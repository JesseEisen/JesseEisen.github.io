<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="">
    <meta name="keywords"  content="blog, note, life, 博客, 生活, reading">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Bash Shell Script 杂记 - 林康的博客 | L.K. Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="shell 作为日常编程中比较方便的工具，通过一些 shell 脚本可以完成很多的事情，但是 shell 本身的一些语法比较古怪，且在不同的系统上所体现的结果有时候也不尽相同。日常使用中我们会遇到一些问题，同时也会积累一些比较好的惯用法，这篇文章主要的目的就是对某些细节进行分析，同时也会对一些习惯用法进行总结。注意本文所提及的语法在 bash 中验证通过，所以如果你使用的是 zsh 或者其他...">
    
    <meta property="article:published_time" content="2017-10-15T00:00:00Z">
    
    
    <meta property="article:author" content="L.K.">
    
    
    <meta property="article:tag" content="bash">
    
    <meta property="article:tag" content="笔记">
    
    
    <meta property="og:image" content="http://localhost:4000/img/sc.jpg">
    <meta property="og:url" content="http://localhost:4000/2017/10/15/bash-shell/">
    <meta property="og:site_name" content="林康的博客 | L.K. Blog">
    
    <title>Bash Shell Script 杂记 - 林康的博客 | L.K. Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2017/10/15/bash-shell/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">L.K. Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">Archive</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/inpost/post-bash-script.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/inpost/post-bash-script.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=bash" title="bash">bash</a>
                        
                        <a class="tag" href="/archive/?tag=%E7%AC%94%E8%AE%B0" title="笔记">笔记</a>
                        
                    </div>
                    <h1>Bash Shell Script 杂记</h1>
                    
                    <h2 class="subheading">记录和解释难以顺畅使用的Shell</h2>
                    <span class="meta">Posted by L.K. on October 15, 2017</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>shell 作为日常编程中比较方便的工具，通过一些 shell 脚本可以完成很多的事情，但是 shell 本身的一些语法比较古怪，且在不同的系统上所体现的结果有时候也不尽相同。日常使用中我们会遇到一些问题，同时也会积累一些比较好的惯用法，这篇文章主要的目的就是对某些细节进行分析，同时也会对一些习惯用法进行总结。注意本文所提及的语法在 bash 中验证通过，所以如果你使用的是 zsh 或者其他 shell， 在使用脚本的时候建议加上: <code class="highlighter-rouge"><span class="c">#!/usr/bin/env bash</span></code> 。</p>

<hr />

<h3 id="positional-parameter-简述">positional parameter 简述</h3>

<p>在 bash 手册中，位置参数是这样定义的：</p>

<blockquote>
  <p>A positional parameter is a parameter denoted by one or more digits, other than the single  digit  0.
Positional  parameters  are  assigned from the shell’s arguments when it is invoked, and may be reassigned using the set builtin command.</p>
</blockquote>

<p>通常我们最熟悉的就是使用 <code class="highlighter-rouge">$1</code> 这样的数字代表的变量。如果超过了10个后，我们可以这样使用 <code class="highlighter-rouge">${11}</code> 。此外还有一些特殊的位置变量。<code class="highlighter-rouge">$*</code> ,<code class="highlighter-rouge">$@</code>, <code class="highlighter-rouge">$#</code> ,<code class="highlighter-rouge">$FUNCNAME</code>。 最后一个变量其实在一定情况下和 $0 是相同的。</p>

<p>操作位置参数的方式可以通过内置命令 <code class="highlighter-rouge">shift</code> 。顾名思义就是切换位置参数，如果 shift 不带参数的话，则按位一个一个的切换，<strong>同时也可以指定参数，一次性切换多个</strong>，下面通过一个例子说明一下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">while</span> <span class="o">[</span> <span class="s2">"</span><span class="k">${</span><span class="nv">1</span><span class="p">+defined</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
	<span class="c"># do something </span>
	<span class="nb">shift
</span><span class="k">done</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>遍历整个位置参数，同时还防止当 <code class="highlighter-rouge">$1</code> 为空的时候会提前停止的情况，defined 是我们根据实际情况预先定义的。</p>

<p>我们还可以使用 for 循环来遍历位置参数，比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for </span>arg<span class="p">;</span> <span class="k">do
	 </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$arg</span><span class="s2">"</span>
<span class="k">done</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这个是使用的位置参数本身作为遍历对象，只会读取位置参数而不会修改，这个算是一个比较安全的操作。</p>

<p>提到位置参数，有两个经常容易混淆的参数必须要对比到，根据不同的情况的需要，我们可以灵活的使用相应的参数及其形式。 下面通过一个表来展示下这两者的差别。</p>

<p>​</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">变量</th>
      <th style="text-align: left">输出结果</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">$*</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">$1 $2 $3 ... ${N}</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">$@</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">$1 $2 $3 ... ${N}</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">"$*"</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">"$1c$2c$3c...c${N}"</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">"$@"</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">"$1" "$2" "$3" ... "${N}"</code></td>
    </tr>
  </tbody>
</table>

<p>​</p>

<p>这边的 <code class="highlighter-rouge">c</code> 是表示的 IFS 的第一个参数。一般情况下还是建议使用 <code class="highlighter-rouge">"$@"</code> 。 也许你会从中发现一个小的陷阱，即当我们在使用遍历位置参数的时候，如果使用 <code class="highlighter-rouge">"$*"</code> 将位置参数传到函数中，循环只会执行一次。并不是我们所期望的多次执行。 此外位置参数不添加引号时会自动扩展引号，举个例子就明白了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
<span class="c"># script.sh</span>
showcount<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"we get"</span> <span class="nv">$# </span><span class="s1">'parameter(s)'</span>
<span class="o">}</span>

showcount <span class="nv">$@</span>
showcount <span class="nv">$*</span>
showcount <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
showcount <span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span>

<span class="nv">$ </span>./script.sh <span class="s1">'a b'</span> c d
we get 4 parameter<span class="o">(</span>s<span class="o">)</span>
we get 4 parameter<span class="o">(</span>s<span class="o">)</span>
we get 3 parameter<span class="o">(</span>s<span class="o">)</span>
we get 1 parameter<span class="o">(</span>s<span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>可以看出前两者将引号中的内容扩展了。同时这个也展示了使用 <code class="highlighter-rouge">"$*"</code> 作为函数参数传入是，变量个数为 <code class="highlighter-rouge">1</code>。</p>

<p>此外在数组那块还会提到和位置参数相关的内容，现在暂时不过多涉及。</p>

<h3 id="使用-set-设置-positional-parameter">使用 set 设置 positional parameter</h3>

<p>set 的一个作用就是用来设置位置参数，现在不讨论 set 在脚本调试和其他功效上的内容，只讨论在设置位置参数时的作用。首先先看一个简单的例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">set </span>a b c
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$3</span><span class="s2">"</span>
a b c
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这边的 <code class="highlighter-rouge">$1,$2,$3</code> 就是位置参数。 我们可以通过 <code class="highlighter-rouge">set</code> 来修改位置参数，比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">set </span>b c
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>
b c
<span class="nv">$ </span><span class="nb">set </span>a <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$3</span><span class="s2">"</span>
a b c
</pre></td></tr></tbody></table></code></pre></div></div>

<p>我们后面修改了该位置参数，在原有的基础上，增加了一个新的参数 <code class="highlighter-rouge">a</code> ， 通过这个属性，我们可以做更多的事情，比如 <code class="highlighter-rouge">double</code> 一下所有的位置参数之类的。 我们再来看下一个例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">set</span> <span class="nt">--</span> <span class="s2">" hello,   world  "</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$*</span>
hello, world
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$1</span>
hello, world
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这个例子从侧面看可以去掉多个空格，实际上的原理很简单，利用了 <code class="highlighter-rouge">$*</code> 的默认输出的是 <code class="highlighter-rouge">$1 $2 $3 ...</code>，  注意这里没有对变量添加引号，且我们可以看到位置参数并没有被分隔开。这一定程度上可以用做 <code class="highlighter-rouge">trim</code> 函数。</p>

<h3 id="here-documents-和-here-strings">Here documents 和 Here strings</h3>

<p>这两者都是重定向的一种形式。<strong>Here documents</strong> 的语法很简单，不过由于也有两种形式，所以在使用的过程中也有一定的差别。语法如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nb">command</span> &lt;&lt;<span class="o">[</span>-]word
...
...
word
</pre></td></tr></tbody></table></code></pre></div></div>

<p>一般用 here documents 的比较多的是在 usage 函数中。在这中间的所有的内容都是直接输出的, 不会做任何的修改，不过注意一点的是，如果使用的是 <code class="highlighter-rouge">&lt;&lt;-</code> 那么会将输出的文本中的前导tab去除掉。下面的几个例子展示了 here documents 的实际使用：</p>

<ul>
  <li>抑制变量的扩展</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="sh">'</span><span class="no">EOF</span><span class="sh">'
&gt; This is my name </span><span class="nv">$name</span><span class="sh">
&gt; EOF
This is my name </span><span class="nv">$name</span><span class="sh">       # 这个变量没有被转换成相应的内容
</span></pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>在管道中使用</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="sh">'</span><span class="no">EOF</span><span class="sh">' | sed 's/a/b/g'
&gt; abc
&gt; nab
&gt; EOF
bbc
nbb
</span></pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<p><strong>Here strings</strong> 的基本语法是 <code class="highlighter-rouge">&lt;&lt;&lt;</code>。它的主要作用是可以替代管道进行输入，我们知道使用管道的时候实际是操作是在 subshell 中进行的，所以有些变量在退出了 subshell 的环境后就不存在了。比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"Hello world"</span> | <span class="nb">read </span>first second
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$first</span> <span class="nv">$second</span>
<span class="c"># nothing will output</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>遇到这种情况，一种折中的办法就是在 subshell 中进行输出，使用 group command 进行。但是如果我们想在当前的环境中使用变量，这种方式就不适合了。因此现在使用 Here strings 就比较合适了。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">read </span>first second <span class="o">&lt;&lt;&lt;</span> <span class="s2">"Hello World"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$first</span> <span class="nv">$second</span>
Hello World
</pre></td></tr></tbody></table></code></pre></div></div>

<p>looks good！很完美的解决了这个问题。</p>

<h3 id="多使用-printf-而不是-echo">多使用 printf 而不是 echo</h3>

<p>shell 中的 printf 在一定程度上和 C 语言中的 printf 类似，语法上基本上差别不大。熟悉 C 的话，使用这些还是很简单的。echo 默认输出换行符，且在不同的系统上的表现也不同，同时 <code class="highlighter-rouge">-n</code> 是没办法输出来的。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>$ echo -n
$ echo '-n'  # cannot output
$ echo -e '\055n'
-n
</pre></td></tr></tbody></table></code></pre></div></div>

<p>通过 printf 可以做一些比较 cool 的事儿。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c"># 格式化输出</span>
<span class="nb">printf</span> <span class="s1">'%d | %0o | 0x%x'</span> <span class="s2">"126"</span> <span class="s2">"126"</span> <span class="s2">"126"</span>
<span class="c"># 绘制水平线</span>
<span class="nb">printf</span> <span class="s1">'%.0s-'</span> <span class="o">{</span>1..20<span class="o">}</span><span class="p">;</span> <span class="nb">echo</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="数学计算">数学计算</h3>

<p>目前推荐使用 <code class="highlighter-rouge">$(( ))</code> 进行数学计算，虽然使用 <code class="highlighter-rouge">let</code>  也可以完成相应的工作但是使用前者是比较稳妥的，且不容易出错。</p>

<p>首先在 bash 中，数字的表示形式有如下几种：</p>

<ul>
  <li><code class="highlighter-rouge">0...</code>  表示为八进制数</li>
  <li><code class="highlighter-rouge">0x...</code> 或者 <code class="highlighter-rouge">0X...</code>  表示为十六进制数</li>
  <li><code class="highlighter-rouge">&lt;BASE&gt;#...</code>  根据 base 来解析后面的数字。</li>
</ul>

<p>其余的则会被当做十进制的数来使用。 对于第三种情形，需要着重说一下，这个语法的目的是为了将其他不同 base 的值转换成十进制的值。 比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%s\n'</span> <span class="k">$((</span><span class="m">16#abc</span><span class="k">))</span>
2748
<span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%s\n'</span> <span class="k">$((</span><span class="m">2#010101</span><span class="k">))</span>
21
<span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%s\n'</span> <span class="k">$((</span><span class="m">10#abc</span><span class="k">))</span>
bash: 10#abc: value too great <span class="k">for </span>base <span class="o">(</span>error token is <span class="s2">"10#abc"</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>所以我们可以看到，即使数字没有使用相应的机制标识开头也同样可以转换成十进制。同样的如果想将十进制转换成其他的进制的，可以使用 <code class="highlighter-rouge">printf</code> 格式化输出。</p>

<p>下面来说一下计算部分，在 <code class="highlighter-rouge">$(())</code> 中支持大部分的数学计算语法。逻辑运算，位操作，以及常规的数据运算都是支持的。下面通过一些基本的例子展示下数学计算：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%d\n'</span> <span class="k">$((</span><span class="nv">a</span><span class="o">=</span><span class="m">2</span>, a+<span class="o">=</span><span class="m">3</span><span class="k">))</span>
5
<span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%d\n'</span> <span class="k">$((</span><span class="nv">a</span><span class="o">=</span><span class="m">1</span>, a++<span class="k">))</span>
1
<span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%d\n'</span> <span class="k">$((</span><span class="m">1</span><span class="o">+</span><span class="m">3</span><span class="k">))</span>
4
</pre></td></tr></tbody></table></code></pre></div></div>

<p>我们需要注意的是，返回值是最后一个表达式的结果。 除此之外，在 <code class="highlighter-rouge">$(())</code> 中也是支持变量操作的。比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="o">((</span><span class="nv">a</span><span class="o">=</span>16#abc, <span class="nv">b</span><span class="o">=</span>16#<span class="k">${</span><span class="nv">a</span>:0:2<span class="k">}</span><span class="o">))</span><span class="p">;</span> <span class="nb">printf</span> <span class="s1">'%s, %s\n'</span> <span class="nv">$a</span> <span class="nv">$b</span>
2748, 39
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这边涉及到了子串扩展，这个在后面详细说明。 不过并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nv">$ x</span><span class="o">=</span>1
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">$((</span><span class="nv">$x</span><span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="k">))</span> <span class="c"># 将会被扩展为 $((1[0]))</span>
bash: 1[0]: syntax error: invalid arithmetic operator <span class="o">(</span>error token is <span class="s2">"[0]"</span><span class="o">)</span>
<span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%d\n'</span> <span class="k">$((${</span><span class="nv">x</span><span class="p">[0]</span><span class="k">}))</span> 
1
<span class="nv">$ </span><span class="nb">printf</span> <span class="s1">'%d\n'</span> <span class="k">$((</span><span class="s2">"</span><span class="nv">$x</span><span class="s2">"</span> <span class="o">==</span> <span class="m">1</span><span class="k">))</span>  <span class="c"># 解析为 $(("1")) </span>
1
</pre></td></tr></tbody></table></code></pre></div></div>

<p>上面的这一点我们就得注意下，有些变量并不一一定能在数学扩展中解析出来。此外，我们也可以用变量扩展作为布尔值的判断。比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="o">((</span>1 <span class="o">==</span> 2<span class="o">))</span><span class="p">;</span> <span class="k">then
	</span><span class="nb">echo</span> <span class="s2">"true"</span>
<span class="k">else
	</span><span class="nb">echo</span> <span class="s2">"false"</span>
<span class="k">fi</span>
<span class="c"># false</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>shell 中的数学计算基本上就是这些，还有其他的内容后续继续增加。</p>

<h3 id="正则表达式">正则表达式</h3>

<p>我们在写脚本时，可以使用 <code class="highlighter-rouge">sed</code>, <code class="highlighter-rouge">awk</code>, <code class="highlighter-rouge">perl</code> 等工具自带的正则。但是如果不是很复杂的情况， 单独使用 bash 自带的正则就可以了。bash 本身支持的是 ERE 语法，同时也支持 group 匹配。RE 的语法在这里不多说了，正则表达式在有时候会比较清晰一些。比如下面的这个例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ls 
</span>1_abc.txt  245_def.txt 
</pre></td></tr></tbody></table></code></pre></div></div>

<p>将上述的文件名中的数字转换成16进制的。 这个问题解决的办法很多，我们尝试使用 RE 来解决这个问题。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>convert<span class="o">()</span> <span class="o">{</span>
    <span class="nv">filename</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
    <span class="nv">rx</span><span class="o">=</span><span class="s1">'^([0-9]+)_(.*)$'</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="o">=</span>~ <span class="nv">$rx</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    	</span><span class="nb">mv</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span><span class="nb">printf</span> <span class="s1">'%04x%s'</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BASH_REMATCH</span><span class="p">[1]</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BASH_REMATCH</span><span class="p">[2]</span><span class="k">}</span><span class="s2">"</span><span class="k">)</span><span class="s2">"</span>
    <span class="k">fi</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>匹配到数字部分和字符串部分然后将其通过 <code class="highlighter-rouge">printf</code> 输出。匹配到的分组部分保存在 <code class="highlighter-rouge">BASH_REMATCH </code>中， 不过通过 bash 的字符串子串操作也可以轻松完成。不过在获取子串这块语法会存在一些混淆，这个后面再说，现在看看使用子串如何解决这个问题。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c"># bad， not safe</span>
convert<span class="o">()</span> <span class="o">{</span>
    <span class="nv">number</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="p">%%_*</span><span class="k">}</span>
    <span class="nv">other</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="p">##*_</span><span class="k">}</span>
    <span class="nb">mv</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span><span class="nb">printf</span> <span class="s1">'%04x%s'</span> <span class="s2">"</span><span class="nv">$number</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$other</span><span class="s2">"</span><span class="k">)</span><span class="s2">"</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>实际上通过子串分割更加的快捷，不过需要保证每个文件都是统一的格式，不存在其他的格式。所以使用正则的好处是对于不符合条件的文件名不进行分割，在一定程度上更加的安全一些。</p>

<h3 id="字符串子串">字符串子串</h3>

<p>bash 中有不少的扩展，其中包括 <code class="highlighter-rouge">paramater expand</code> 。 先不讨论有关变量赋值的扩展，只讨论和子串有关的部分。首先和其他脚本语言中比较类似的切片语法。</p>

<ul>
  <li>${parameter:offset[:length]}</li>
</ul>

<p>这个扩展很好理解，返回值为 parameter 从 offset 处开始的 length 个字符。 这个 offset 可以为负数，其中 length 是可选。 parameter 可以为位置参数，在这种情况下索引是默认从 1 开始的。其他的情况下索引是从 0 开始的。一个简单的例子展示一下这个是如何扩展的。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat </span>substring.sh
<span class="c">#!/usr/bin/env bash</span>
<span class="nv">str</span><span class="o">=</span><span class="s2">"This is a string"</span>
<span class="nb">printf</span> <span class="s2">"%s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="p">@</span>:2:2<span class="k">}</span><span class="s2">"</span>
<span class="nb">printf</span> <span class="s2">"%s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">str</span>:5<span class="k">}</span><span class="s2">"</span>
<span class="nv">$ </span>./substring.sh 1 2 3 4 5
2 
3
is a string
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这个扩展对数组也是可以使用的，不过如果使用在关系型数组上，其结果是未定义的。</p>

<ul>
  <li>${parameter#word}</li>
  <li>${parameter##word}</li>
</ul>

<p>移除掉匹配的前缀，所谓的前缀就是 word 所表示的。word 部分可以使用通配符来表示，有关通配符的内容见后面。 这个匹配一般在获取后缀名或者是目录名比较有用。 比如下面的例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nv">$ mypath</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$mypath</span><span class="s2">"</span>
/home/user/work/shell
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">mypath</span><span class="p">#*/</span><span class="k">}</span>
home/user/work/shell
<span class="nv">$ </span><span class="nb">echo</span> <span class="k">${</span><span class="nv">mypath</span><span class="p">##*/</span><span class="k">}</span>
shell
</pre></td></tr></tbody></table></code></pre></div></div>

<p>一个 <code class="highlighter-rouge">#</code> 表明匹配最短的前缀； 两个 <code class="highlighter-rouge">##</code> 表明匹配最长的前缀。 前缀部分的内容需根据实际情况来决定。</p>

<ul>
  <li>${parameter%word}</li>
  <li>${parameter%%word}</li>
</ul>

<p>移除掉后缀，原理同上面的。word 部分支持通配符的表示。这个一般在获取文件名或者目录的 path 比较有用。所以我们可以这样使用：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="nv">$ myfile</span><span class="o">=</span>base.name.txt
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">myfile</span><span class="p">%.*</span><span class="k">}</span><span class="s2">"</span>
base.name
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">myfile</span><span class="p">%%.*</span><span class="k">}</span><span class="s2">"</span>
base
</pre></td></tr></tbody></table></code></pre></div></div>

<p>但是也能看到这个扩展的局限性，就是匹配的结果要么最少，要么最多，没有达到一个平衡，不过这些都需要我们自己去衡量与选择。</p>

<ul>
  <li>${parameter/pattern/string}</li>
</ul>

<p>模式替换，实际上就是将匹配到的内容用 string 替换掉。这个功能有一些使用的技巧，整理如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">场景</th>
      <th>结果</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">pattern 以<code class="highlighter-rouge">/ </code>开头</td>
      <td>替换掉所有匹配的 pattern</td>
    </tr>
    <tr>
      <td style="text-align: left">pattern 以<code class="highlighter-rouge">#</code> 开头</td>
      <td>必须是头部就匹配到 pattern</td>
    </tr>
    <tr>
      <td style="text-align: left">pattern 以<code class="highlighter-rouge">%</code> 开头</td>
      <td>必须是尾部开始匹配到 pattern</td>
    </tr>
    <tr>
      <td style="text-align: left">string 为空</td>
      <td>删除掉匹配到的 pattern</td>
    </tr>
  </tbody>
</table>

<p>除此之外，如果参数是 <code class="highlighter-rouge">@</code> 或者  <code class="highlighter-rouge">*</code> 的话，则对每一个参数都使用这样的匹配。下面通过几个例子来简单说明下:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="nv">$ target</span><span class="o">=</span><span class="s2">"This is a string"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">target</span><span class="p">/is/IS</span><span class="k">}</span><span class="s2">"</span>  <span class="c"># only first matched will be replaced</span>
ThIS is a string
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">target</span><span class="p">//is/IS</span><span class="k">}</span><span class="s2">"</span> <span class="c"># each matched will be replaced</span>
ThIS IS a string
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">target</span><span class="p">/#T/t</span><span class="k">}</span><span class="s2">"</span> <span class="c"># replace first character</span>
this is a string
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">target</span><span class="p">/%sting/STRING</span><span class="k">}</span><span class="s2">"</span> <span class="c"># repalce end if the string</span>
This is a STRING
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">target</span><span class="p">/is</span><span class="k">}</span><span class="s2">"</span> <span class="c"># delete first matched</span>
Th is a string
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"</span><span class="k">${</span><span class="nv">target</span><span class="p">//is</span><span class="k">}</span><span class="s2">"</span> <span class="c"># delete all matched</span>
Th  a string
</pre></td></tr></tbody></table></code></pre></div></div>

<p>主要是需要记住一些符号的使用，其他的内容，现在不在这边过多的涉及，讨论过多后更加容易混淆，这边只介绍和子串相关的内容，至于大小写转换的功能，这些提及的比较少，所以也不整理了。</p>

<h3 id="通配符">通配符</h3>

<p>要完整的理清统配符的内容，得单独理出一篇。不过在这边主要是说明一些最基本的。至于通过 <code class="highlighter-rouge">shopt</code> 打开相关的扩展之类的，暂时不涉及。</p>

<p>实际上通配符只是一个低配版的 RE，语法标记上简化了很多。注意  <code class="highlighter-rouge">.</code> 在通配符中没有特殊含义，仍然代表的是原本的含义。 在 bash 中一般是如下的几个标记：</p>

<ul>
  <li><code class="highlighter-rouge">*</code>  匹配一个或者多个字符</li>
  <li><code class="highlighter-rouge">?</code>  匹配一个字符</li>
  <li><code class="highlighter-rouge">[...]</code> 匹配这个集合中的任意一个字符</li>
</ul>

<p>我们使用的最多的是 <code class="highlighter-rouge">*</code> ，这在遍历文件是最常用到：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for </span>file <span class="k">in</span> <span class="k">*</span><span class="p">;</span> <span class="k">do</span>
	......
<span class="k">done</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>除此之外，我们在 case 中经常会使用到这个，比如验证输入Yes/NO。 我们可以这样做：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">case</span> <span class="s2">"</span><span class="nv">$input</span><span class="s2">"</span> <span class="k">in</span>
	<span class="o">[</span>Yy]|<span class="s1">''</span><span class="p">)</span>  <span class="nv">end</span><span class="o">=</span>1<span class="p">;</span>
	<span class="o">[</span>Nn]<span class="k">*</span><span class="o">)</span>    <span class="nv">end</span><span class="o">=</span>0<span class="p">;</span>
	<span class="k">*</span><span class="o">)</span>        <span class="nb">echo</span> <span class="s2">"unknown character"</span>
<span class="k">esac</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>实际上我们在使用  <code class="highlighter-rouge">[[</code>时也可以使用通配符，比如下面这样的方式：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="o">[[</span> <span class="nv">$input</span> <span class="o">=</span> <span class="o">[</span>Ee]rror <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> 
	... 
<span class="k">fi</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>此外还有一些范围相关的通配符，比如: <code class="highlighter-rouge">[a-h]</code>, <code class="highlighter-rouge">[[:alnum:]]</code>，<code class="highlighter-rouge">[[:digit:]_.]</code> 等，这些用法是合法的。如果你熟悉 RE，这些应该不会太陌生。 至于取反操作有的是 <code class="highlighter-rouge">!</code> , 表示非。 余下的扩展部分可以看之前整理的<a href="http://jesseeisen.github.io/2016/08/16/shell-glob.html">shell-glob</a>， 这里面有对扩展部分的例子。</p>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/08/01/redirection/" data-toggle="tooltip" data-placement="top" title="Bash 重定向">
                        Previous<br>
                        <span>Bash 重定向</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/06/27/command-line/" data-toggle="tooltip" data-placement="top" title="命令行解析">
                        Next<br>
                        <span>命令行解析</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
    </div>
</section>


                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "jesseeisen";
    var disqus_identifier = "/2017/10/15/bash-shell";
    var disqus_url = "http://localhost:4000/2017/10/15/bash-shell/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  <li>
    <a target="_blank" href="https://www.zhihu.com/people/jessechen-52">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa  fa-stack-1x fa-inverse">知</i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="http://weibo.com/linkangchen">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/JesseEisen">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; L.K. Blog 2019
                    <br>
                    Powered by <a href="https://jesseeisen.github.io">L.K. Blog</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=jesseeisen&repo=jesseeisen.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>

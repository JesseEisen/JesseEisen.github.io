<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="">
    <meta name="keywords"  content="blog, note, life, 博客, 生活, reading">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="命令行解析 - 林康的博客 | L.K. Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="我们在日常编程中，对命令行参数的解析是不可避免的。一般情况下，不同的编程语言都提供了相应的库函数来解析命令行参数。这些库函数有些是比较顺手的，有些则比较原始，通过了解一下不同的解析思路，利用不同语言自有的特性实现一些顺手的命令行解析工具。

">
    
    <meta property="article:published_time" content="2018-06-27T00:00:00Z">
    
    
    <meta property="article:author" content="L.K.">
    
    
    <meta property="article:tag" content="Linux">
    
    <meta property="article:tag" content="Programming">
    
    
    <meta property="og:image" content="http://localhost:4000/img/sc.jpg">
    <meta property="og:url" content="http://localhost:4000/2018/06/27/command-line/">
    <meta property="og:site_name" content="林康的博客 | L.K. Blog">
    
    <title>命令行解析 - 林康的博客 | L.K. Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2018/06/27/command-line/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">L.K. Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">Archive</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/inpost/post-commandline-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/inpost/post-commandline-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=Linux" title="Linux">Linux</a>
                        
                        <a class="tag" href="/archive/?tag=Programming" title="Programming">Programming</a>
                        
                    </div>
                    <h1>命令行解析</h1>
                    
                    <h2 class="subheading">分析市面上常用的几种命令行解析方式</h2>
                    <span class="meta">Posted by L.K. on June 27, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>我们在日常编程中，对命令行参数的解析是不可避免的。一般情况下，不同的编程语言都提供了相应的库函数来解析命令行参数。这些库函数有些是比较顺手的，有些则比较原始，通过了解一下不同的解析思路，利用不同语言自有的特性实现一些顺手的命令行解析工具。</p>

<hr />

<h3 id="命令行基本概念">命令行基本概念</h3>

<p>首先我们得了解一下命令行的基本格式。比如 GNU 的命令行参数的语法惯例如下：</p>

<ul>
  <li>命令行参数若是以 <code class="highlighter-rouge">-</code> 开头的则认为是选项（options）</li>
  <li>多个选项可以在单个的 <code class="highlighter-rouge">-</code>  后面（注意选项应为不带参数的形式）</li>
  <li>选项的名字是一个单个的字符数字的形式（alphanumeric）</li>
  <li>选项后面可以带参数</li>
  <li>选项和他的参数之间可以有或者不存在分隔符， 比如 <code class="highlighter-rouge">-o foo</code>  和 <code class="highlighter-rouge">-ofoo</code>  可以认为是相同的</li>
  <li>选项一般在其他非选项的参数前面出现</li>
  <li><code class="highlighter-rouge">--</code>  表示参数终止， 在这之后的参数都会被认为是非选项，即使是带了 <code class="highlighter-rouge">-</code>  的</li>
  <li>单独的一个 <code class="highlighter-rouge">-</code>  一般用来表示读取或者写向标准输入输出</li>
  <li>选项可以以任意顺序出现，同一个选项也可以出现多次</li>
</ul>

<p>上述的语法，大体上说明了一个基本的命令行该有的形式，但是还有一些细节没有涉及到。 比如一个选项是否接受一个可选参数或者必须带有一个参数。 我们在看一些命令的手册时，往往会看到这样的几个符号：</p>

<ul>
  <li><code class="highlighter-rouge">[]</code></li>
  <li><code class="highlighter-rouge">&lt;&gt;</code></li>
  <li><code class="highlighter-rouge">()</code></li>
  <li><code class="highlighter-rouge">|</code></li>
  <li><code class="highlighter-rouge">...</code></li>
</ul>

<p>这几个符号要细究下来，组合的形式比较多，所表示的含义也不尽相同。所以想要定义一个比较标准的命令行 Usage，对于这些参数的组合使用是必须了解的。</p>

<ul>
  <li>参数</li>
</ul>

<p>一般我们使用  <code class="highlighter-rouge">&lt;argument&gt;</code>  表示参数， 这个参数即为选项后面所需要带的参数，或者是正常命令行参数。 比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre> program &lt;arg1&gt; &lt;arg2&gt;
 program <span class="nt">-o</span> &lt;file&gt;
 program <span class="nt">--input</span><span class="o">=</span>&lt;<span class="nb">source</span><span class="o">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这些都是表示参数，一般参数提供出来，未加修饰符都默认是必须提供的参数。</p>

<ul>
  <li>可选项</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>program <span class="o">[</span><span class="nt">-w</span> option] <span class="o">[</span><span class="nt">-f</span> value]
program <span class="o">[</span><span class="nt">-f</span><span class="o">]</span> <span class="o">[</span><span class="nt">-o</span><span class="o">]</span> <span class="o">[</span>&lt;argument&gt;]
</pre></td></tr></tbody></table></code></pre></div></div>

<p>使用 <code class="highlighter-rouge">[]</code> 表明这个参数或者选项是可选的，可选的意思即为在运行命令时这些是可提供或者不提供的。</p>

<ul>
  <li>互斥</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>program <span class="o">[</span><span class="nt">-a</span> | <span class="nt">-b</span><span class="o">]</span>
类似于如下写法：
program <span class="o">[</span><span class="nt">-a</span><span class="o">]</span>
program <span class="o">[</span><span class="nt">-b</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>互斥表明这两个参数或者多个参数只能选择其中之一，如果都出现了，则会报错, 上面的实例中表示可以都不出现。</p>

<ul>
  <li>必选项</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>program: &lt;argument&gt;
program: <span class="o">(</span><span class="nt">-a</span> &lt;good&gt; | &lt;bad&gt;<span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>使用 <code class="highlighter-rouge">()</code> 是为了来表示必选，或者是作为一个组合的意思。 上面的例子指的是两个选项必须出现其中之一。</p>

<ul>
  <li>重复</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nb">ls</span>: <span class="o">[</span>FILE]...
program: <span class="o">(</span>&lt;from&gt; &lt;to&gt;<span class="o">)</span>...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>重复的意思即为这个参数或者这一组参数可以出现多次。最直观的的就是 <code class="highlighter-rouge">ls</code>  可以有参数, 可以同时有多个参数等。</p>

<p>当我们打开 man 手册的时候，往往会发现在  <code class="highlighter-rouge">SYNOPSIS</code>  这一小节中的内容其实很简单。比如:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">ls</span> <span class="o">[</span>OPTION]... <span class="o">[</span>FILE]...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这边使用 <code class="highlighter-rouge">OPTION</code>  做一个占位符，在后续将选项的具体形式极其使用说明进行详细描述。 这也为我们在编写 Usage 函数时提供了一个思路。</p>

<p>一个简单的 usage 示例：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>Usage: ./test <span class="o">[</span>options]
Options:
        <span class="nt">-V</span>, <span class="nt">--version</span>                 output program version
	<span class="nt">-h</span>, <span class="nt">--help</span>                    output <span class="nb">help </span>information
	<span class="nt">-v</span>, <span class="nt">--verbose</span>                 <span class="nb">enable </span>verbose stuff
	<span class="nt">-r</span>, <span class="nt">--required</span> &lt;arg&gt;          required arg
	<span class="nt">-o</span>, <span class="nt">--optional</span> <span class="o">[</span>arg]          optional arg
</pre></td></tr></tbody></table></code></pre></div></div>

<p>当我们在设计一个命令行工具的时候，一些选项的命名实际上是可以遵循一些惯例的，比如 <code class="highlighter-rouge">--help</code> , <code class="highlighter-rouge">--version</code> 等输出基本程序信息。 GNU 列出了一个在 GNU 软件中所使用到的长选项的<a href="https://www.gnu.org/prep/standards/html_node/Option-Table.html#Option-Table">说明</a>。 目的是为了后续的一个兼容，这对我们日常的编写程序也是有一定的指导意义的。</p>

<p>上面说的这些并不能完全概括所有的情形，只能说作为在 <code class="highlighter-rouge">*nix</code> 上工作的人所习惯的一个范式，不过有了理论基础，实际操作上，不同的语言或者不同的库所提供的解析方式有很大的不同。我们总想解析能做到简单易用，指哪打哪儿的效果，但是现实往往并不能如愿，下面就从我说熟悉几个语言上说一说几种不同的命令行解析思路。</p>

<hr />

<h3 id="awk-语言篇">Awk 语言篇</h3>

<p>之所以将 awk 放在最开始说，是因为 awk 本身并没有提供命令行解析的相关函数或者库， 即使是 gawk 也没有提供相应的库，所以需要我们自己去实现。正因为如此，将其放在最开始说是很有必要的，因为我们需要去从头到尾的实现下 <code class="highlighter-rouge">getopt</code> 函数, 通过这个过程来了解一下 getopt 的基本原理。</p>

<p>getopt 一般是在一个循环中使用。 基本的使用框架如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="err">使用方式：</span>
<span class="k">while</span><span class="p">((</span><span class="n">flag</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">"ab:cd"</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">flag</span><span class="p">){</span>
		<span class="p">...</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>options 是预先定义的，argc 和 argv 表示的是命令行参数，getopt 最简单的思路如下：</p>

<ul>
  <li>从命令行中取出合法的 option （短或者长的参数），解析出 flag</li>
  <li>在 options 中找到对应的 flag， 并检查是否带有参数</li>
  <li>若是需要带参数的，则将下一个命令行参数设置到 Optarg 中，否则该 flag 解析完成， 返回该 flag。</li>
</ul>

<p>一般 getopt 会维护两个全局变量， Optind 和 Optarg， 前者表示解析到第几个命令行参数， 后者表示该 flag 带有的参数。 getopt 使用 <code class="highlighter-rouge">:</code>  表示一个 flag 是带有参数的。</p>

<p>下面是 GNU awk 对 getopt 的一个简单实现：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="k">function </span>getopt<span class="o">(</span>argc, argv, options,   thisopt, i<span class="o">)</span>
<span class="o">{</span>
        <span class="k">if</span><span class="o">(</span>length<span class="o">(</span>options<span class="o">)</span> <span class="o">==</span> 0<span class="o">){</span>
                <span class="k">return</span> <span class="nt">-1</span>
        <span class="o">}</span>
		<span class="c"># no support  --</span>
        <span class="k">if</span><span class="o">(</span>argv[Optind] <span class="o">==</span> <span class="s2">"--"</span><span class="o">){</span>
                Optind++
                _opti <span class="o">=</span> 0
                <span class="k">return</span> <span class="nt">-1</span>
        <span class="o">}</span><span class="k">else if</span><span class="o">(</span>argv[Optind] <span class="o">!</span>~ /^-[^: <span class="o">]</span>/<span class="o">){</span>
        <span class="c"># flag must start by - and not contain : and space</span>
                _opti <span class="o">=</span> 0
                <span class="k">return</span> <span class="nt">-1</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span>_opti <span class="o">==</span> 0<span class="o">)</span>
                _opti <span class="o">=</span> 2
        thisopt <span class="o">=</span> substr<span class="o">(</span>argv[Optind], _opti, 1<span class="o">)</span>
        Optopt <span class="o">=</span> thisopt
        i <span class="o">=</span> index<span class="o">(</span>options, thisopt<span class="o">)</span>
        <span class="k">if</span><span class="o">(</span>i <span class="o">==</span> 0<span class="o">){</span>
                <span class="k">if</span><span class="o">(</span>Opterr<span class="o">)</span>
                        <span class="nb">printf</span><span class="o">(</span><span class="s2">"%c -- invalid option</span><span class="se">\n</span><span class="s2">"</span>, thisopt<span class="o">)</span> <span class="o">&gt;</span> <span class="s2">"/dev/stderr"</span>
                <span class="k">if</span><span class="o">(</span>_opti <span class="o">&gt;=</span> length<span class="o">(</span>argv[Optind]<span class="o">)){</span>
                        Optind++
                        _opti <span class="o">=</span> 0
                <span class="o">}</span><span class="k">else
                        </span>_opti++
                <span class="k">return</span> <span class="s2">"?"</span>
        <span class="o">}</span>

        <span class="k">if</span><span class="o">(</span>substr<span class="o">(</span>options, i+1, 1<span class="o">)</span> <span class="o">==</span> <span class="s2">":"</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span>length<span class="o">(</span>substr<span class="o">(</span>argv[Optind], _opti + 1<span class="o">))</span> <span class="o">&gt;</span> 0<span class="o">)</span>
                        Optarg <span class="o">=</span> substr<span class="o">(</span>argv[Optind], _opti + 1<span class="o">)</span>  <span class="c"># -abcfoo</span>
                <span class="k">else
                        </span>Optarg <span class="o">=</span> argv[++Optind]
                _opti <span class="o">=</span> 0
        <span class="o">}</span><span class="k">else
                </span>Optarg <span class="o">=</span> <span class="s2">""</span>

        <span class="k">if</span><span class="o">(</span>_opti <span class="o">==</span> 0 <span class="o">||</span> _opti <span class="o">&gt;=</span> length<span class="o">(</span>argv[Optind]<span class="o">)){</span>
                Optind++
                _opti <span class="o">=</span> 0
        <span class="o">}</span><span class="k">else
                </span>_opti++
        <span class="k">return </span>thisopt
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这个 getopt 的实现不支持长参数解析，同时使用上也很有局限性，但是很清楚的说明了 getopt 的基本原理。 我们可以这么使用：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>BEGIN <span class="o">{</span>
	Opterr <span class="o">=</span> 1
    Optind <span class="o">=</span> 1

    <span class="k">while</span><span class="o">((</span>flag <span class="o">=</span> getopt<span class="o">(</span>ARGC, ARGV, <span class="s2">"ab:cd"</span><span class="o">))</span> <span class="o">!=</span> <span class="nt">-1</span><span class="o">)</span>
    	<span class="nb">printf</span><span class="o">(</span><span class="s2">"flag=%c , optarg=%s</span><span class="se">\n</span><span class="s2">"</span>, flag, Optarg<span class="o">)</span>

    <span class="k">for</span><span class="o">(</span><span class="p">;</span> Optind &lt; ARGC<span class="p">;</span> Optind++<span class="o">)</span>
    	<span class="nb">printf</span><span class="o">(</span><span class="s2">"Non-option argument:[%d] %s</span><span class="se">\n</span><span class="s2">"</span><span class="nb">.</span> Optind, ARGV[Optind]<span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>使用 getopt 主体在结果处理上，每次解析出来的 flag 和 optval 可以按照我们想要的方式进行处理。由于 getopt 的使用方式是通用的，如果你熟悉 getopt ，只要支持 getopt 的情况下，一般都能做到上手就用，最多也就是阅读下 man 手册上的一些细节和 feature。</p>

<p>上面实现的 getopt 不支持长参数，若要加入对长参数的解析并不是很困难，只需要在执行解析前将长短 flag 做一个映射即可，这在 awk 中可以直接使用关系型数组即可，比如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>longopts[<span class="s2">"create"</span><span class="o">]</span> <span class="o">=</span> <span class="s2">"c"</span>
longopts[<span class="s2">"verbose"</span><span class="o">]</span> <span class="o">=</span> <span class="s2">"V"</span>
...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>设置这个 map 后，当我们解析出是长参数时，判断一下当前定义的长参数是否在 longopts 中，可以这么做：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">if</span><span class="o">(!(</span>lopt <span class="k">in </span>longopts<span class="o">)){</span>
    <span class="c"># error print</span>
    <span class="k">return</span> <span class="s2">"?"</span>
<span class="o">}</span>

opt <span class="o">=</span> longopts[lopt]
<span class="c"># then we just return the opt</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>一般命令行操作都会提供长短参数配套使用机制的。但是也有需求是只提供长参数，并不与短参数绑定，所以只需要将这个 map 的值设置成我们期望返回的即可。</p>

<p>awk 的好处就在于能够快速搭建一个原型，这对我们后续对 C 的分析有很大的帮助。</p>

<hr />

<h3 id="c-语言篇">C 语言篇</h3>

<p>C 语言中我们大多使用的就是 <code class="highlighter-rouge">getopt</code> 和 <code class="highlighter-rouge">getopt_long</code>  这两个标准库中的函数，我们所以做的就是在定义好 flag 后需要自己去解析，一方面很自由，如何去处理 flag 所带的参数是由开发者自己去实现；另一方面又显得很繁琐， 因为有时候我只想解析后就能直接使用 。</p>

<p>C 中的 getopt 和上述的 awk 方式类似，所以这边不多加叙述。 按照一种更好的做法，在 C 中最好是使用 getopt_long，因为有对长参数的支持。下面就来说一说 getopt_long 的基本使用情况。</p>

<p>在 AWK 篇的最后我们简单的说了下实现对长参数的解析的方式，C 中没有关系型数组，但是 C 可以定义结构，因此，当我们使用 getopt_long 的时候，我们需要初始化一个结构体。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">option</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> 	<span class="n">has_arg</span><span class="p">;</span>
    <span class="kt">int</span>        <span class="o">*</span><span class="n">flag</span><span class="p">;</span>
    <span class="kt">int</span> 	<span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这四个参数中最后两个参数比较灵活一些，前面两个从字面意义上也能看：第一个是长标签的名字，第二个为是否有参数。</p>

<p><code class="highlighter-rouge">flag</code> 如果设置为 NULL， 那么 getopt_long 就将返回 val， 如果 flag 不为空，而是指向一个变量，那么 getopt_long 返回 0， 并将 val 赋值给 flag 指向的变量。<code class="highlighter-rouge">val</code> 的作用就是作为 getopt_long 的返回值，或者是给 flag 指向的变量赋值。</p>

<p>而如果我们想将长短参数进行绑定的话，只需要将 flag 设置为 NULL， 并将 val 设置成短参数的值，这样 getopt_long 返回的值和是短参数时一致。至于实现原理，基本上和 getopt 类似，只是需要多加一个对长参数的解析以及寻找到与之绑定的短参数(或者直接返回指定的val)。</p>

<p>具体的使用例子就不在此描述了，可以看下 getopt_long 的 man 手册，里面提供了相关的示例。</p>

<hr />

<p>回过头来想一想， getopt 的操作并没有特别的繁琐，只是在 flag 很多的情况下， switch 的判断分支会很多。从上面我们会看到使用 getopt 我们要事无巨细的写所有的处理。实际上我们可以做的更加的集中一些， 比如 TJ 的 <a href="https://github.com/clibs/commander">commander</a> 以及 GNU 的 <a href="https://www.gnu.org/software/libc/manual/html_node/Argp.html#Argp">Argp</a> 。 后者的使用还是稍重一些。前者就显的比较 modern ， 提供的接口也比较简单，使用起来并不复杂。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>  <span class="n">command_t</span> <span class="n">cmd</span><span class="p">;</span>
  <span class="n">command_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"0.0.1"</span><span class="p">);</span>
  <span class="n">command_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">"-v"</span><span class="p">,</span> <span class="s">"--verbose"</span><span class="p">,</span> <span class="s">"enable verbose stuff"</span><span class="p">,</span> <span class="n">verbose</span><span class="p">);</span>
  <span class="n">command_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">"-r"</span><span class="p">,</span> <span class="s">"--required &lt;arg&gt;"</span><span class="p">,</span> <span class="s">"required arg"</span><span class="p">,</span> <span class="n">required</span><span class="p">);</span>
  <span class="n">command_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">"-o"</span><span class="p">,</span> <span class="s">"--optional [arg]"</span><span class="p">,</span> <span class="s">"optional arg"</span><span class="p">,</span> <span class="n">optional</span><span class="p">);</span>
  <span class="n">command_parse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>不过 commander 写的比较多的是最后的回调，如果参数很多，而参数处理很简单的话，整个处理的篇幅也比较大，不过这一套实现命令行的处理机制是值得我们去学习的，结构化处理易于维护。</p>

<p>现在我们来看一看 commander 的实现原理：</p>

<p>command_option 函数将所定义的长短参数放入对应的 struct 域中， 着重说一下在长参数处理上。需要将这个字符串拆分成长参数和 arguments。比如：<code class="highlighter-rouge">--required &lt;arg&gt;</code>  要解析成 <code class="highlighter-rouge">require</code>  和 <code class="highlighter-rouge">&lt;arg&gt;</code>  并将这两个分别存储在 <code class="highlighter-rouge">option-&gt;large</code>  和  <code class="highlighter-rouge">option-&gt;argname</code>  中。 并根据  <code class="highlighter-rouge">&lt;</code>  和 <code class="highlighter-rouge">[</code>  判定是否是可选还是必须参数。</p>

<p>在 command_parse 中，首先将 argv 的参数标准化， 即将短参数组合的情况拆分开，比如 <code class="highlighter-rouge">-abc</code> 需要转成 <code class="highlighter-rouge">-a -b -c</code>  的形式。接着就是遍历 argv 和 我们之前解析保存的 option 结构，一个一个的比对，如果匹配成功，调用 cb 函数处理结果。</p>

<p>基本的解析过程就是这样，思路很简洁，没有特别绕的地方，如果有兴趣，建议走读一遍代码。</p>

<p>在实际使用中， commander 仍然有一些不能处理情况，比如：当使负数时，负数会被误认为是 flag， 同时不支持 <code class="highlighter-rouge">--</code> 终止操作, getopt 和 getopt_long 是支持 <code class="highlighter-rouge">--</code>  的， 所以这里需要 hack 一下 commander 的代码，由于代码的结构清晰，所以自己扩展一下使用很方便。这是我之前提交的一个 <a href="https://github.com/clibs/commander/pull/23">PR</a> 用来支持 <code class="highlighter-rouge">--</code> 的， 但是未被合并 :(  。</p>

<p>还有一种情况——子命令， 最典型的例子就是 <code class="highlighter-rouge">Git</code>。Git 提供了很多的子命令，每个子命令又有自己的 flag，所以此时一种更加通用的解析方式很必要。接下来我们理解一下 Git 是如何处理命令行参数的。</p>

<p>首先 Git 是从 <code class="highlighter-rouge">common_cmd.c</code>  中的 main 启动，之后执行 <code class="highlighter-rouge">git.c</code>  中的 <code class="highlighter-rouge">cmd_main()</code> 函数。在 cmd_main 函数中包含对命令行的处理。首先将 Git 的子命令或者说是内置命令定义在一个结构中： ` struct cmd_struct commands[] ` 。这个表中定义的是子命令的名称以及该命令对应的处理函数，这些处理函数的实现是在单个的文件中。 Git 会优先处理内置命令，由于子命令是紧接着 <code class="highlighter-rouge">git</code>  出现的，所以先从 commands 表中找到对应命令，如果有则通过  <code class="highlighter-rouge">handle_builtin()</code> 函数进行，如果不是内置命令，则再去处理其他参数，Git 的处理 flag 的过程是直接解析，并没有采用 getopt 的形式，所谓的直接解析指的是在一个循环中通过 <code class="highlighter-rouge">strcmp</code> 对参数进行匹配。</p>

<p>在处理子命令时， git 采用类似的思路，即子命令本身的 flag 解析则是将该命令的 flag 定义到 <code class="highlighter-rouge">struct option </code>   中，将这个 options 传入 <code class="highlighter-rouge">parse_options()</code> 函数中进行解析， 接着再回到子命令的处理函数中继续处理。 这种处理方式的关键部分是这个 option 结构体，我们可以看一下 struct option 的结构定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">option</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">parse_opt_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">short_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">long_name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argh</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">help</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">parse_opt_cb</span> <span class="o">*</span><span class="n">callback</span><span class="p">;</span>
	<span class="kt">intptr_t</span> <span class="n">defval</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>结构的中的前面几个域是比较一目了然的，需要说一下的是 flags， 这个 flags 里面定义该参数的一些行为， 比如： <code class="highlighter-rouge">PARSE_OPT_OPTARG </code>, <code class="highlighter-rouge">PARSE_OPT_NOARG </code>  等， 这里面严格区分了是参数可选，有参数， bool型 flag 等。此外，对于某些参数的处理也可以直接调用 callback 进行更复杂的处理。</p>

<p>在 parse_options() 中，根据预定义的 options 表，进行更加细致的处理， 在这里是 parse_options 是一个通用的处理函数。可以类比成 getopt 函数的作用。所有的动作都通过结构体中定义的项进行，相当高效。Git 的这一套机制在后续添加新的命令时，更加的灵活，通过提供一套解析的模板，只需要实现相应的命令各自的处理函数即可，耦合度低。</p>

<p>再回到 C 本身，对子命令的处理也提供一个方案。 在 <code class="highlighter-rouge">stdlib.h</code>  中提供了一个 <code class="highlighter-rouge">getsubopt</code>  函数用来处理 子option 的参数，需要搭配 <code class="highlighter-rouge">getopt</code> 使用。具体的例子可以参考 man 手册中的 EXAMPLE 小节。</p>

<p>从 C 的角度而言，解析的活儿都是自己来干的，这也让我们更加清晰的认识到解析命令行参数的一个基本思路，剩下的就是按需设计想要的方式。如果不想这么麻烦，我们可以参考借鉴一下 Go 以及其他语言的用法，然后自己实现一套。</p>

<hr />

<h3 id="go-语言篇">Go 语言篇</h3>

<p>来到高级语言这部分之后，对于命令行的处理似乎能够更加的方便快捷了。 Go 语言中提供的 flag 包，支持一般参数的形式解析以及子命令的解析，在解析的扩展方面 Go 也是很灵活的。</p>

<p>Go 的 flag 标准库基本能满足基本的日常使用，但是仍有一些不太畅快的地方。 毕竟命令行的使用没有一个通用的方式，不同的系统或者说不同的软件所使用的命令行的风格也有所不同。Go 所支持的命令行语法比较简单：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="o">-</span><span class="n">flag</span>
<span class="o">-</span><span class="n">flag</span><span class="o">=</span><span class="n">x</span>
<span class="o">-</span><span class="n">flag</span> <span class="n">x</span>  <span class="c">// non-boolean flags only</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>同时默认为所有的 flag 添加了长 flag 语法。由于这样的语法定义很简单，因此就不支持短 flag 的组合，以及多参数的情况。我们阅读 flag 包的源码就能发现，在解析参数时采用的是一个 for 循环，从头到尾的解析所有的参数，所以 flag 都是定义死的，所以短参数的组合是不能识别的，flag 包会直接给出 help 的信息。硬解析就是这样，只要 flags 不在预定义的 flags 中，则认为错误。</p>

<p>我所说的多参数指的是下面的这样的情况：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="err">$</span> <span class="o">./</span><span class="n">hello</span> <span class="o">-</span><span class="n">s</span> <span class="n">str1</span> <span class="o">-</span><span class="n">s</span> <span class="n">str2</span>
<span class="p">[</span><span class="n">str2</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>我们期望 <code class="highlighter-rouge">-s</code> 能返回 <code class="highlighter-rouge">[str1, str2]</code> , Go 标准包提供的参数类型中没有复合类型，所以会导致后面解析的参数会覆盖掉前面已经解析保存的参数。好在官方文档中有提供一个自定义类型的解析的示例，这个扩展得益于 Go 的 interface 机制。 所以我们只需要将自定义的类型实现 <code class="highlighter-rouge">Value</code>  接口即可，这个 interface 的定义为：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">type</span> <span class="n">Value</span> <span class="k">interface</span> <span class="p">{</span>
  	<span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
  	<span class="n">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>也就是说我们需要对自定义的类型实现下 <code class="highlighter-rouge">String 和 Set</code> 方法。那上面所说的多参数问题，就可以使用定义成 slice 或者其他可以保存多个数据的类型，如何保存就需要在 Set 方法中实现，这一点是很方便的。</p>

<p>此外，flag 包还支持子命令的定义，需要先创建一个 flagset 类型， 然后将子命令的定义添加到刚定义的 flagset 类型中，所使用的方法定义和我们直接使用 flag 包级别的方法是一致的，这个大大降低了开发的心智。</p>

<p>还有一点就是，Go 的 flag 包没有命令行的可选参数和必选参数的概念。有的只是如果没有设置这个 flag 那么就是用默认值，设置了就将该 flag 紧接着的 paramater 解析为需要的参数。这种做法有利有弊，好处在于规范命令行的使用，flag 要么设置（除了布尔型的 flag）， 设置了就必须有值。 但是也带来了一个错误, 比如对后面需要带有参数的 flag 未设置参数，那会导致后面的 flag 被误认为是参数。</p>

<p>总之 Go 这么定义 flag 包，在没有特殊需求的时候可以很快速的完成简单命令行的设计。 对比 <code class="highlighter-rouge">getopt</code> 就能发现，一旦我们定义好了 flag 的规则，那么解析后返回的结果就可以使用了，而不再需要一个循环去处理每次的返回值。这一点是极大的提高了开发时的效率，但这个效率也是建立在你的命令行处理不复杂的情况下。</p>

<p>Go 标准包功能只是一个基础，功能上并不丰富，所以第三方的包也就有较大的选择空间，一个没有太多学习成本且是 for hunman 的包就很受欢迎，目前比较流行的是 <a href="https://github.com/ogier/pflag">pflag</a> 、<a href="https://github.com/alecthomas/kingpin">kingpin</a> 这两种。 两者各有各的特色，需要自己根据实际需求去取舍一下， 在这里就不详细的去叙述两者的实现原理，只补充一点流式函数的使用能够让写代码的人很爽，这一点在 C 中就很难体验到。 同时省去了一大部分的内存管理的烦恼，使用高级语言来编程确实舒服。</p>

<p>最后还有一个比较不错的框架推荐下，<a href="https://github.com/spf13/cobra">cobra</a>  。 这是一个用来开发命令行工具的框架，一些大的项目也用它来开发，比如 Kubernetes。通过命令直接初始化好一个项目，增加子命令以及在子命令中添加 flag 都非常的方便。 有兴趣的话，可以研究研究。</p>

<hr />

<h3 id="python-篇">Python 篇</h3>

<p>到了 Python 这边，上面的这些解析的方式 Python 都能驾驭，然而当 <a href="http://docopt.org/">dotopt</a> 出现的后，基本上算是秒杀其他。用法就是你只要按照规范写好 Usage 信息即可，剩下的你就不用管了。解析之后你将得到一个 dictionary， key 是你 Usage 里面出现的所有和 flag 相关的内容。</p>

<p>基本思路是先将 Usage 部分先解析出 option，之后再根据 argv 来解析实际的参数，这一块实际和前面的解析方法是一致的。所以基本上你能看到使用 dotopt 后，代码就非常的简洁：(代码来自官方 repo 示例)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="s">"""Naval Fate.

Usage:
  naval_fate.py ship new &lt;name&gt;...
  naval_fate.py ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;]
  naval_fate.py ship shoot &lt;x&gt; &lt;y&gt;
  naval_fate.py mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored | --drifting]
  naval_fate.py (-h | --help)
  naval_fate.py --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --speed=&lt;kn&gt;  Speed in knots [default: 10].
  --moored      Moored (anchored) mine.
  --drifting    Drifting mine.

"""</span>
<span class="kn">from</span> <span class="nn">docopt</span> <span class="kn">import</span> <span class="n">docopt</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="n">docopt</span><span class="p">(</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">'Naval Fate 2.0'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>所有的一些就都在 arguments 这个 dictionary 中了，我们只需要按照需求来获取对应 flag 的参数。 使用 dotopt 的前提是你需要熟悉并且按照 POSIX 的方式来定义你的 usage 。 这算是一个学习的成本，一旦掌握了这个定义的方式，那剩下的就是一行代码的事儿。 这基本上可以说是秒杀了一众其他的解析。 作者的一个视频里面也调侃了目前 Python 中使用的比较多的几个解析命令行工具。确实，在 docopt 的实例里面，对 git 的命令解析做了一个示范，确实简洁了很多，我们无需关系解析的细节，只需要关系最终的结果。</p>

<p>此外这一套解析方式已经被移植到其他的语言上了，可以参考这个<a href="https://github.com/docopt">链接</a>。 出此之外，我个人觉得在 Python 更加容易上手的一个工具是 argparse。 形式类似于上面的 Commander， 简单示例如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-s'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">'store'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">'src'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"seach a pattern"</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'-p'</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">'store'</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">'print_lately'</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span><span class="n">nargs</span><span class="o">=</span><span class="s">'?'</span><span class="p">,</span>
			<span class="n">help</span><span class="o">=</span><span class="s">'print n lately words'</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这其中 action 表示的是 flag 的属性，是带参数的还是一个布尔型的。 dest 是对每一个 flag 所做的操作的保存，比如 <code class="highlighter-rouge">result.src</code> ， 此外还有其他的属性可以设置。具体的可以参考 argparse 的手册。 同时我们也能发现这样的做法实际上和我们在 C 中定义结构体的方式是类似的，只是不同的语言所实现的方式不一样罢了。</p>

<hr />

<h3 id="总结">总结</h3>

<p>经过上面这一通整理，对命令行的解析以及相关工具的使用应该是比较清晰了。使用现成的库或者包进行命令行解析，可以提高效率，减轻一些心智负担，但是通过手动去写解析方式能够带来更高的灵活性。工具只是一种解决问题的方式，明白其中的实现原理，造轮子也只是时间的事儿。</p>

<p>(全文完)</p>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/10/15/bash-shell/" data-toggle="tooltip" data-placement="top" title="Bash Shell Script 杂记">
                        Previous<br>
                        <span>Bash Shell Script 杂记</span>
                        </a>
                    </li>
                    
                    
                </ul>
                <hr style="visibility: hidden;">

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
    </div>
</section>


                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "jesseeisen";
    var disqus_identifier = "/2018/06/27/command-line";
    var disqus_url = "http://localhost:4000/2018/06/27/command-line/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  <li>
    <a target="_blank" href="https://www.zhihu.com/people/jessechen-52">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa  fa-stack-1x fa-inverse">知</i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="http://weibo.com/linkangchen">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/JesseEisen">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; L.K. Blog 2019
                    <br>
                    Powered by <a href="https://jesseeisen.github.io">L.K. Blog</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=jesseeisen&repo=jesseeisen.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>

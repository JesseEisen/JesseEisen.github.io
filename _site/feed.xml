<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L.K. Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 30 Jun 2019 18:56:06 +0800</pubDate>
    <lastBuildDate>Sun, 30 Jun 2019 18:56:06 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>SystemTap Syntax 初探</title>
        <description>&lt;p&gt;SystemTap 是一个调试追踪工具，提供了一系列可以用来监测 Linux 性能和细节分析的基本部件。本文作为一个 SystemTap 的基本入门梳理。从安装到正式上手自定义一些脚本从而使用到日常编程调试中。&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;SystemTap 是由 RedHat 开发的，因此在 RedHat 系列的 Linux 发行版上一般会或多或少的直接支持。首先需要明确一点的是：SystemTap 是一款调试追踪工具，支撑其正常工作的条件是需要一定的 debuginfo 存在，一般内核是不会自带这些信息的，因此需要手动安装对应版本的 debuginfo 以更好的使用 SystemTap。&lt;/p&gt;

&lt;p&gt;由于不同的操作系统所安装的方式不一样，因此在此就不详细描述安装过程,如果你使用的是 RedHat 系的系统，可以参考: &lt;a href=&quot;https://sourceware.org/systemtap/SystemTap_Beginners_Guide/using-systemtap.html#installproper&quot;&gt;安装 SystemTap&lt;/a&gt; 和 &lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html-single/systemtap_beginners_guide/index#using-setup&quot;&gt;Install and Setup&lt;/a&gt; 这两个链接。&lt;/p&gt;

&lt;p&gt;如果你的系统对应的版本没有对应的 debuginfo，那需要升级一下 kernel。 具体的升级方式参考对应系统的官网升级方式。&lt;/p&gt;

&lt;h3 id=&quot;systemtap-工作方式&quot;&gt;SystemTap 工作方式&lt;/h3&gt;

&lt;p&gt;在真正深入到 SystemTap 的具体内容前，我们可以了解一下 SystemTap 的基本工作方式，这样更有利于我们使用。&lt;/p&gt;

&lt;p&gt;首先，SystemTap 会检查脚本是否合法，同时替换匹配到 tapset 定义。这一步和 C 语言中的预编译过程一样。 接着 SystemTap 将脚本翻译成 C 代码，同时编译成一个 kernel module。完成之后，SystemTap 加载这些模块，并激活脚本中涉及到的探针。这些探针是原先就存在 Kernel 中，使能之后，当有事件发生，对应的探针就会执行我们脚本定义的这些 handler。当 SystemTap 结束后，这些探针会立即被关闭，同时这些 kernel module 也会被销毁。&lt;/p&gt;

&lt;p&gt;从上述的工作原理也能看出， SystemTap 是需要 kernel 支持的。 同时，需要做一步代码翻译和编译，所以在运行速度上，最开始时比较耗时的。&lt;/p&gt;

&lt;h3 id=&quot;运行-systemtap-脚本&quot;&gt;运行 SystemTap 脚本&lt;/h3&gt;

&lt;p&gt;脚本的运行一般是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;stap&lt;/code&gt; 命令进行，不过并不是所有的用户都能执行该命令， 如果你有超级用户权限，那自然是可以跑的，如果没有我们可以通过将对应的用户添加到组 &lt;code class=&quot;highlighter-rouge&quot;&gt;stapdev&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;stapusr&lt;/code&gt;。 前者的权限比较大一点，后者的权限只能运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;staprun&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;staprun 是运行通过 stap 编译生成的 &lt;code class=&quot;highlighter-rouge&quot;&gt;instrumentation module&lt;/code&gt;。 其不能直接运行 stap 脚本。&lt;/p&gt;

&lt;p&gt;此外 stap 还有几个通用的选项需要了解一下，这样会让你更好的使用 SystemTap。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;提供更加详细的输出，这个在出错的情况下打开比较有用，可以提供更多的信息。比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;stap -vvv xxx.stp&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-o filename&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将输出到标准输出的内容写到文件中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-S size,count&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;限制文件大小为 size MB，同时限制文件数为 count 个。 这个选项一般用在管理日志文件上。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-x process id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;target()&lt;/code&gt; 为指定的 process ID。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c command&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;target()&lt;/code&gt; 为指定的命令。 注意需要指定完整的命令路径。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e script&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意 script 指的是字符串型的 systemtap 语句， 而不是脚本文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-F&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后台运行脚本并记录结果，一般有两种模式: in-memory flight recorder、 File Fligh Recorder。 从名称上可以直接看出，前者是内容保存在 memory 中， 另一个是保存在文件中。针对后者我们可以这么用 &lt;code class=&quot;highlighter-rouge&quot;&gt;stap -F -o /tmp/temp.log -S 1,2 temp.stp&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用于列出对应模块或者 kernel 中支持的 probe。比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;stap -l 'kernel.function(&quot;*&quot;)'&lt;/code&gt; 会列出当前所有 kernel 的 function probe：&lt;/p&gt;

&lt;h3 id=&quot;systemtap-脚本&quot;&gt;SystemTap 脚本&lt;/h3&gt;

&lt;p&gt;systemTap 脚本是由两个最基本的内容组成：&lt;em&gt;event&lt;/em&gt; 和 &lt;em&gt;handler&lt;/em&gt; 。这两者我们通常组合在一快称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;probe&lt;/code&gt;，即探针。&lt;/p&gt;

&lt;p&gt;我们书写脚本的目的是更好的处理我们的需求，最基本的就是我们根据需要写出我们想要捕获的事件，并给出对应的 handler。&lt;/p&gt;

&lt;p&gt;SystemTap 脚本一般以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.stp&lt;/code&gt; 结尾，脚本内容一般是由 probe 组成。详细的语法如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;probe &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;kernel|module&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;module-pattern&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt;.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;function-pattern&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;.&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;call|return[.maxactive&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;VALUE&lt;span class=&quot;o&quot;&gt;)]&lt;/span&gt;|inline&lt;span class=&quot;o&quot;&gt;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通常一个脚本中的 probe 可以有多个，而同一个 probe 可以有多个事件，事件以逗号隔开。如果同一个 probe 指定了多个事件，那么只要有一个 event 发生，SystemTap 就会执行 handler。statement 的语法和 C 语言的语法比较接近。&lt;/p&gt;

&lt;p&gt;针对 &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;maxactive&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;inline&lt;/code&gt; 的解释如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;call is used to attach entry point non-inlined function, while .inline is used to attach first instruction of inlined function;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;maxactive specifies how many instances of the specified function can be probed simultaneously. You can leave off .maxactive in most cases, as the default (KRETACTIVE) should be sufficient. However, if you notice an excessive number of skipped probes, try setting .maxactive to incrementally higher values to see if the number of skipped probes decreases.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;.return is used for return points of non-inlined functions;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;empty suffix is treated as combination of .call and .inline suffixes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上述的 &lt;code class=&quot;highlighter-rouge&quot;&gt;function-pattern&lt;/code&gt; 的具体定义如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;@source-path[&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;:line-number|:first-line-last-line|+relative-line-number&lt;span class=&quot;o&quot;&gt;}]]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# 函数名@文件名：指定行&lt;/span&gt;
kernel.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;AUDIT_MODE@../security/apparmor/include/policy.h:401&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外，我们也可以自定义函数，这个好处就是可以避免重复代码。格式如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;function_name&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;arguments&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;statements&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
probe event &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;function_name&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;arguments&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;target-variable&quot;&gt;target variable&lt;/h3&gt;

&lt;p&gt;首先 probe event 是映射到代码中的实际位置的。 而target variable 的作用是去获取代码中该位置的可见变量的值。 一般我们可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-L&lt;/code&gt; 列出当前可以查看的 target variable 值。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;stap &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'kernel.function(&quot;vfs_read&quot;)'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#输出&lt;/span&gt;
kernel.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;vfs_read@../fs/read_write.c:381&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$file&lt;/span&gt;:struct file&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$buf&lt;/span&gt;:char&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$count&lt;/span&gt;:size_t &lt;span class=&quot;nv&quot;&gt;$pos&lt;/span&gt;:loff_t&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意，这个功能需要安装对应的 kernel debuginfo 才能支持。 上面的输出是什么意思呢？每个 target variable 都是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 开头， &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; 后面跟着变量的类型。&lt;/p&gt;

&lt;p&gt;对于 target variable 不属于当前 probe 的本地变量，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;@var(&quot;varname@src/file.c&quot;)&lt;/code&gt; 来访问。&lt;/p&gt;

&lt;p&gt;正常情况下如果我们要访问某个 target variable， 可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; ，同时 target variable 是可以链式使用的。 下面有一例子可以用来展示一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;stap -e 'probe kernel.function(&quot;vfs_read&quot;) {
           printf (&quot;current files_stat max_files: %d\n&quot;,
                   @var(&quot;files_stat@fs/file_table.c&quot;)-&amp;gt;max_files);
           exit(); }'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除此之外，如果知道了当前数据的地址，可以通过下面的几个函数，更快的获取到内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;kernel_char(address)     &lt;br /&gt;
Obtain the character at address from kernel memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kernel_short(address) &lt;br /&gt;
Obtain the short at address from kernel memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kernel_int(address) &lt;br /&gt;
Obtain the int at address from kernel memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kernel_long(address)  &lt;br /&gt;
Obtain the long at address from kernel memory&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kernel_string(address)  &lt;br /&gt;
Obtain the string at address from kernel memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kernel_string_n(address, n)  &lt;br /&gt;
Obtain the string at address from the kernel memory and limits the string to n bytes.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时如果我们不清楚有哪些变量可以输出，或者变量较多时，可以使用一些快捷的预定义变量进行输出：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$$vars  当前定义域内存在的所有变量&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;locals&lt;/script&gt;vars 的子集，只包含本地变量&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;parms&lt;/script&gt;vars 的子集，只包含函数变量&lt;/li&gt;
  &lt;li&gt;$$return  只可以在 .return 的 probe 中使用，如果被探测的函数是有返回值的话，则打印出该返回值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在上述的变量后面还可以添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;$$&lt;/code&gt; 这两个后缀。以此来输出更加详细的内容，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;$$var$&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;$$var$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@defined&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;@choose_defined&lt;/code&gt; 是用检查 target variable 是否存在。后者是前者的一个语法糖。什么意思呢？ 一般代码是会改变的，有些变量可能在某些版本上是不存在的，因此我们可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;@defined&lt;/code&gt; 进行判断。惯用法是：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;write_access &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;@defined&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$flags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ? &lt;span class=&quot;nv&quot;&gt;$flags&lt;/span&gt; : &lt;span class=&quot;nv&quot;&gt;$write_access&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这和 C 语言中的三元符是一个道理。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;@choose_define&lt;/code&gt; 则是对三元符的一个语法糖。即：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;@defined&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;?&lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;  等价于 @choose_defined（&lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt;, &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;）
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;event&quot;&gt;event&lt;/h3&gt;

&lt;p&gt;SystemTap 将事件大致分为：同步事件和异步事件。所谓的同步事件指的是，在内核代码中某一处的指令被执行后，则会触发的事件。异步事件指的是不和内核代码相互绑定的事件，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; 事件。&lt;/p&gt;

&lt;p&gt;我们大多数情况下需要使用的是同步事件，大致有如下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;syscall.system_call&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的事件是捕捉的系统调用，监测的是指定系统调用的动作。当调用了该系统调用，SystemTap就会执行我们指定的 statement。此外，也可以监控系统调用退出的动作，只需要在后面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;.return&lt;/code&gt; 即可。比如： &lt;code class=&quot;highlighter-rouge&quot;&gt;syscall.close&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;syscall.close.return&lt;/code&gt;。如果有返回值，一般会存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$return&lt;/code&gt; 中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;vfs.file_operation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;监测的是虚拟文件系统的相关动作。和 syscall 类似，也有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.return&lt;/code&gt; 的动作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;kernel.function(“function”)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;监测内核函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt;。当内核中任意的线程调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt;，都会触发对应的 event。同样可以指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;.return&lt;/code&gt; 来捕获退出时的事件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt; 中可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;,同样如果想追踪指定文件中的函数，可以使用如下的方式：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;probe kernel.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*@net/socket.c&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
probe kernel.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*@net/socket.c&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.return &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单说明一下，第一条语句的意思是： 监控内核源文件 net/socket.c 中所有的函数。 第二条语句的意思是当这些函数退出时捕获对应 event。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;kernel.trace(“tracepoint”)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在的 kernel 中会有一些特定的指令事件。这些事件被静态地标记为 tracepoint。比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel.trace(&quot;kfree_skb&quot;)&lt;/code&gt;。 这个追踪点就是表明 network 缓存被释放，此时就会触发对应的事件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;module(“module”).function(“function”)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统的内核模块在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/kernel_version&lt;/code&gt; 并以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.ko&lt;/code&gt; 结尾。 这些模块也是可以被 SystemTap 追踪的。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;probe module(&quot;ext3&quot;).function(&quot;*&quot;) {}
probe module(&quot;ext3&quot;).function(&quot;*&quot;).return {}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面说一说异步事件, 异步事件大致有如下几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;begin&lt;/li&gt;
  &lt;li&gt;end&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个可以类比 awk 中的 BEGIN 和 END 。 在 SystemTap 开始之前，会执行 begin 中的内容，在结束之前会执行 end 中内容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;timer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用来周期性的处理内容，这个一般用在定期的输出收集到的内容。一般有如下的衍生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;+ timer.s(xxx)
+ timer.ms(xxx)
+ timer.us(xxx)
+ timer.ns(xxx)
+ timer.hz(hertz)
+ timer.jiffies(jiffies)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个基本的例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
probe begin
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Enter&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

probe timer.s&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2s later&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

probe end
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Exit&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;man stapprobes&lt;/code&gt; 查看 stap 所支持的 event。 同时在 SEE ALSO 中可以看到其他相关的 man page。&lt;/p&gt;

&lt;h3 id=&quot;内置-function&quot;&gt;内置 function&lt;/h3&gt;

&lt;p&gt;SystemTap 内置了一些可以直接使用的函数，比如 printf() 使用方式和 C 语言中的 printf 一样。除此之外还有如下几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tid()&lt;/li&gt;
  &lt;li&gt;uid()&lt;/li&gt;
  &lt;li&gt;cpu()  当前 cpu 个数&lt;/li&gt;
  &lt;li&gt;gettimeofday_s()  从 1970/1/1 起的秒&lt;/li&gt;
  &lt;li&gt;ctime() 转换上述时间&lt;/li&gt;
  &lt;li&gt;pp()  用来描述当前被处理的 probe point 的字符串&lt;/li&gt;
  &lt;li&gt;thread_indent() 更好的输出结果，可以接受一个参数，参数表示的是 indent 变化，可正可负。&lt;/li&gt;
  &lt;li&gt;name  标记当前系统调用的名字。&lt;/li&gt;
  &lt;li&gt;target()  在一开始我们提到这个，主要使用与绑定 pid 或者 command 名称&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基本语法&quot;&gt;基本语法&lt;/h3&gt;

&lt;p&gt;SystemTap 和 awk 类似，可以自动识别变量的类型，不过需要区分局部变量和全局变量，全局变量需要在 probe 外通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt; 关键字定义。局部变量是被初始化过的。 支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;++&lt;/code&gt; 操作符。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件语句&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;条件语句和 C 类似，如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;condition&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    statement1
&lt;span class=&quot;k&quot;&gt;else
    &lt;/span&gt;statement2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果有多条语句，需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt; 包裹。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;循环语句&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;condition&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    statement

&lt;span class=&quot;c&quot;&gt;# for &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;initial&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; condition&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; increment&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    statement
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般我们写脚本需要传入一下命令行的参数， SystemTap 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;@1， @2&lt;/code&gt; 等表示命令行参数。 使用时直接传入指定的函数中。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;probe kernel.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;@1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
probe kernel.function&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;@1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.return &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;关联数组&quot;&gt;关联数组&lt;/h4&gt;

&lt;p&gt;关联数组和 awk 中的关联数组很像，使用上也没多少区别。 需要注意的一点是，我们需要在使用前通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt; 定义下数组。&lt;/p&gt;

&lt;p&gt;需要着重说明的是， SystemTap 中支持多个 index。一般情况下，我们的索引是单个的字符串。比如:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;arr[&lt;span class=&quot;s2&quot;&gt;&quot;stephen&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 30
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是在 SystemTap 中我们最多可以对同一个 value 设置 9 个 index， 比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;device[pid&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;,execname&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;,uid&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;,ppid&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;W&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; devname
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这么做的好处是什么呢？ 显而易见的是提供了更多的信息，当我们在遍历关联数组时，这些 index 都可以作为我们的信息输出。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;foreach&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;pid, execname, uid, ppid, status] &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;device&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%4s %5s %d %d %s %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, pid, execname, uid, ppid, status, device[pid,execname,uid,ppid,status]&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;数组的读写和我们平常的使用一致，没有太多的区别，同样是通过取下标进行的。如果想要遍历关联数组，可以通过上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt; 进行。 使用也比较简单。单个 index 的情况如下使用：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;foreach&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;index &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;arrays&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    statements
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里面还需要着重说的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt; 有一个特别的语法，支持排序和个数限制。这样可以让代码更加的简洁。具体的语法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;foreach(index in array+ limit 10)
#or
foreach(index in array- limit 10)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在数组名后面添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 表示增序或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 表示逆序。 后面的 limit 表示限制 10 个元素输出。此外如果想要删除数组的元素或者清空整个组可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt; 关键字。&lt;/p&gt;

&lt;p&gt;我们还可以判断一个元素是否存在于关联数组中，语法如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;array&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    statement
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;总量统计&quot;&gt;总量统计&lt;/h4&gt;

&lt;p&gt;statistical aggregate 是用来统计一组数据，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt; value&lt;/code&gt; 将 value 加到集合中。操作的对象可以是一个全局变量也可以是数组的一个元素。 这个统计是独立于操作对象本身的，怎么理解呢？举个例子。&lt;/p&gt;

&lt;p&gt;比如我们有一个数组 &lt;code class=&quot;highlighter-rouge&quot;&gt;readbytes[execname()] &amp;lt;&amp;lt;&amp;lt; 2&lt;/code&gt;。如果我们一直操作这样的语句，最后 &lt;code class=&quot;highlighter-rouge&quot;&gt;readbytes[execname]&lt;/code&gt; 的值都是初始值，而不是我们想象中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 不是赋值的意思，他是存在另一个结构中，不会修改操作对象本生。&lt;/p&gt;

&lt;p&gt;那如何获取到这个统计的具体内容呢？ SystemTap 提供了几个运算符，可以方便的来获取统计内容，在说到运算符之前，我们简单的看个例子： 假定有一个空集合，我们往里面添加一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt; 1&lt;/code&gt;, 此时集合中就有一个元素了， 我们继续添加一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt; 2&lt;/code&gt;。那此时集合中就有了 1 和 2 两个元素。 有了这样的印象后，下面看看几个获取统计的函数, 语法是：&lt;code class=&quot;highlighter-rouge&quot;&gt;@extractor(variable/array_index expression)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;extractor 可以是如下几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;count  返回统计集合中元素的个数&lt;/li&gt;
  &lt;li&gt;sum    返回统计集合中元素值的总和&lt;/li&gt;
  &lt;li&gt;min    返回统计集合中元素的最小值&lt;/li&gt;
  &lt;li&gt;max    返回统计集合中元素的最大值&lt;/li&gt;
  &lt;li&gt;avg    返回统计集合中元素的平均值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; 而言，按照上面的例子而言，执行 count 后， 返回的是 2， 而执行 sum 之后，返回的是 3。&lt;/p&gt;

&lt;h3 id=&quot;tapset&quot;&gt;tapset&lt;/h3&gt;

&lt;p&gt;SystemTap 提供了 tapset 库，可以类比下 C 的 libc。 tapset 中提供了相应的全局变量和函数可以直接在 SystemTap 脚本中使用。 具体的手册可以参考 &lt;a href=&quot;https://sourceware.org/systemtap/tapsets/index.html&quot;&gt;tapset&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;其他内容&quot;&gt;其他内容&lt;/h3&gt;

&lt;p&gt;probe 后一般可以跟上 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;。 这两个符号的意思是： &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt; 表示 probe 是可选的，如果不存在对应的 probe ，程序也不会出错。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; 表明 probe 一旦解析成功，则不会继续解析后面的 probe。&lt;/p&gt;

&lt;h3 id=&quot;用户态的探针&quot;&gt;用户态的探针&lt;/h3&gt;

&lt;p&gt;说了这么多，大多都是涉及到的是内核相关的监测。这些监测会让我们更好的了解系统，但是如何将 SystemTap 应用到 user 模式中呢？ SystemTap 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;uprobes&lt;/code&gt; 模块来支持用户态的探测。&lt;/p&gt;

&lt;p&gt;一般内核版本在 3.5 以上的都默认包含了 &lt;code class=&quot;highlighter-rouge&quot;&gt;uprobes&lt;/code&gt;。 可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;grep CONFIG_UPROBES /boot/config-\&lt;/code&gt;uname -r`&lt;code class=&quot;highlighter-rouge&quot;&gt; 验证一下是否包含。输出结果为 &lt;/code&gt;CONFIG_UPROBES=y`。&lt;/p&gt;

&lt;p&gt;所有的用户态的事件监测都是用过 &lt;code class=&quot;highlighter-rouge&quot;&gt;process&lt;/code&gt; 打头的。一般有如下的几个调用方式：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;process.begin
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;PATH&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.begin
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;PID&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.begin

process.thread.begin
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;PATH&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.thread.begin
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;PID&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.thread.begin

process.end
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;PATH&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.end
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;PID&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.end

process.thread.end
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;PATH&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.thread.end
process&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;PID&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.thread.end
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相关的解释如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The .begin variant is called when a new process described by PID or PATH is created. If no PID or PATH argument is specified (for example process.begin), the probe flags any new process being spawned.
The .thread.begin variant is called when a new thread described by PID or PATH is created.
The .end variant is called when a process described by PID or PATH dies.
The .thread.end variant is called when a thread described by PID or PATH dies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除此之外还有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 是比较好用的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;process.syscall
process(&quot;PATH&quot;).syscall
process(PID).syscall

process.syscall.return
process(&quot;PATH&quot;).syscall.return
process(PID).syscall.return
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在处理 syscall 的 probe 时，我们可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;$syscall&lt;/code&gt; 获取系统调用数。 前六个该系统调用的参数可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;$arg1, $arg2... $arg6&lt;/code&gt; 等等获取到。&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/systemtap/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/systemtap/</guid>
        
        <category>Linux</category>
        
        <category>动态追踪</category>
        
        
      </item>
    
      <item>
        <title>C 语言中的 Fat Pointer</title>
        <description>&lt;p&gt;在正式讨论这篇文章的主角前，我想讨论一下在 C 编程中经常容易出现的错误，就是当数组传入函数后，实际该数组就退化成指针，而作为数组所具有的维度的属性就丢失了。&lt;/p&gt;

&lt;p&gt;通常我们会使用下面的一个宏来计算数组的长度：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#define nelem(x) (sizeof(x)/sizeof((x)[0]))
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意这个宏统计的是当前数组所有元素的个数，并不是当前数组被赋值了多少。当我们对函数参数使用该宏的时候，往往得到的结果并不是我们期望的。比如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nelem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个结果往往是当前系统上一个指针的长度。对于这种情况，很容易出现溢出或者 segmentation fault。 这也许是指针和数组最直观的不同，很多情况下我们很容易忽略这个。&lt;/p&gt;

&lt;p&gt;规避这个问题最简单的方式就是多加一个长度的参数，或者我们使用如下的方式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;定义一个带有变长数组的结构体，这个结构体所占的大小为仅为第一参数 int 所占的大小，&lt;strong&gt;第二个参数不占结构体空间但是内存紧跟在结构体之后，这就让我们在分配内存的的时候，可以只分配一次内存，即可以使用 buf&lt;/strong&gt;。 如果将 buf 定义成指针，则这个指针的地址不一定紧跟在结构体之后，所以一般情况下需要分配两次内存。&lt;/p&gt;

&lt;p&gt;当然这种方式你在任何情况下对 buf 使用 nelem 宏，结果都不是你所期望的数组的大小。 其实定义成带有变长数组的方式是一种 trick 的方式。 读过 redis 的源码的都知道，redis 里面的 sds ，这种 hack string 的方式和我们上面定义的这个结果很类似。&lt;/p&gt;

&lt;p&gt;redis 通过定义一个 sdshdr 结构，在这个结构中定义了如下内容：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sdshdr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而暴露给其他 API 使用的字符串类型却是： &lt;code class=&quot;highlighter-rouge&quot;&gt;typedef char *sds;&lt;/code&gt; 。 具体的操作可以简化成下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;sds&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newsdslen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* 定义一个 sdshdr 指针并分配相关内存 */&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* 将 init 中内容复制到 buf 中 */&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后返回了是我们常见的字符串，这样做的好处则是可以通用标准库中的 string 操作函数，又可以更好根据 len 和 free 维护当前的 string。&lt;/p&gt;

&lt;p&gt;这样的思路其实就是已经是在使用 fat pointer 了。 而使用 fat pointer 的目的是什么呢？ 目的之一就是作为一种对象信息的维护。这个对象的信息在创建一个通用模板函数的情况下比较实用，比如 &lt;a href=&quot;http://libcello.org/home&quot;&gt;Cello&lt;/a&gt; 这个项目就是大量的使用 fat pointer。将很大一部分的信息隐藏在头部，暴露出来的只是简单的结构体类型。 这个项目作者自己也调侃说：“这是一个使用错误的工具解决错误的问题”。 不过整个代码还是很有学习价值的。&lt;/p&gt;

&lt;p&gt;一个简单的 fat pointer 思路是这样的， 我们同样定义一个 header 结构体，这个结构体里面我们只存放一个简单的 type 字段。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cello 中大量使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt;， 这个主要是为了实现一个通用的形式。 比如我们要创建一个整型的变量，我们可以这么干：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;header_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define alloc_stack(T) header_init( \
  (char[sizeof(struct Header) + sizeof(struct T)]){0}, T)
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define $(T, ...) ((struct T*)memcpy( \
  alloc_stack(T), &amp;amp;((struct T){__VA_ARGS__}), sizeof(struct T)))
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的宏是从栈上分配内存，此时我们可以定义这样一个结构体：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时我们就可以这么使用了：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这么一通操作看起来很复杂，不过当我们有这样的一个函数，接收的是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt; 的参数，那这种方式的便利性就出来了。&lt;/p&gt;

&lt;p&gt;实际上这个头部可以包含更多的内容，Cello 中包含更加复杂的操作, 使用了 Type classes 的概念，这在函数式编程中比较常见。可以简单的理解为对一系列具有某种性质的 type 的抽象，如果一个type想要成为某个 type class， 就必须成为这个实例并实现 type class 定义的函数。 这么说或许确实挺抽象的，以 Cello 中的一个类型定义为例。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Help&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Help&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Doc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Help_Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;Help_Brief&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Help_Description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Help_Definition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Help_Examples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Help_Methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define Instance(I, ...) NULL, #I, &amp;amp;((struct I){__VA_ARGS__})
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边 Help 实现了 Doc 这个结构中所定义的所有函数，那么当我们在使用 help 时则可以放到 Doc 的处理函数中。&lt;/p&gt;

&lt;p&gt;这种做法，实际上不是特别适合 C，但是这其中的一些处理方式还是很值得我们去学习，这从侧面反应出 Fat pointer 的使用可以达到 Cello 这样抽象的程度，这在让我们在实现一些 API 时可以做到更加的干净。&lt;/p&gt;

&lt;p&gt;（全文完）&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/23/fat-pointer/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/23/fat-pointer/</guid>
        
        <category>C</category>
        
        <category>Programming</category>
        
        
      </item>
    
      <item>
        <title>命令行解析</title>
        <description>&lt;p&gt;我们在日常编程中，对命令行参数的解析是不可避免的。一般情况下，不同的编程语言都提供了相应的库函数来解析命令行参数。这些库函数有些是比较顺手的，有些则比较原始，通过了解一下不同的解析思路，利用不同语言自有的特性实现一些顺手的命令行解析工具。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;命令行基本概念&quot;&gt;命令行基本概念&lt;/h3&gt;

&lt;p&gt;首先我们得了解一下命令行的基本格式。比如 GNU 的命令行参数的语法惯例如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;命令行参数若是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 开头的则认为是选项（options）&lt;/li&gt;
  &lt;li&gt;多个选项可以在单个的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;  后面（注意选项应为不带参数的形式）&lt;/li&gt;
  &lt;li&gt;选项的名字是一个单个的字符数字的形式（alphanumeric）&lt;/li&gt;
  &lt;li&gt;选项后面可以带参数&lt;/li&gt;
  &lt;li&gt;选项和他的参数之间可以有或者不存在分隔符， 比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;-o foo&lt;/code&gt;  和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-ofoo&lt;/code&gt;  可以认为是相同的&lt;/li&gt;
  &lt;li&gt;选项一般在其他非选项的参数前面出现&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;  表示参数终止， 在这之后的参数都会被认为是非选项，即使是带了 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;  的&lt;/li&gt;
  &lt;li&gt;单独的一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;  一般用来表示读取或者写向标准输入输出&lt;/li&gt;
  &lt;li&gt;选项可以以任意顺序出现，同一个选项也可以出现多次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述的语法，大体上说明了一个基本的命令行该有的形式，但是还有一些细节没有涉及到。 比如一个选项是否接受一个可选参数或者必须带有一个参数。 我们在看一些命令的手册时，往往会看到这样的几个符号：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这几个符号要细究下来，组合的形式比较多，所表示的含义也不尽相同。所以想要定义一个比较标准的命令行 Usage，对于这些参数的组合使用是必须了解的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般我们使用  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;argument&amp;gt;&lt;/code&gt;  表示参数， 这个参数即为选项后面所需要带的参数，或者是正常命令行参数。 比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; program &amp;lt;arg1&amp;gt; &amp;lt;arg2&amp;gt;
 program &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &amp;lt;file&amp;gt;
 program &lt;span class=&quot;nt&quot;&gt;--input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些都是表示参数，一般参数提供出来，未加修饰符都默认是必须提供的参数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可选项&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; option] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; value]
program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;argument&amp;gt;]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt; 表明这个参数或者选项是可选的，可选的意思即为在运行命令时这些是可提供或者不提供的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;互斥&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; | &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
类似于如下写法：
program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;互斥表明这两个参数或者多个参数只能选择其中之一，如果都出现了，则会报错, 上面的实例中表示可以都不出现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;必选项&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;program: &amp;lt;argument&amp;gt;
program: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &amp;lt;good&amp;gt; | &amp;lt;bad&amp;gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; 是为了来表示必选，或者是作为一个组合的意思。 上面的例子指的是两个选项必须出现其中之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重复&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;FILE]...
program: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&amp;lt;from&amp;gt; &amp;lt;to&amp;gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重复的意思即为这个参数或者这一组参数可以出现多次。最直观的的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;  可以有参数, 可以同时有多个参数等。&lt;/p&gt;

&lt;p&gt;当我们打开 man 手册的时候，往往会发现在  &lt;code class=&quot;highlighter-rouge&quot;&gt;SYNOPSIS&lt;/code&gt;  这一小节中的内容其实很简单。比如:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;OPTION]... &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;FILE]...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;OPTION&lt;/code&gt;  做一个占位符，在后续将选项的具体形式极其使用说明进行详细描述。 这也为我们在编写 Usage 函数时提供了一个思路。&lt;/p&gt;

&lt;p&gt;一个简单的 usage 示例：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Usage: ./test &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options]
Options:
        &lt;span class=&quot;nt&quot;&gt;-V&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;                 output program version
	&lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--help&lt;/span&gt;                    output &lt;span class=&quot;nb&quot;&gt;help &lt;/span&gt;information
	&lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--verbose&lt;/span&gt;                 &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;verbose stuff
	&lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--required&lt;/span&gt; &amp;lt;arg&amp;gt;          required arg
	&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--optional&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;arg]          optional arg
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们在设计一个命令行工具的时候，一些选项的命名实际上是可以遵循一些惯例的，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;--help&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;--version&lt;/code&gt; 等输出基本程序信息。 GNU 列出了一个在 GNU 软件中所使用到的长选项的&lt;a href=&quot;https://www.gnu.org/prep/standards/html_node/Option-Table.html#Option-Table&quot;&gt;说明&lt;/a&gt;。 目的是为了后续的一个兼容，这对我们日常的编写程序也是有一定的指导意义的。&lt;/p&gt;

&lt;p&gt;上面说的这些并不能完全概括所有的情形，只能说作为在 &lt;code class=&quot;highlighter-rouge&quot;&gt;*nix&lt;/code&gt; 上工作的人所习惯的一个范式，不过有了理论基础，实际操作上，不同的语言或者不同的库所提供的解析方式有很大的不同。我们总想解析能做到简单易用，指哪打哪儿的效果，但是现实往往并不能如愿，下面就从我说熟悉几个语言上说一说几种不同的命令行解析思路。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;awk-语言篇&quot;&gt;Awk 语言篇&lt;/h3&gt;

&lt;p&gt;之所以将 awk 放在最开始说，是因为 awk 本身并没有提供命令行解析的相关函数或者库， 即使是 gawk 也没有提供相应的库，所以需要我们自己去实现。正因为如此，将其放在最开始说是很有必要的，因为我们需要去从头到尾的实现下 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 函数, 通过这个过程来了解一下 getopt 的基本原理。&lt;/p&gt;

&lt;p&gt;getopt 一般是在一个循环中使用。 基本的使用框架如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;getopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;使用方式：&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ab:cd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;options 是预先定义的，argc 和 argv 表示的是命令行参数，getopt 最简单的思路如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从命令行中取出合法的 option （短或者长的参数），解析出 flag&lt;/li&gt;
  &lt;li&gt;在 options 中找到对应的 flag， 并检查是否带有参数&lt;/li&gt;
  &lt;li&gt;若是需要带参数的，则将下一个命令行参数设置到 Optarg 中，否则该 flag 解析完成， 返回该 flag。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般 getopt 会维护两个全局变量， Optind 和 Optarg， 前者表示解析到第几个命令行参数， 后者表示该 flag 带有的参数。 getopt 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;  表示一个 flag 是带有参数的。&lt;/p&gt;

&lt;p&gt;下面是 GNU awk 对 getopt 的一个简单实现：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;getopt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argc, argv, options,   thisopt, i&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c&quot;&gt;# no support  --&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind] &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;--&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                Optind++
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind] &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;~ /^-[^: &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;/&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# flag must start by - and not contain : and space&lt;/span&gt;
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_opti &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 2
        thisopt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind], _opti, 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        Optopt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; thisopt
        i &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; index&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;options, thisopt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Opterr&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%c -- invalid option&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, thisopt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/dev/stderr&quot;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_opti &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind]&lt;span class=&quot;o&quot;&gt;)){&lt;/span&gt;
                        Optind++
                        _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else
                        &lt;/span&gt;_opti++
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;?&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;options, i+1, 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind], _opti + 1&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        Optarg &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind], _opti + 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# -abcfoo&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else
                        &lt;/span&gt;Optarg &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; argv[++Optind]
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else
                &lt;/span&gt;Optarg &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_opti &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; _opti &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind]&lt;span class=&quot;o&quot;&gt;)){&lt;/span&gt;
                Optind++
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else
                &lt;/span&gt;_opti++
        &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;thisopt
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个 getopt 的实现不支持长参数解析，同时使用上也很有局限性，但是很清楚的说明了 getopt 的基本原理。 我们可以这么使用：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;BEGIN &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	Opterr &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
    Optind &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;flag &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; getopt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ARGC, ARGV, &lt;span class=&quot;s2&quot;&gt;&quot;ab:cd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    	&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;flag=%c , optarg=%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, flag, Optarg&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; Optind &amp;lt; ARGC&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; Optind++&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    	&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Non-option argument:[%d] %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; Optind, ARGV[Optind]&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 getopt 主体在结果处理上，每次解析出来的 flag 和 optval 可以按照我们想要的方式进行处理。由于 getopt 的使用方式是通用的，如果你熟悉 getopt ，只要支持 getopt 的情况下，一般都能做到上手就用，最多也就是阅读下 man 手册上的一些细节和 feature。&lt;/p&gt;

&lt;p&gt;上面实现的 getopt 不支持长参数，若要加入对长参数的解析并不是很困难，只需要在执行解析前将长短 flag 做一个映射即可，这在 awk 中可以直接使用关系型数组即可，比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;longopts[&lt;span class=&quot;s2&quot;&gt;&quot;create&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;
longopts[&lt;span class=&quot;s2&quot;&gt;&quot;verbose&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;V&quot;&lt;/span&gt;
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设置这个 map 后，当我们解析出是长参数时，判断一下当前定义的长参数是否在 longopts 中，可以这么做：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!(&lt;/span&gt;lopt &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;longopts&lt;span class=&quot;o&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# error print&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;?&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

opt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; longopts[lopt]
&lt;span class=&quot;c&quot;&gt;# then we just return the opt&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般命令行操作都会提供长短参数配套使用机制的。但是也有需求是只提供长参数，并不与短参数绑定，所以只需要将这个 map 的值设置成我们期望返回的即可。&lt;/p&gt;

&lt;p&gt;awk 的好处就在于能够快速搭建一个原型，这对我们后续对 C 的分析有很大的帮助。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;c-语言篇&quot;&gt;C 语言篇&lt;/h3&gt;

&lt;p&gt;C 语言中我们大多使用的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt_long&lt;/code&gt;  这两个标准库中的函数，我们所以做的就是在定义好 flag 后需要自己去解析，一方面很自由，如何去处理 flag 所带的参数是由开发者自己去实现；另一方面又显得很繁琐， 因为有时候我只想解析后就能直接使用 。&lt;/p&gt;

&lt;p&gt;C 中的 getopt 和上述的 awk 方式类似，所以这边不多加叙述。 按照一种更好的做法，在 C 中最好是使用 getopt_long，因为有对长参数的支持。下面就来说一说 getopt_long 的基本使用情况。&lt;/p&gt;

&lt;p&gt;在 AWK 篇的最后我们简单的说了下实现对长参数的解析的方式，C 中没有关系型数组，但是 C 可以定义结构，因此，当我们使用 getopt_long 的时候，我们需要初始化一个结构体。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; 	&lt;span class=&quot;n&quot;&gt;has_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; 	&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这四个参数中最后两个参数比较灵活一些，前面两个从字面意义上也能看：第一个是长标签的名字，第二个为是否有参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flag&lt;/code&gt; 如果设置为 NULL， 那么 getopt_long 就将返回 val， 如果 flag 不为空，而是指向一个变量，那么 getopt_long 返回 0， 并将 val 赋值给 flag 指向的变量。&lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 的作用就是作为 getopt_long 的返回值，或者是给 flag 指向的变量赋值。&lt;/p&gt;

&lt;p&gt;而如果我们想将长短参数进行绑定的话，只需要将 flag 设置为 NULL， 并将 val 设置成短参数的值，这样 getopt_long 返回的值和是短参数时一致。至于实现原理，基本上和 getopt 类似，只是需要多加一个对长参数的解析以及寻找到与之绑定的短参数(或者直接返回指定的val)。&lt;/p&gt;

&lt;p&gt;具体的使用例子就不在此描述了，可以看下 getopt_long 的 man 手册，里面提供了相关的示例。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;回过头来想一想， getopt 的操作并没有特别的繁琐，只是在 flag 很多的情况下， switch 的判断分支会很多。从上面我们会看到使用 getopt 我们要事无巨细的写所有的处理。实际上我们可以做的更加的集中一些， 比如 TJ 的 &lt;a href=&quot;https://github.com/clibs/commander&quot;&gt;commander&lt;/a&gt; 以及 GNU 的 &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Argp.html#Argp&quot;&gt;Argp&lt;/a&gt; 。 后者的使用还是稍重一些。前者就显的比较 modern ， 提供的接口也比较简单，使用起来并不复杂。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;n&quot;&gt;command_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.0.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-v&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--verbose&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;enable verbose stuff&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--required &amp;lt;arg&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;required arg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-o&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--optional [arg]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;optional arg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过 commander 写的比较多的是最后的回调，如果参数很多，而参数处理很简单的话，整个处理的篇幅也比较大，不过这一套实现命令行的处理机制是值得我们去学习的，结构化处理易于维护。&lt;/p&gt;

&lt;p&gt;现在我们来看一看 commander 的实现原理：&lt;/p&gt;

&lt;p&gt;command_option 函数将所定义的长短参数放入对应的 struct 域中， 着重说一下在长参数处理上。需要将这个字符串拆分成长参数和 arguments。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;--required &amp;lt;arg&amp;gt;&lt;/code&gt;  要解析成 &lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;  和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;arg&amp;gt;&lt;/code&gt;  并将这两个分别存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;option-&amp;gt;large&lt;/code&gt;  和  &lt;code class=&quot;highlighter-rouge&quot;&gt;option-&amp;gt;argname&lt;/code&gt;  中。 并根据  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;  和 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;  判定是否是可选还是必须参数。&lt;/p&gt;

&lt;p&gt;在 command_parse 中，首先将 argv 的参数标准化， 即将短参数组合的情况拆分开，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;-abc&lt;/code&gt; 需要转成 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a -b -c&lt;/code&gt;  的形式。接着就是遍历 argv 和 我们之前解析保存的 option 结构，一个一个的比对，如果匹配成功，调用 cb 函数处理结果。&lt;/p&gt;

&lt;p&gt;基本的解析过程就是这样，思路很简洁，没有特别绕的地方，如果有兴趣，建议走读一遍代码。&lt;/p&gt;

&lt;p&gt;在实际使用中， commander 仍然有一些不能处理情况，比如：当使负数时，负数会被误认为是 flag， 同时不支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt; 终止操作, getopt 和 getopt_long 是支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;  的， 所以这里需要 hack 一下 commander 的代码，由于代码的结构清晰，所以自己扩展一下使用很方便。这是我之前提交的一个 &lt;a href=&quot;https://github.com/clibs/commander/pull/23&quot;&gt;PR&lt;/a&gt; 用来支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt; 的， 但是未被合并 :(  。&lt;/p&gt;

&lt;p&gt;还有一种情况——子命令， 最典型的例子就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;。Git 提供了很多的子命令，每个子命令又有自己的 flag，所以此时一种更加通用的解析方式很必要。接下来我们理解一下 Git 是如何处理命令行参数的。&lt;/p&gt;

&lt;p&gt;首先 Git 是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;common_cmd.c&lt;/code&gt;  中的 main 启动，之后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git.c&lt;/code&gt;  中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_main()&lt;/code&gt; 函数。在 cmd_main 函数中包含对命令行的处理。首先将 Git 的子命令或者说是内置命令定义在一个结构中： ` struct cmd_struct commands[] ` 。这个表中定义的是子命令的名称以及该命令对应的处理函数，这些处理函数的实现是在单个的文件中。 Git 会优先处理内置命令，由于子命令是紧接着 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;  出现的，所以先从 commands 表中找到对应命令，如果有则通过  &lt;code class=&quot;highlighter-rouge&quot;&gt;handle_builtin()&lt;/code&gt; 函数进行，如果不是内置命令，则再去处理其他参数，Git 的处理 flag 的过程是直接解析，并没有采用 getopt 的形式，所谓的直接解析指的是在一个循环中通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;strcmp&lt;/code&gt; 对参数进行匹配。&lt;/p&gt;

&lt;p&gt;在处理子命令时， git 采用类似的思路，即子命令本身的 flag 解析则是将该命令的 flag 定义到 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct option &lt;/code&gt;   中，将这个 options 传入 &lt;code class=&quot;highlighter-rouge&quot;&gt;parse_options()&lt;/code&gt; 函数中进行解析， 接着再回到子命令的处理函数中继续处理。 这种处理方式的关键部分是这个 option 结构体，我们可以看一下 struct option 的结构定义：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_opt_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;short_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;long_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;parse_opt_cb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结构的中的前面几个域是比较一目了然的，需要说一下的是 flags， 这个 flags 里面定义该参数的一些行为， 比如： &lt;code class=&quot;highlighter-rouge&quot;&gt;PARSE_OPT_OPTARG &lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PARSE_OPT_NOARG &lt;/code&gt;  等， 这里面严格区分了是参数可选，有参数， bool型 flag 等。此外，对于某些参数的处理也可以直接调用 callback 进行更复杂的处理。&lt;/p&gt;

&lt;p&gt;在 parse_options() 中，根据预定义的 options 表，进行更加细致的处理， 在这里是 parse_options 是一个通用的处理函数。可以类比成 getopt 函数的作用。所有的动作都通过结构体中定义的项进行，相当高效。Git 的这一套机制在后续添加新的命令时，更加的灵活，通过提供一套解析的模板，只需要实现相应的命令各自的处理函数即可，耦合度低。&lt;/p&gt;

&lt;p&gt;再回到 C 本身，对子命令的处理也提供一个方案。 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;stdlib.h&lt;/code&gt;  中提供了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;getsubopt&lt;/code&gt;  函数用来处理 子option 的参数，需要搭配 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 使用。具体的例子可以参考 man 手册中的 EXAMPLE 小节。&lt;/p&gt;

&lt;p&gt;从 C 的角度而言，解析的活儿都是自己来干的，这也让我们更加清晰的认识到解析命令行参数的一个基本思路，剩下的就是按需设计想要的方式。如果不想这么麻烦，我们可以参考借鉴一下 Go 以及其他语言的用法，然后自己实现一套。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;go-语言篇&quot;&gt;Go 语言篇&lt;/h3&gt;

&lt;p&gt;来到高级语言这部分之后，对于命令行的处理似乎能够更加的方便快捷了。 Go 语言中提供的 flag 包，支持一般参数的形式解析以及子命令的解析，在解析的扩展方面 Go 也是很灵活的。&lt;/p&gt;

&lt;p&gt;Go 的 flag 标准库基本能满足基本的日常使用，但是仍有一些不太畅快的地方。 毕竟命令行的使用没有一个通用的方式，不同的系统或者说不同的软件所使用的命令行的风格也有所不同。Go 所支持的命令行语法比较简单：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// non-boolean flags only&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时默认为所有的 flag 添加了长 flag 语法。由于这样的语法定义很简单，因此就不支持短 flag 的组合，以及多参数的情况。我们阅读 flag 包的源码就能发现，在解析参数时采用的是一个 for 循环，从头到尾的解析所有的参数，所以 flag 都是定义死的，所以短参数的组合是不能识别的，flag 包会直接给出 help 的信息。硬解析就是这样，只要 flags 不在预定义的 flags 中，则认为错误。&lt;/p&gt;

&lt;p&gt;我所说的多参数指的是下面的这样的情况：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们期望 &lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt; 能返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;[str1, str2]&lt;/code&gt; , Go 标准包提供的参数类型中没有复合类型，所以会导致后面解析的参数会覆盖掉前面已经解析保存的参数。好在官方文档中有提供一个自定义类型的解析的示例，这个扩展得益于 Go 的 interface 机制。 所以我们只需要将自定义的类型实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;  接口即可，这个 interface 的定义为：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也就是说我们需要对自定义的类型实现下 &lt;code class=&quot;highlighter-rouge&quot;&gt;String 和 Set&lt;/code&gt; 方法。那上面所说的多参数问题，就可以使用定义成 slice 或者其他可以保存多个数据的类型，如何保存就需要在 Set 方法中实现，这一点是很方便的。&lt;/p&gt;

&lt;p&gt;此外，flag 包还支持子命令的定义，需要先创建一个 flagset 类型， 然后将子命令的定义添加到刚定义的 flagset 类型中，所使用的方法定义和我们直接使用 flag 包级别的方法是一致的，这个大大降低了开发的心智。&lt;/p&gt;

&lt;p&gt;还有一点就是，Go 的 flag 包没有命令行的可选参数和必选参数的概念。有的只是如果没有设置这个 flag 那么就是用默认值，设置了就将该 flag 紧接着的 paramater 解析为需要的参数。这种做法有利有弊，好处在于规范命令行的使用，flag 要么设置（除了布尔型的 flag）， 设置了就必须有值。 但是也带来了一个错误, 比如对后面需要带有参数的 flag 未设置参数，那会导致后面的 flag 被误认为是参数。&lt;/p&gt;

&lt;p&gt;总之 Go 这么定义 flag 包，在没有特殊需求的时候可以很快速的完成简单命令行的设计。 对比 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 就能发现，一旦我们定义好了 flag 的规则，那么解析后返回的结果就可以使用了，而不再需要一个循环去处理每次的返回值。这一点是极大的提高了开发时的效率，但这个效率也是建立在你的命令行处理不复杂的情况下。&lt;/p&gt;

&lt;p&gt;Go 标准包功能只是一个基础，功能上并不丰富，所以第三方的包也就有较大的选择空间，一个没有太多学习成本且是 for hunman 的包就很受欢迎，目前比较流行的是 &lt;a href=&quot;https://github.com/ogier/pflag&quot;&gt;pflag&lt;/a&gt; 、&lt;a href=&quot;https://github.com/alecthomas/kingpin&quot;&gt;kingpin&lt;/a&gt; 这两种。 两者各有各的特色，需要自己根据实际需求去取舍一下， 在这里就不详细的去叙述两者的实现原理，只补充一点流式函数的使用能够让写代码的人很爽，这一点在 C 中就很难体验到。 同时省去了一大部分的内存管理的烦恼，使用高级语言来编程确实舒服。&lt;/p&gt;

&lt;p&gt;最后还有一个比较不错的框架推荐下，&lt;a href=&quot;https://github.com/spf13/cobra&quot;&gt;cobra&lt;/a&gt;  。 这是一个用来开发命令行工具的框架，一些大的项目也用它来开发，比如 Kubernetes。通过命令直接初始化好一个项目，增加子命令以及在子命令中添加 flag 都非常的方便。 有兴趣的话，可以研究研究。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;python-篇&quot;&gt;Python 篇&lt;/h3&gt;

&lt;p&gt;到了 Python 这边，上面的这些解析的方式 Python 都能驾驭，然而当 &lt;a href=&quot;http://docopt.org/&quot;&gt;dotopt&lt;/a&gt; 出现的后，基本上算是秒杀其他。用法就是你只要按照规范写好 Usage 信息即可，剩下的你就不用管了。解析之后你将得到一个 dictionary， key 是你 Usage 里面出现的所有和 flag 相关的内容。&lt;/p&gt;

&lt;p&gt;基本思路是先将 Usage 部分先解析出 option，之后再根据 argv 来解析实际的参数，这一块实际和前面的解析方法是一致的。所以基本上你能看到使用 dotopt 后，代码就非常的简洁：(代码来自官方 repo 示例)&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Naval Fate.

Usage:
  naval_fate.py ship new &amp;lt;name&amp;gt;...
  naval_fate.py ship &amp;lt;name&amp;gt; move &amp;lt;x&amp;gt; &amp;lt;y&amp;gt; [--speed=&amp;lt;kn&amp;gt;]
  naval_fate.py ship shoot &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;
  naval_fate.py mine (set|remove) &amp;lt;x&amp;gt; &amp;lt;y&amp;gt; [--moored | --drifting]
  naval_fate.py (-h | --help)
  naval_fate.py --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --speed=&amp;lt;kn&amp;gt;  Speed in knots [default: 10].
  --moored      Moored (anchored) mine.
  --drifting    Drifting mine.

&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;docopt&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;docopt&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;docopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__doc__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Naval Fate 2.0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所有的一些就都在 arguments 这个 dictionary 中了，我们只需要按照需求来获取对应 flag 的参数。 使用 dotopt 的前提是你需要熟悉并且按照 POSIX 的方式来定义你的 usage 。 这算是一个学习的成本，一旦掌握了这个定义的方式，那剩下的就是一行代码的事儿。 这基本上可以说是秒杀了一众其他的解析。 作者的一个视频里面也调侃了目前 Python 中使用的比较多的几个解析命令行工具。确实，在 docopt 的实例里面，对 git 的命令解析做了一个示范，确实简洁了很多，我们无需关系解析的细节，只需要关系最终的结果。&lt;/p&gt;

&lt;p&gt;此外这一套解析方式已经被移植到其他的语言上了，可以参考这个&lt;a href=&quot;https://github.com/docopt&quot;&gt;链接&lt;/a&gt;。 出此之外，我个人觉得在 Python 更加容易上手的一个工具是 argparse。 形式类似于上面的 Commander， 简单示例如下：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argparse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArgumentParser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_argument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'-s'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'store'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'src'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;seach a pattern&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_argument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'-p'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'store'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'print_lately'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nargs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'?'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'print n lately words'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这其中 action 表示的是 flag 的属性，是带参数的还是一个布尔型的。 dest 是对每一个 flag 所做的操作的保存，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;result.src&lt;/code&gt; ， 此外还有其他的属性可以设置。具体的可以参考 argparse 的手册。 同时我们也能发现这样的做法实际上和我们在 C 中定义结构体的方式是类似的，只是不同的语言所实现的方式不一样罢了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;经过上面这一通整理，对命令行的解析以及相关工具的使用应该是比较清晰了。使用现成的库或者包进行命令行解析，可以提高效率，减轻一些心智负担，但是通过手动去写解析方式能够带来更高的灵活性。工具只是一种解决问题的方式，明白其中的实现原理，造轮子也只是时间的事儿。&lt;/p&gt;

&lt;p&gt;(全文完)&lt;/p&gt;

</description>
        <pubDate>Wed, 27 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/27/command-line/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/27/command-line/</guid>
        
        <category>Linux</category>
        
        <category>Programming</category>
        
        
      </item>
    
      <item>
        <title>Bash Shell Script 杂记</title>
        <description>&lt;p&gt;shell 作为日常编程中比较方便的工具，通过一些 shell 脚本可以完成很多的事情，但是 shell 本身的一些语法比较古怪，且在不同的系统上所体现的结果有时候也不尽相同。日常使用中我们会遇到一些问题，同时也会积累一些比较好的惯用法，这篇文章主要的目的就是对某些细节进行分析，同时也会对一些习惯用法进行总结。注意本文所提及的语法在 bash 中验证通过，所以如果你使用的是 zsh 或者其他 shell， 在使用脚本的时候建议加上: &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;&lt;/code&gt; 。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;positional-parameter-简述&quot;&gt;positional parameter 简述&lt;/h3&gt;

&lt;p&gt;在 bash 手册中，位置参数是这样定义的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A positional parameter is a parameter denoted by one or more digits, other than the single  digit  0.
Positional  parameters  are  assigned from the shell’s arguments when it is invoked, and may be reassigned using the set builtin command.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常我们最熟悉的就是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt; 这样的数字代表的变量。如果超过了10个后，我们可以这样使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;${11}&lt;/code&gt; 。此外还有一些特殊的位置变量。&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; ,&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$#&lt;/code&gt; ,&lt;code class=&quot;highlighter-rouge&quot;&gt;$FUNCNAME&lt;/code&gt;。 最后一个变量其实在一定情况下和 $0 是相同的。&lt;/p&gt;

&lt;p&gt;操作位置参数的方式可以通过内置命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;shift&lt;/code&gt; 。顾名思义就是切换位置参数，如果 shift 不带参数的话，则按位一个一个的切换，&lt;strong&gt;同时也可以指定参数，一次性切换多个&lt;/strong&gt;，下面通过一个例子说明一下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+defined&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;# do something &lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;shift
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遍历整个位置参数，同时还防止当 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt; 为空的时候会提前停止的情况，defined 是我们根据实际情况预先定义的。&lt;/p&gt;

&lt;p&gt;我们还可以使用 for 循环来遍历位置参数，比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;arg&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
	 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$arg&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个是使用的位置参数本身作为遍历对象，只会读取位置参数而不会修改，这个算是一个比较安全的操作。&lt;/p&gt;

&lt;p&gt;提到位置参数，有两个经常容易混淆的参数必须要对比到，根据不同的情况的需要，我们可以灵活的使用相应的参数及其形式。 下面通过一个表来展示下这两者的差别。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;输出结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$1 $2 $3 ... ${N}&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$1 $2 $3 ... ${N}&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$*&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$1c$2c$3c...c${N}&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$@&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; ... &quot;${N}&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;这边的 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 是表示的 IFS 的第一个参数。一般情况下还是建议使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$@&quot;&lt;/code&gt; 。 也许你会从中发现一个小的陷阱，即当我们在使用遍历位置参数的时候，如果使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$*&quot;&lt;/code&gt; 将位置参数传到函数中，循环只会执行一次。并不是我们所期望的多次执行。 此外位置参数不添加引号时会自动扩展引号，举个例子就明白了：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# script.sh&lt;/span&gt;
showcount&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;we get&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$# &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'parameter(s)'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

showcount &lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;
showcount &lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;
showcount &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
showcount &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./script.sh &lt;span class=&quot;s1&quot;&gt;'a b'&lt;/span&gt; c d
we get 4 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
we get 4 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
we get 3 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
we get 1 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出前两者将引号中的内容扩展了。同时这个也展示了使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$*&quot;&lt;/code&gt; 作为函数参数传入是，变量个数为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此外在数组那块还会提到和位置参数相关的内容，现在暂时不过多涉及。&lt;/p&gt;

&lt;h3 id=&quot;使用-set-设置-positional-parameter&quot;&gt;使用 set 设置 positional parameter&lt;/h3&gt;

&lt;p&gt;set 的一个作用就是用来设置位置参数，现在不讨论 set 在脚本调试和其他功效上的内容，只讨论在设置位置参数时的作用。首先先看一个简单的例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;a b c
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$3&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
a b c
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边的 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1,$2,$3&lt;/code&gt; 就是位置参数。 我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; 来修改位置参数，比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;b c
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
b c
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;a &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$3&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
a b c
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们后面修改了该位置参数，在原有的基础上，增加了一个新的参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; ， 通过这个属性，我们可以做更多的事情，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; 一下所有的位置参数之类的。 我们再来看下一个例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; hello,   world  &quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;
hello, world
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
hello, world
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子从侧面看可以去掉多个空格，实际上的原理很简单，利用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 的默认输出的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1 $2 $3 ...&lt;/code&gt;，  注意这里没有对变量添加引号，且我们可以看到位置参数并没有被分隔开。这一定程度上可以用做 &lt;code class=&quot;highlighter-rouge&quot;&gt;trim&lt;/code&gt; 函数。&lt;/p&gt;

&lt;h3 id=&quot;here-documents-和-here-strings&quot;&gt;Here documents 和 Here strings&lt;/h3&gt;

&lt;p&gt;这两者都是重定向的一种形式。&lt;strong&gt;Here documents&lt;/strong&gt; 的语法很简单，不过由于也有两种形式，所以在使用的过程中也有一定的差别。语法如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt; &amp;lt;&amp;lt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;-]word
...
...
word
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般用 here documents 的比较多的是在 usage 函数中。在这中间的所有的内容都是直接输出的, 不会做任何的修改，不过注意一点的是，如果使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 那么会将输出的文本中的前导tab去除掉。下面的几个例子展示了 here documents 的实际使用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抑制变量的扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;'
&amp;gt; This is my name &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
&amp;gt; EOF
This is my name &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;       # 这个变量没有被转换成相应的内容
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在管道中使用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;' | sed 's/a/b/g'
&amp;gt; abc
&amp;gt; nab
&amp;gt; EOF
bbc
nbb
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Here strings&lt;/strong&gt; 的基本语法是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;。它的主要作用是可以替代管道进行输入，我们知道使用管道的时候实际是操作是在 subshell 中进行的，所以有些变量在退出了 subshell 的环境后就不存在了。比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello world&quot;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;first second
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$first&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$second&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# nothing will output&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遇到这种情况，一种折中的办法就是在 subshell 中进行输出，使用 group command 进行。但是如果我们想在当前的环境中使用变量，这种方式就不适合了。因此现在使用 Here strings 就比较合适了。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;first second &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$first&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$second&lt;/span&gt;
Hello World
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;looks good！很完美的解决了这个问题。&lt;/p&gt;

&lt;h3 id=&quot;多使用-printf-而不是-echo&quot;&gt;多使用 printf 而不是 echo&lt;/h3&gt;

&lt;p&gt;shell 中的 printf 在一定程度上和 C 语言中的 printf 类似，语法上基本上差别不大。熟悉 C 的话，使用这些还是很简单的。echo 默认输出换行符，且在不同的系统上的表现也不同，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; 是没办法输出来的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;$ echo -n
$ echo '-n'  # cannot output
$ echo -e '\055n'
-n
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 printf 可以做一些比较 cool 的事儿。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# 格式化输出&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d | %0o | 0x%x'&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;126&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;126&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;126&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 绘制水平线&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%.0s-'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;1..20&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数学计算&quot;&gt;数学计算&lt;/h3&gt;

&lt;p&gt;目前推荐使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(( ))&lt;/code&gt; 进行数学计算，虽然使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;  也可以完成相应的工作但是使用前者是比较稳妥的，且不容易出错。&lt;/p&gt;

&lt;p&gt;首先在 bash 中，数字的表示形式有如下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0...&lt;/code&gt;  表示为八进制数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x...&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;0X...&lt;/code&gt;  表示为十六进制数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;BASE&amp;gt;#...&lt;/code&gt;  根据 base 来解析后面的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其余的则会被当做十进制的数来使用。 对于第三种情形，需要着重说一下，这个语法的目的是为了将其他不同 base 的值转换成十进制的值。 比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;16#abc&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
2748
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2#010101&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
21
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10#abc&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
bash: 10#abc: value too great &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;base &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;error token is &lt;span class=&quot;s2&quot;&gt;&quot;10#abc&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以我们可以看到，即使数字没有使用相应的机制标识开头也同样可以转换成十进制。同样的如果想将十进制转换成其他的进制的，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; 格式化输出。&lt;/p&gt;

&lt;p&gt;下面来说一下计算部分，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(())&lt;/code&gt; 中支持大部分的数学计算语法。逻辑运算，位操作，以及常规的数据运算都是支持的。下面通过一些基本的例子展示下数学计算：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;, a+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
5
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;, a++&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们需要注意的是，返回值是最后一个表达式的结果。 除此之外，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(())&lt;/code&gt; 中也是支持变量操作的。比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16#abc, &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16#&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;:0:2&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s, %s\n'&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;
2748, 39
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边涉及到了子串扩展，这个在后面详细说明。 不过并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 将会被扩展为 $((1[0]))&lt;/span&gt;
bash: 1[0]: syntax error: invalid arithmetic operator &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;error token is &lt;span class=&quot;s2&quot;&gt;&quot;[0]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[0]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}))&lt;/span&gt; 
1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 解析为 $((&quot;1&quot;)) &lt;/span&gt;
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的这一点我们就得注意下，有些变量并不一一定能在数学扩展中解析出来。此外，我们也可以用变量扩展作为布尔值的判断。比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;1 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;false&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# false&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;shell 中的数学计算基本上就是这些，还有其他的内容后续继续增加。&lt;/p&gt;

&lt;h3 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;我们在写脚本时，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;awk&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;perl&lt;/code&gt; 等工具自带的正则。但是如果不是很复杂的情况， 单独使用 bash 自带的正则就可以了。bash 本身支持的是 ERE 语法，同时也支持 group 匹配。RE 的语法在这里不多说了，正则表达式在有时候会比较清晰一些。比如下面的这个例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls 
&lt;/span&gt;1_abc.txt  245_def.txt 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将上述的文件名中的数字转换成16进制的。 这个问题解决的办法很多，我们尝试使用 RE 来解决这个问题。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;convert&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'^([0-9]+)_(.*)$'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~ &lt;span class=&quot;nv&quot;&gt;$rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%04x%s'&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;BASH_REMATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[1]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;BASH_REMATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[2]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;匹配到数字部分和字符串部分然后将其通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; 输出。匹配到的分组部分保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;BASH_REMATCH &lt;/code&gt;中， 不过通过 bash 的字符串子串操作也可以轻松完成。不过在获取子串这块语法会存在一些混淆，这个后面再说，现在看看使用子串如何解决这个问题。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# bad， not safe&lt;/span&gt;
convert&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%%_*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;##*_&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%04x%s'&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$number&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$other&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上通过子串分割更加的快捷，不过需要保证每个文件都是统一的格式，不存在其他的格式。所以使用正则的好处是对于不符合条件的文件名不进行分割，在一定程度上更加的安全一些。&lt;/p&gt;

&lt;h3 id=&quot;字符串子串&quot;&gt;字符串子串&lt;/h3&gt;

&lt;p&gt;bash 中有不少的扩展，其中包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;paramater expand&lt;/code&gt; 。 先不讨论有关变量赋值的扩展，只讨论和子串有关的部分。首先和其他脚本语言中比较类似的切片语法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter:offset[:length]}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个扩展很好理解，返回值为 parameter 从 offset 处开始的 length 个字符。 这个 offset 可以为负数，其中 length 是可选。 parameter 可以为位置参数，在这种情况下索引是默认从 1 开始的。其他的情况下索引是从 0 开始的。一个简单的例子展示一下这个是如何扩展的。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;substring.sh
&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;This is a string&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;:2:2&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;:5&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./substring.sh 1 2 3 4 5
2 
3
is a string
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个扩展对数组也是可以使用的，不过如果使用在关系型数组上，其结果是未定义的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter#word}&lt;/li&gt;
  &lt;li&gt;${parameter##word}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除掉匹配的前缀，所谓的前缀就是 word 所表示的。word 部分可以使用通配符来表示，有关通配符的内容见后面。 这个匹配一般在获取后缀名或者是目录名比较有用。 比如下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ mypath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$mypath&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
/home/user/work/shell
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mypath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;#*/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
home/user/work/shell
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mypath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;##*/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
shell
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 表明匹配最短的前缀； 两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;##&lt;/code&gt; 表明匹配最长的前缀。 前缀部分的内容需根据实际情况来决定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter%word}&lt;/li&gt;
  &lt;li&gt;${parameter%%word}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除掉后缀，原理同上面的。word 部分支持通配符的表示。这个一般在获取文件名或者目录的 path 比较有用。所以我们可以这样使用：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ myfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;base.name.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;myfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%.*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
base.name
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;myfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%%.*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
base
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是也能看到这个扩展的局限性，就是匹配的结果要么最少，要么最多，没有达到一个平衡，不过这些都需要我们自己去衡量与选择。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter/pattern/string}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模式替换，实际上就是将匹配到的内容用 string 替换掉。这个功能有一些使用的技巧，整理如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;场景&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pattern 以&lt;code class=&quot;highlighter-rouge&quot;&gt;/ &lt;/code&gt;开头&lt;/td&gt;
      &lt;td&gt;替换掉所有匹配的 pattern&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pattern 以&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 开头&lt;/td&gt;
      &lt;td&gt;必须是头部就匹配到 pattern&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pattern 以&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; 开头&lt;/td&gt;
      &lt;td&gt;必须是尾部开始匹配到 pattern&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string 为空&lt;/td&gt;
      &lt;td&gt;删除掉匹配到的 pattern&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;除此之外，如果参数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; 或者  &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 的话，则对每一个参数都使用这样的匹配。下面通过几个例子来简单说明下:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;This is a string&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/is/IS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# only first matched will be replaced&lt;/span&gt;
ThIS is a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;//is/IS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# each matched will be replaced&lt;/span&gt;
ThIS IS a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/#T/t&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# replace first character&lt;/span&gt;
this is a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/%sting/STRING&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# repalce end if the string&lt;/span&gt;
This is a STRING
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/is&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# delete first matched&lt;/span&gt;
Th is a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;//is&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# delete all matched&lt;/span&gt;
Th  a string
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要是需要记住一些符号的使用，其他的内容，现在不在这边过多的涉及，讨论过多后更加容易混淆，这边只介绍和子串相关的内容，至于大小写转换的功能，这些提及的比较少，所以也不整理了。&lt;/p&gt;

&lt;h3 id=&quot;通配符&quot;&gt;通配符&lt;/h3&gt;

&lt;p&gt;要完整的理清统配符的内容，得单独理出一篇。不过在这边主要是说明一些最基本的。至于通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;shopt&lt;/code&gt; 打开相关的扩展之类的，暂时不涉及。&lt;/p&gt;

&lt;p&gt;实际上通配符只是一个低配版的 RE，语法标记上简化了很多。注意  &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 在通配符中没有特殊含义，仍然代表的是原本的含义。 在 bash 中一般是如下的几个标记：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;  匹配一个或者多个字符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;  匹配一个字符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[...]&lt;/code&gt; 匹配这个集合中的任意一个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们使用的最多的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; ，这在遍历文件是最常用到：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;file &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
	......
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除此之外，我们在 case 中经常会使用到这个，比如验证输入Yes/NO。 我们可以这样做：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Yy]|&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Nn]&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;nv&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unknown character&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上我们在使用  &lt;code class=&quot;highlighter-rouge&quot;&gt;[[&lt;/code&gt;时也可以使用通配符，比如下面这样的方式：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Ee]rror &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; 
	... 
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外还有一些范围相关的通配符，比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;[a-h]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[:alnum:]]&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;[[:digit:]_.]&lt;/code&gt; 等，这些用法是合法的。如果你熟悉 RE，这些应该不会太陌生。 至于取反操作有的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; , 表示非。 余下的扩展部分可以看之前整理的&lt;a href=&quot;http://jesseeisen.github.io/2016/08/16/shell-glob.html&quot;&gt;shell-glob&lt;/a&gt;， 这里面有对扩展部分的例子。&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/15/bash-shell/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/15/bash-shell/</guid>
        
        <category>bash</category>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>Bash 重定向</title>
        <description>&lt;p&gt;在日常的 bash 脚本或者命令行的使用中，我们经常会使用到重定向，我们会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt; 这样简单的基于标准文件描述符的重定向。如果使用到一些比较复杂的重定向时，重定向也会因为顺序的不同而产生不同的结果。所以有必要来理一理重定向的相关问题。&lt;/p&gt;

&lt;h3 id=&quot;the-basics&quot;&gt;The basics&lt;/h3&gt;

&lt;p&gt;在 linux 上，当我们打开一个 terminal 的时候，, 默认打开了三个文件描述符：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;standard input:  &lt;strong&gt;值为 0&lt;/strong&gt;  可用&lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;表示&lt;/li&gt;
  &lt;li&gt;standard output: &lt;strong&gt;值为 1&lt;/strong&gt;  可用&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;表示&lt;/li&gt;
  &lt;li&gt;standard error: &lt;strong&gt;值为 2&lt;/strong&gt;  可用&lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;表示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这三个标准的文件描述符，我们还可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; 来打开更多的文件描述符。&lt;/p&gt;

&lt;h3 id=&quot;1output-redirection&quot;&gt;1.Output Redirection&lt;/h3&gt;

&lt;p&gt;输出重定向，基本语法 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;gt; file&lt;/code&gt; (n 表示描述符的值）。一般使用它是 &lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;gt; file&lt;/code&gt;（同样可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;command 1&amp;gt;file&lt;/code&gt;）, 它主要是将原本输出到&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;上的内容重定向到了&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;，改变的是标准输出。&lt;/p&gt;

&lt;p&gt;如果想将标准错误的结果重定向，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;command 2&amp;gt;file&lt;/code&gt;。这就将原来输出到标准错误的内容，重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;中。同样&lt;code class=&quot;highlighter-rouge&quot;&gt;command 3&amp;gt;file&lt;/code&gt;这个命令是将&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;这个文件描述符重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;2input-redirection&quot;&gt;2.Input Redirection&lt;/h3&gt;

&lt;p&gt;输入重定向，基本语法&lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;lt; file&lt;/code&gt;(n 表示描述符的值）。一般用它来改变&lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;的值。可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;lt;file&lt;/code&gt;将 file 重定向到标准输入。同样&lt;code class=&quot;highlighter-rouge&quot;&gt;command 3&amp;lt;file&lt;/code&gt; 将 file 重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;上。&lt;/p&gt;

&lt;h3 id=&quot;3pipe&quot;&gt;3.Pipe&lt;/h3&gt;

&lt;p&gt;管道 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 主要是将连接了标准输出和标准输入， &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 左边是标准输出， 右边是标准输入。&lt;/p&gt;

&lt;h3 id=&quot;duplicating&quot;&gt;Duplicating&lt;/h3&gt;

&lt;p&gt;上面介绍的是我们比较常用的三个方式，接下来是&lt;strong&gt;复制文件描述符&lt;/strong&gt;。我们经常会看到这样的用法&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;。这个重定向的意思是：&lt;strong&gt;写到文件描述符 2 的内容将写到文件描述符 1 指向的地方&lt;/strong&gt;（不说 stdout/stderr 是因为这两个可以在此之前已经被重定向了）。&lt;/p&gt;

&lt;p&gt;这边所谓的复制可以这样理解。在&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;后，这两个描述符都指向了同一个地方。复制文件描述符可以抽象成&lt;code class=&quot;highlighter-rouge&quot;&gt;m&amp;gt;&amp;amp;n&lt;/code&gt;, 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;是两个描述符。&lt;/p&gt;

&lt;p&gt;通过一个例子理解下复制：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file
line 1
line 2
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;file
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; 3 line
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
line 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;4&amp;gt;&amp;amp;3
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; 4 line
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
line 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到在执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;4&amp;gt;&amp;amp;3&lt;/code&gt;后，使用描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;同样能读到&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;指向的那个文件的下一行。这就表明将&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;复制给了&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;order-of-redirection&quot;&gt;Order Of Redirection&lt;/h3&gt;

&lt;p&gt;使用重定向的顺序也是需要注意的，比如一个很经典的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Q:what’s the difference between 2&amp;gt;&amp;amp;1 &amp;gt;foo and &amp;gt;foo 2&amp;gt;&amp;amp;1, and when do I use which?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;利用这个问题来说明一下不同的顺序使用重定向会带来什么影响。首先从：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1 &amp;gt;foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;将描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;复制给描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;, 这样&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;都指向了同一个地方。 接着将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;。 但是此时&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;还是指向是&lt;strong&gt;之前&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;指向的地方&lt;/strong&gt;。所以此时&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;不是指向的同一个地方，这相当是将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;备份了一下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;foo 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;foo&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;, 接着&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;复制给&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;。此时&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;都被重定向到了&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;下面的一个例子便能很好的说明这两个的区别：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;f&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is stdout&quot;&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is stderr&quot;&lt;/span&gt; 1&amp;gt;&amp;amp;2
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

f &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;foo 2&amp;gt;&amp;amp;1   &lt;span class=&quot;c&quot;&gt;# nothing printed out&lt;/span&gt;
f 2&amp;gt;&amp;amp;1 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;foo   &lt;span class=&quot;c&quot;&gt;# print &quot;This is stderr&quot; only&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两种方式没有对错，在不同的需求下使用对应的顺序。&lt;/p&gt;

&lt;h3 id=&quot;some-pratical-usages&quot;&gt;Some Pratical Usages&lt;/h3&gt;

&lt;p&gt;在一些情况下，使用重定向会引发一些错误，我们可以使用一些方式去规避它。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sed 命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed 's/a/A/g' file &amp;gt; file&lt;/code&gt;。这个用法估计很多人在不经意间都会用到，实际上这个用法是不会有作用的。我们之所以这么做是想将 sed 做出的修改写入到文件中。所以将标准输出重定向到该文件上。问题就在这儿！ 在 sed 命令执行之前，file 先被重定向，这时 file 就被截断，内容已被清空了，所以 sed 在读文件的时候，什么都读不到。 而正确的做法是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 选项。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注： 千万不要在 sed 中将重定向的文件指定成即将用于输入的那个文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;read 命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 bash 中，我们习惯性使用如下方式来读取文件的内容：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &amp;lt; file

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个用法是没有问题的，也可以很好的执行。不过如果我们在 while 循环体内使用再次使用 read 呢？比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
   &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
   &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Continue to read?&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 1
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &amp;lt; file
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个情况下就会出错了。出错在于，此时循环体内的标准输入已经被重定向到了&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;是要从标准输入中读取，而这时只能从 file 中读取了。这和我们所期望的就有所不同了，
此时可以使用如下方式：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;file
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; 3 line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Continue to read?&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 1
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将文件在描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;上打开，通过 read 指定读取时的描述符，这样就避免了标准输入被重定向的问题。&lt;/p&gt;

&lt;h3 id=&quot;create-more-file-descriptor&quot;&gt;Create More File Descriptor&lt;/h3&gt;

&lt;p&gt;上面简单的提了一下使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;创建描述符，现在介绍一下如何创建合适类型的文件描述符。我们直接从例子来说明创建的过程：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# we have a file named foo&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;foo
hello world
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;foo    &lt;span class=&quot;c&quot;&gt;# create a fd only can used to read.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 5  word &amp;lt;&amp;amp;3 &lt;span class=&quot;c&quot;&gt;# read 5 character from foo&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
hello
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;good&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;3
&lt;span class=&quot;nt&quot;&gt;-bash&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;: write error: Bad file descriptor
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到，再往&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;里面写入的时候报错了，说明此时&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;只是一个只读的文件描述符。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;这个描述符的时候，我们需要利用复制的方式，不然 bash 会将&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;理解成普通的文件。如果当前目录下没有&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;这个文件，
bash 便会报错：No such file or directory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此我们需要用到如下的方式：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;foo  &lt;span class=&quot;c&quot;&gt;# create a read and write fd&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 5 word &amp;lt;&amp;amp;3 &lt;span class=&quot;c&quot;&gt;#read seek the file to position 5&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; / &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;3
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;foo
hello/world
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这会儿的&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;便可读可写。同样的，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exec 3&amp;gt;foo&lt;/code&gt; 创建一个可写的文件描述符。（这个可以结合 Linux 系统编程上的 open 函数理解）&lt;/p&gt;

&lt;h3 id=&quot;close-file-descriptor&quot;&gt;Close File Descriptor&lt;/h3&gt;

&lt;p&gt;如果这个描述符不需要再使用了，可以关闭这个描述符。bash 提供了如下的关闭方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;lt;&amp;amp;-&lt;/code&gt;  关闭一个用于输入的描述符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;&amp;amp;-, &amp;lt;&amp;amp;-&lt;/code&gt;  关闭标准输入&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;gt;&amp;amp;-&lt;/code&gt;  关闭一个用于输出的描述符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;&amp;amp;-, &amp;gt;&amp;amp;-&lt;/code&gt;  关闭标准输出&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;some-abbreviations&quot;&gt;Some Abbreviations&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&amp;amp;&lt;/code&gt;  abbr  &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1 |&lt;/code&gt;  added in bash4&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;gt;/dev/null&lt;/code&gt; abbr &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些缩写可以了解一下，目的是为了能够在别人有使用的时候可以能读懂。&lt;/p&gt;

&lt;h3 id=&quot;small-example&quot;&gt;Small Example&lt;/h3&gt;

&lt;p&gt;当我们想在脚本中，希望 log 能够一边输出到终端上，一边又能写入文件中。这时候也可以使用到重定向，在 linux 中有一个命令&lt;code class=&quot;highlighter-rouge&quot;&gt;tee&lt;/code&gt;是可以将内容输出到标准输出和文件的。我们可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;来实现，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;pass&quot; | tee log&lt;/code&gt;。不过如果有很多的 log，每条都用&lt;code class=&quot;highlighter-rouge&quot;&gt;|tee log&lt;/code&gt; 会比较繁琐。所以可以结合&lt;code class=&quot;highlighter-rouge&quot;&gt;process substitute&lt;/code&gt; 和重定向来简化这个过程。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tee &lt;/span&gt;log&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pass&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样只要往标准输出的内容，都会被丢给&lt;code class=&quot;highlighter-rouge&quot;&gt;tee&lt;/code&gt;. 不过这还不能很完美的工作。原因在于&lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt;是带有缓冲的，所以如果 log 只是有关标准输出的，那么这么使用是没有问题的。不过我们一般也会将标准错误的内容也保存到 log 中的话，可能会出现打印出来的顺序和实际代码中 log 输出的顺序不一致。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;1&amp;gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tee &lt;/span&gt;log&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;2&amp;gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tee &lt;/span&gt;log&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 1 pass&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 2 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 3 pass&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 4 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2

&lt;span class=&quot;c&quot;&gt;#will output&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 1 pass
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 3 pass
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 2 error
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 4 error
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是对 log 顺序有要求的话，这样的输出明显是不符合条件的。 好在 linux 中提供了两个命令&lt;code class=&quot;highlighter-rouge&quot;&gt;stdbuf&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;unbuffer&lt;/code&gt;。这两个命令的原理是不同的，具体的可自行 goole。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;echo_unbuf&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;stdbuf&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O0&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;#unbuffer echo &quot;$@&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 1 pass&quot;&lt;/span&gt;
echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 2 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2
echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 3 pass&quot;&lt;/span&gt;
echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 4 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2

&lt;span class=&quot;c&quot;&gt;#will output like output&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过封装一个&lt;code class=&quot;highlighter-rouge&quot;&gt;echo_unbuf&lt;/code&gt;，这样便能保证了 log 输出的顺序是正确的。最后如果出现了后台命令在程序结束后打印，则可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;来同步一下。&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/70963/difference-between-2-2-dev-null-dev-null-and-dev-null-21/70971#70971&quot;&gt;Difference between some redirections&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tldp.org/LDP/abs/html/io-redirection.html&quot;&gt;IO Redirection&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/08/01/redirection/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/08/01/redirection/</guid>
        
        <category>bash</category>
        
        <category>基础</category>
        
        
      </item>
    
  </channel>
</rss>

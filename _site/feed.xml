<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L.K. Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 23 Jun 2019 23:19:01 +0800</pubDate>
    <lastBuildDate>Sun, 23 Jun 2019 23:19:01 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>命令行解析</title>
        <description>&lt;p&gt;我们在日常编程中，对命令行参数的解析是不可避免的。一般情况下，不同的编程语言都提供了相应的库函数来解析命令行参数。这些库函数有些是比较顺手的，有些则比较原始，通过了解一下不同的解析思路，利用不同语言自有的特性实现一些顺手的命令行解析工具。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;命令行基本概念&quot;&gt;命令行基本概念&lt;/h3&gt;

&lt;p&gt;首先我们得了解一下命令行的基本格式。比如 GNU 的命令行参数的语法惯例如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;命令行参数若是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 开头的则认为是选项（options）&lt;/li&gt;
  &lt;li&gt;多个选项可以在单个的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;  后面（注意选项应为不带参数的形式）&lt;/li&gt;
  &lt;li&gt;选项的名字是一个单个的字符数字的形式（alphanumeric）&lt;/li&gt;
  &lt;li&gt;选项后面可以带参数&lt;/li&gt;
  &lt;li&gt;选项和他的参数之间可以有或者不存在分隔符， 比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;-o foo&lt;/code&gt;  和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-ofoo&lt;/code&gt;  可以认为是相同的&lt;/li&gt;
  &lt;li&gt;选项一般在其他非选项的参数前面出现&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;  表示参数终止， 在这之后的参数都会被认为是非选项，即使是带了 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;  的&lt;/li&gt;
  &lt;li&gt;单独的一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;  一般用来表示读取或者写向标准输入输出&lt;/li&gt;
  &lt;li&gt;选项可以以任意顺序出现，同一个选项也可以出现多次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述的语法，大体上说明了一个基本的命令行该有的形式，但是还有一些细节没有涉及到。 比如一个选项是否接受一个可选参数或者必须带有一个参数。 我们在看一些命令的手册时，往往会看到这样的几个符号：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这几个符号要细究下来，组合的形式比较多，所表示的含义也不尽相同。所以想要定义一个比较标准的命令行 Usage，对于这些参数的组合使用是必须了解的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般我们使用  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;argument&amp;gt;&lt;/code&gt;  表示参数， 这个参数即为选项后面所需要带的参数，或者是正常命令行参数。 比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; program &amp;lt;arg1&amp;gt; &amp;lt;arg2&amp;gt;
 program &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &amp;lt;file&amp;gt;
 program &lt;span class=&quot;nt&quot;&gt;--input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些都是表示参数，一般参数提供出来，未加修饰符都默认是必须提供的参数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可选项&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; option] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; value]
program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&amp;lt;argument&amp;gt;]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt; 表明这个参数或者选项是可选的，可选的意思即为在运行命令时这些是可提供或者不提供的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;互斥&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; | &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
类似于如下写法：
program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
program &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;互斥表明这两个参数或者多个参数只能选择其中之一，如果都出现了，则会报错, 上面的实例中表示可以都不出现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;必选项&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;program: &amp;lt;argument&amp;gt;
program: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &amp;lt;good&amp;gt; | &amp;lt;bad&amp;gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; 是为了来表示必选，或者是作为一个组合的意思。 上面的例子指的是两个选项必须出现其中之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重复&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;FILE]...
program: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&amp;lt;from&amp;gt; &amp;lt;to&amp;gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;重复的意思即为这个参数或者这一组参数可以出现多次。最直观的的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;  可以有参数, 可以同时有多个参数等。&lt;/p&gt;

&lt;p&gt;当我们打开 man 手册的时候，往往会发现在  &lt;code class=&quot;highlighter-rouge&quot;&gt;SYNOPSIS&lt;/code&gt;  这一小节中的内容其实很简单。比如:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;OPTION]... &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;FILE]...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;OPTION&lt;/code&gt;  做一个占位符，在后续将选项的具体形式极其使用说明进行详细描述。 这也为我们在编写 Usage 函数时提供了一个思路。&lt;/p&gt;

&lt;p&gt;一个简单的 usage 示例：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Usage: ./test &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options]
Options:
        &lt;span class=&quot;nt&quot;&gt;-V&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;                 output program version
	&lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--help&lt;/span&gt;                    output &lt;span class=&quot;nb&quot;&gt;help &lt;/span&gt;information
	&lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--verbose&lt;/span&gt;                 &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;verbose stuff
	&lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--required&lt;/span&gt; &amp;lt;arg&amp;gt;          required arg
	&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;, &lt;span class=&quot;nt&quot;&gt;--optional&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;arg]          optional arg
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们在设计一个命令行工具的时候，一些选项的命名实际上是可以遵循一些惯例的，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;--help&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;--version&lt;/code&gt; 等输出基本程序信息。 GNU 列出了一个在 GNU 软件中所使用到的长选项的&lt;a href=&quot;https://www.gnu.org/prep/standards/html_node/Option-Table.html#Option-Table&quot;&gt;说明&lt;/a&gt;。 目的是为了后续的一个兼容，这对我们日常的编写程序也是有一定的指导意义的。&lt;/p&gt;

&lt;p&gt;上面说的这些并不能完全概括所有的情形，只能说作为在 &lt;code class=&quot;highlighter-rouge&quot;&gt;*nix&lt;/code&gt; 上工作的人所习惯的一个范式，不过有了理论基础，实际操作上，不同的语言或者不同的库所提供的解析方式有很大的不同。我们总想解析能做到简单易用，指哪打哪儿的效果，但是现实往往并不能如愿，下面就从我说熟悉几个语言上说一说几种不同的命令行解析思路。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;awk-语言篇&quot;&gt;Awk 语言篇&lt;/h3&gt;

&lt;p&gt;之所以将 awk 放在最开始说，是因为 awk 本身并没有提供命令行解析的相关函数或者库， 即使是 gawk 也没有提供相应的库，所以需要我们自己去实现。正因为如此，将其放在最开始说是很有必要的，因为我们需要去从头到尾的实现下 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 函数, 通过这个过程来了解一下 getopt 的基本原理。&lt;/p&gt;

&lt;p&gt;getopt 一般是在一个循环中使用。 基本的使用框架如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;getopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;使用方式：&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ab:cd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;options 是预先定义的，argc 和 argv 表示的是命令行参数，getopt 最简单的思路如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从命令行中取出合法的 option （短或者长的参数），解析出 flag&lt;/li&gt;
  &lt;li&gt;在 options 中找到对应的 flag， 并检查是否带有参数&lt;/li&gt;
  &lt;li&gt;若是需要带参数的，则将下一个命令行参数设置到 Optarg 中，否则该 flag 解析完成， 返回该 flag。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般 getopt 会维护两个全局变量， Optind 和 Optarg， 前者表示解析到第几个命令行参数， 后者表示该 flag 带有的参数。 getopt 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;  表示一个 flag 是带有参数的。&lt;/p&gt;

&lt;p&gt;下面是 GNU awk 对 getopt 的一个简单实现：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;getopt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argc, argv, options,   thisopt, i&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;c&quot;&gt;# no support  --&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind] &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;--&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                Optind++
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind] &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;~ /^-[^: &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;/&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# flag must start by - and not contain : and space&lt;/span&gt;
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_opti &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 2
        thisopt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind], _opti, 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        Optopt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; thisopt
        i &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; index&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;options, thisopt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Opterr&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%c -- invalid option&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, thisopt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/dev/stderr&quot;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_opti &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind]&lt;span class=&quot;o&quot;&gt;)){&lt;/span&gt;
                        Optind++
                        _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else
                        &lt;/span&gt;_opti++
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;?&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;options, i+1, 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind], _opti + 1&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        Optarg &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; substr&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind], _opti + 1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# -abcfoo&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else
                        &lt;/span&gt;Optarg &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; argv[++Optind]
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else
                &lt;/span&gt;Optarg &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_opti &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; _opti &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;argv[Optind]&lt;span class=&quot;o&quot;&gt;)){&lt;/span&gt;
                Optind++
                _opti &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else
                &lt;/span&gt;_opti++
        &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;thisopt
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个 getopt 的实现不支持长参数解析，同时使用上也很有局限性，但是很清楚的说明了 getopt 的基本原理。 我们可以这么使用：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;BEGIN &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	Opterr &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
    Optind &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;flag &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; getopt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ARGC, ARGV, &lt;span class=&quot;s2&quot;&gt;&quot;ab:cd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    	&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;flag=%c , optarg=%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;, flag, Optarg&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; Optind &amp;lt; ARGC&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; Optind++&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    	&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Non-option argument:[%d] %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; Optind, ARGV[Optind]&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 getopt 主体在结果处理上，每次解析出来的 flag 和 optval 可以按照我们想要的方式进行处理。由于 getopt 的使用方式是通用的，如果你熟悉 getopt ，只要支持 getopt 的情况下，一般都能做到上手就用，最多也就是阅读下 man 手册上的一些细节和 feature。&lt;/p&gt;

&lt;p&gt;上面实现的 getopt 不支持长参数，若要加入对长参数的解析并不是很困难，只需要在执行解析前将长短 flag 做一个映射即可，这在 awk 中可以直接使用关系型数组即可，比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;longopts[&lt;span class=&quot;s2&quot;&gt;&quot;create&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;
longopts[&lt;span class=&quot;s2&quot;&gt;&quot;verbose&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;V&quot;&lt;/span&gt;
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设置这个 map 后，当我们解析出是长参数时，判断一下当前定义的长参数是否在 longopts 中，可以这么做：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!(&lt;/span&gt;lopt &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;longopts&lt;span class=&quot;o&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# error print&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;?&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

opt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; longopts[lopt]
&lt;span class=&quot;c&quot;&gt;# then we just return the opt&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般命令行操作都会提供长短参数配套使用机制的。但是也有需求是只提供长参数，并不与短参数绑定，所以只需要将这个 map 的值设置成我们期望返回的即可。&lt;/p&gt;

&lt;p&gt;awk 的好处就在于能够快速搭建一个原型，这对我们后续对 C 的分析有很大的帮助。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;c-语言篇&quot;&gt;C 语言篇&lt;/h3&gt;

&lt;p&gt;C 语言中我们大多使用的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt_long&lt;/code&gt;  这两个标准库中的函数，我们所以做的就是在定义好 flag 后需要自己去解析，一方面很自由，如何去处理 flag 所带的参数是由开发者自己去实现；另一方面又显得很繁琐， 因为有时候我只想解析后就能直接使用 。&lt;/p&gt;

&lt;p&gt;C 中的 getopt 和上述的 awk 方式类似，所以这边不多加叙述。 按照一种更好的做法，在 C 中最好是使用 getopt_long，因为有对长参数的支持。下面就来说一说 getopt_long 的基本使用情况。&lt;/p&gt;

&lt;p&gt;在 AWK 篇的最后我们简单的说了下实现对长参数的解析的方式，C 中没有关系型数组，但是 C 可以定义结构，因此，当我们使用 getopt_long 的时候，我们需要初始化一个结构体。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; 	&lt;span class=&quot;n&quot;&gt;has_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; 	&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这四个参数中最后两个参数比较灵活一些，前面两个从字面意义上也能看：第一个是长标签的名字，第二个为是否有参数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flag&lt;/code&gt; 如果设置为 NULL， 那么 getopt_long 就将返回 val， 如果 flag 不为空，而是指向一个变量，那么 getopt_long 返回 0， 并将 val 赋值给 flag 指向的变量。&lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt; 的作用就是作为 getopt_long 的返回值，或者是给 flag 指向的变量赋值。&lt;/p&gt;

&lt;p&gt;而如果我们想将长短参数进行绑定的话，只需要将 flag 设置为 NULL， 并将 val 设置成短参数的值，这样 getopt_long 返回的值和是短参数时一致。至于实现原理，基本上和 getopt 类似，只是需要多加一个对长参数的解析以及寻找到与之绑定的短参数(或者直接返回指定的val)。&lt;/p&gt;

&lt;p&gt;具体的使用例子就不在此描述了，可以看下 getopt_long 的 man 手册，里面提供了相关的示例。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;回过头来想一想， getopt 的操作并没有特别的繁琐，只是在 flag 很多的情况下， switch 的判断分支会很多。从上面我们会看到使用 getopt 我们要事无巨细的写所有的处理。实际上我们可以做的更加的集中一些， 比如 TJ 的 &lt;a href=&quot;https://github.com/clibs/commander&quot;&gt;commander&lt;/a&gt; 以及 GNU 的 &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Argp.html#Argp&quot;&gt;Argp&lt;/a&gt; 。 后者的使用还是稍重一些。前者就显的比较 modern ， 提供的接口也比较简单，使用起来并不复杂。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;n&quot;&gt;command_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.0.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-v&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--verbose&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;enable verbose stuff&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verbose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--required &amp;lt;arg&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;required arg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-o&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;--optional [arg]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;optional arg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command_parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过 commander 写的比较多的是最后的回调，如果参数很多，而参数处理很简单的话，整个处理的篇幅也比较大，不过这一套实现命令行的处理机制是值得我们去学习的，结构化处理易于维护。&lt;/p&gt;

&lt;p&gt;现在我们来看一看 commander 的实现原理：&lt;/p&gt;

&lt;p&gt;command_option 函数将所定义的长短参数放入对应的 struct 域中， 着重说一下在长参数处理上。需要将这个字符串拆分成长参数和 arguments。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;--required &amp;lt;arg&amp;gt;&lt;/code&gt;  要解析成 &lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;  和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;arg&amp;gt;&lt;/code&gt;  并将这两个分别存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;option-&amp;gt;large&lt;/code&gt;  和  &lt;code class=&quot;highlighter-rouge&quot;&gt;option-&amp;gt;argname&lt;/code&gt;  中。 并根据  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;  和 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;  判定是否是可选还是必须参数。&lt;/p&gt;

&lt;p&gt;在 command_parse 中，首先将 argv 的参数标准化， 即将短参数组合的情况拆分开，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;-abc&lt;/code&gt; 需要转成 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a -b -c&lt;/code&gt;  的形式。接着就是遍历 argv 和 我们之前解析保存的 option 结构，一个一个的比对，如果匹配成功，调用 cb 函数处理结果。&lt;/p&gt;

&lt;p&gt;基本的解析过程就是这样，思路很简洁，没有特别绕的地方，如果有兴趣，建议走读一遍代码。&lt;/p&gt;

&lt;p&gt;在实际使用中， commander 仍然有一些不能处理情况，比如：当使负数时，负数会被误认为是 flag， 同时不支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt; 终止操作, getopt 和 getopt_long 是支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;  的， 所以这里需要 hack 一下 commander 的代码，由于代码的结构清晰，所以自己扩展一下使用很方便。这是我之前提交的一个 &lt;a href=&quot;https://github.com/clibs/commander/pull/23&quot;&gt;PR&lt;/a&gt; 用来支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt; 的， 但是未被合并 :(  。&lt;/p&gt;

&lt;p&gt;还有一种情况——子命令， 最典型的例子就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Git&lt;/code&gt;。Git 提供了很多的子命令，每个子命令又有自己的 flag，所以此时一种更加通用的解析方式很必要。接下来我们理解一下 Git 是如何处理命令行参数的。&lt;/p&gt;

&lt;p&gt;首先 Git 是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;common_cmd.c&lt;/code&gt;  中的 main 启动，之后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git.c&lt;/code&gt;  中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd_main()&lt;/code&gt; 函数。在 cmd_main 函数中包含对命令行的处理。首先将 Git 的子命令或者说是内置命令定义在一个结构中： ` struct cmd_struct commands[] ` 。这个表中定义的是子命令的名称以及该命令对应的处理函数，这些处理函数的实现是在单个的文件中。 Git 会优先处理内置命令，由于子命令是紧接着 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;  出现的，所以先从 commands 表中找到对应命令，如果有则通过  &lt;code class=&quot;highlighter-rouge&quot;&gt;handle_builtin()&lt;/code&gt; 函数进行，如果不是内置命令，则再去处理其他参数，Git 的处理 flag 的过程是直接解析，并没有采用 getopt 的形式，所谓的直接解析指的是在一个循环中通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;strcmp&lt;/code&gt; 对参数进行匹配。&lt;/p&gt;

&lt;p&gt;在处理子命令时， git 采用类似的思路，即子命令本身的 flag 解析则是将该命令的 flag 定义到 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct option &lt;/code&gt;   中，将这个 options 传入 &lt;code class=&quot;highlighter-rouge&quot;&gt;parse_options()&lt;/code&gt; 函数中进行解析， 接着再回到子命令的处理函数中继续处理。 这种处理方式的关键部分是这个 option 结构体，我们可以看一下 struct option 的结构定义：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_opt_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;short_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;long_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;parse_opt_cb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;defval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结构的中的前面几个域是比较一目了然的，需要说一下的是 flags， 这个 flags 里面定义该参数的一些行为， 比如： &lt;code class=&quot;highlighter-rouge&quot;&gt;PARSE_OPT_OPTARG &lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;PARSE_OPT_NOARG &lt;/code&gt;  等， 这里面严格区分了是参数可选，有参数， bool型 flag 等。此外，对于某些参数的处理也可以直接调用 callback 进行更复杂的处理。&lt;/p&gt;

&lt;p&gt;在 parse_options() 中，根据预定义的 options 表，进行更加细致的处理， 在这里是 parse_options 是一个通用的处理函数。可以类比成 getopt 函数的作用。所有的动作都通过结构体中定义的项进行，相当高效。Git 的这一套机制在后续添加新的命令时，更加的灵活，通过提供一套解析的模板，只需要实现相应的命令各自的处理函数即可，耦合度低。&lt;/p&gt;

&lt;p&gt;再回到 C 本身，对子命令的处理也提供一个方案。 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;stdlib.h&lt;/code&gt;  中提供了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;getsubopt&lt;/code&gt;  函数用来处理 子option 的参数，需要搭配 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 使用。具体的例子可以参考 man 手册中的 EXAMPLE 小节。&lt;/p&gt;

&lt;p&gt;从 C 的角度而言，解析的活儿都是自己来干的，这也让我们更加清晰的认识到解析命令行参数的一个基本思路，剩下的就是按需设计想要的方式。如果不想这么麻烦，我们可以参考借鉴一下 Go 以及其他语言的用法，然后自己实现一套。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;go-语言篇&quot;&gt;Go 语言篇&lt;/h3&gt;

&lt;p&gt;来到高级语言这部分之后，对于命令行的处理似乎能够更加的方便快捷了。 Go 语言中提供的 flag 包，支持一般参数的形式解析以及子命令的解析，在解析的扩展方面 Go 也是很灵活的。&lt;/p&gt;

&lt;p&gt;Go 的 flag 标准库基本能满足基本的日常使用，但是仍有一些不太畅快的地方。 毕竟命令行的使用没有一个通用的方式，不同的系统或者说不同的软件所使用的命令行的风格也有所不同。Go 所支持的命令行语法比较简单：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// non-boolean flags only&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时默认为所有的 flag 添加了长 flag 语法。由于这样的语法定义很简单，因此就不支持短 flag 的组合，以及多参数的情况。我们阅读 flag 包的源码就能发现，在解析参数时采用的是一个 for 循环，从头到尾的解析所有的参数，所以 flag 都是定义死的，所以短参数的组合是不能识别的，flag 包会直接给出 help 的信息。硬解析就是这样，只要 flags 不在预定义的 flags 中，则认为错误。&lt;/p&gt;

&lt;p&gt;我所说的多参数指的是下面的这样的情况：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们期望 &lt;code class=&quot;highlighter-rouge&quot;&gt;-s&lt;/code&gt; 能返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;[str1, str2]&lt;/code&gt; , Go 标准包提供的参数类型中没有复合类型，所以会导致后面解析的参数会覆盖掉前面已经解析保存的参数。好在官方文档中有提供一个自定义类型的解析的示例，这个扩展得益于 Go 的 interface 机制。 所以我们只需要将自定义的类型实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;  接口即可，这个 interface 的定义为：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也就是说我们需要对自定义的类型实现下 &lt;code class=&quot;highlighter-rouge&quot;&gt;String 和 Set&lt;/code&gt; 方法。那上面所说的多参数问题，就可以使用定义成 slice 或者其他可以保存多个数据的类型，如何保存就需要在 Set 方法中实现，这一点是很方便的。&lt;/p&gt;

&lt;p&gt;此外，flag 包还支持子命令的定义，需要先创建一个 flagset 类型， 然后将子命令的定义添加到刚定义的 flagset 类型中，所使用的方法定义和我们直接使用 flag 包级别的方法是一致的，这个大大降低了开发的心智。&lt;/p&gt;

&lt;p&gt;还有一点就是，Go 的 flag 包没有命令行的可选参数和必选参数的概念。有的只是如果没有设置这个 flag 那么就是用默认值，设置了就将该 flag 紧接着的 paramater 解析为需要的参数。这种做法有利有弊，好处在于规范命令行的使用，flag 要么设置（除了布尔型的 flag）， 设置了就必须有值。 但是也带来了一个错误, 比如对后面需要带有参数的 flag 未设置参数，那会导致后面的 flag 被误认为是参数。&lt;/p&gt;

&lt;p&gt;总之 Go 这么定义 flag 包，在没有特殊需求的时候可以很快速的完成简单命令行的设计。 对比 &lt;code class=&quot;highlighter-rouge&quot;&gt;getopt&lt;/code&gt; 就能发现，一旦我们定义好了 flag 的规则，那么解析后返回的结果就可以使用了，而不再需要一个循环去处理每次的返回值。这一点是极大的提高了开发时的效率，但这个效率也是建立在你的命令行处理不复杂的情况下。&lt;/p&gt;

&lt;p&gt;Go 标准包功能只是一个基础，功能上并不丰富，所以第三方的包也就有较大的选择空间，一个没有太多学习成本且是 for hunman 的包就很受欢迎，目前比较流行的是 &lt;a href=&quot;https://github.com/ogier/pflag&quot;&gt;pflag&lt;/a&gt; 、&lt;a href=&quot;https://github.com/alecthomas/kingpin&quot;&gt;kingpin&lt;/a&gt; 这两种。 两者各有各的特色，需要自己根据实际需求去取舍一下， 在这里就不详细的去叙述两者的实现原理，只补充一点流式函数的使用能够让写代码的人很爽，这一点在 C 中就很难体验到。 同时省去了一大部分的内存管理的烦恼，使用高级语言来编程确实舒服。&lt;/p&gt;

&lt;p&gt;最后还有一个比较不错的框架推荐下，&lt;a href=&quot;https://github.com/spf13/cobra&quot;&gt;cobra&lt;/a&gt;  。 这是一个用来开发命令行工具的框架，一些大的项目也用它来开发，比如 Kubernetes。通过命令直接初始化好一个项目，增加子命令以及在子命令中添加 flag 都非常的方便。 有兴趣的话，可以研究研究。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;python-篇&quot;&gt;Python 篇&lt;/h3&gt;

&lt;p&gt;到了 Python 这边，上面的这些解析的方式 Python 都能驾驭，然而当 &lt;a href=&quot;http://docopt.org/&quot;&gt;dotopt&lt;/a&gt; 出现的后，基本上算是秒杀其他。用法就是你只要按照规范写好 Usage 信息即可，剩下的你就不用管了。解析之后你将得到一个 dictionary， key 是你 Usage 里面出现的所有和 flag 相关的内容。&lt;/p&gt;

&lt;p&gt;基本思路是先将 Usage 部分先解析出 option，之后再根据 argv 来解析实际的参数，这一块实际和前面的解析方法是一致的。所以基本上你能看到使用 dotopt 后，代码就非常的简洁：(代码来自官方 repo 示例)&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Naval Fate.

Usage:
  naval_fate.py ship new &amp;lt;name&amp;gt;...
  naval_fate.py ship &amp;lt;name&amp;gt; move &amp;lt;x&amp;gt; &amp;lt;y&amp;gt; [--speed=&amp;lt;kn&amp;gt;]
  naval_fate.py ship shoot &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;
  naval_fate.py mine (set|remove) &amp;lt;x&amp;gt; &amp;lt;y&amp;gt; [--moored | --drifting]
  naval_fate.py (-h | --help)
  naval_fate.py --version

Options:
  -h --help     Show this screen.
  --version     Show version.
  --speed=&amp;lt;kn&amp;gt;  Speed in knots [default: 10].
  --moored      Moored (anchored) mine.
  --drifting    Drifting mine.

&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;docopt&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;docopt&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;docopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__doc__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Naval Fate 2.0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arguments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所有的一些就都在 arguments 这个 dictionary 中了，我们只需要按照需求来获取对应 flag 的参数。 使用 dotopt 的前提是你需要熟悉并且按照 POSIX 的方式来定义你的 usage 。 这算是一个学习的成本，一旦掌握了这个定义的方式，那剩下的就是一行代码的事儿。 这基本上可以说是秒杀了一众其他的解析。 作者的一个视频里面也调侃了目前 Python 中使用的比较多的几个解析命令行工具。确实，在 docopt 的实例里面，对 git 的命令解析做了一个示范，确实简洁了很多，我们无需关系解析的细节，只需要关系最终的结果。&lt;/p&gt;

&lt;p&gt;此外这一套解析方式已经被移植到其他的语言上了，可以参考这个&lt;a href=&quot;https://github.com/docopt&quot;&gt;链接&lt;/a&gt;。 出此之外，我个人觉得在 Python 更加容易上手的一个工具是 argparse。 形式类似于上面的 Commander， 简单示例如下：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argparse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArgumentParser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_argument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'-s'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'store'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'src'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;seach a pattern&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_argument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'-p'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'store'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'print_lately'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nargs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'?'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;help&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'print n lately words'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这其中 action 表示的是 flag 的属性，是带参数的还是一个布尔型的。 dest 是对每一个 flag 所做的操作的保存，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;result.src&lt;/code&gt; ， 此外还有其他的属性可以设置。具体的可以参考 argparse 的手册。 同时我们也能发现这样的做法实际上和我们在 C 中定义结构体的方式是类似的，只是不同的语言所实现的方式不一样罢了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;经过上面这一通整理，对命令行的解析以及相关工具的使用应该是比较清晰了。使用现成的库或者包进行命令行解析，可以提高效率，减轻一些心智负担，但是通过手动去写解析方式能够带来更高的灵活性。工具只是一种解决问题的方式，明白其中的实现原理，造轮子也只是时间的事儿。&lt;/p&gt;

&lt;p&gt;(全文完)&lt;/p&gt;

</description>
        <pubDate>Wed, 27 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/27/command-line/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/27/command-line/</guid>
        
        <category>Linux</category>
        
        <category>Programming</category>
        
        
      </item>
    
      <item>
        <title>Bash Shell Script 杂记</title>
        <description>&lt;p&gt;shell 作为日常编程中比较方便的工具，通过一些 shell 脚本可以完成很多的事情，但是 shell 本身的一些语法比较古怪，且在不同的系统上所体现的结果有时候也不尽相同。日常使用中我们会遇到一些问题，同时也会积累一些比较好的惯用法，这篇文章主要的目的就是对某些细节进行分析，同时也会对一些习惯用法进行总结。注意本文所提及的语法在 bash 中验证通过，所以如果你使用的是 zsh 或者其他 shell， 在使用脚本的时候建议加上: &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;&lt;/code&gt; 。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;positional-parameter-简述&quot;&gt;positional parameter 简述&lt;/h3&gt;

&lt;p&gt;在 bash 手册中，位置参数是这样定义的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A positional parameter is a parameter denoted by one or more digits, other than the single  digit  0.
Positional  parameters  are  assigned from the shell’s arguments when it is invoked, and may be reassigned using the set builtin command.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常我们最熟悉的就是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt; 这样的数字代表的变量。如果超过了10个后，我们可以这样使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;${11}&lt;/code&gt; 。此外还有一些特殊的位置变量。&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; ,&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;$#&lt;/code&gt; ,&lt;code class=&quot;highlighter-rouge&quot;&gt;$FUNCNAME&lt;/code&gt;。 最后一个变量其实在一定情况下和 $0 是相同的。&lt;/p&gt;

&lt;p&gt;操作位置参数的方式可以通过内置命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;shift&lt;/code&gt; 。顾名思义就是切换位置参数，如果 shift 不带参数的话，则按位一个一个的切换，&lt;strong&gt;同时也可以指定参数，一次性切换多个&lt;/strong&gt;，下面通过一个例子说明一下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+defined&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;# do something &lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;shift
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遍历整个位置参数，同时还防止当 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1&lt;/code&gt; 为空的时候会提前停止的情况，defined 是我们根据实际情况预先定义的。&lt;/p&gt;

&lt;p&gt;我们还可以使用 for 循环来遍历位置参数，比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;arg&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
	 &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$arg&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个是使用的位置参数本身作为遍历对象，只会读取位置参数而不会修改，这个算是一个比较安全的操作。&lt;/p&gt;

&lt;p&gt;提到位置参数，有两个经常容易混淆的参数必须要对比到，根据不同的情况的需要，我们可以灵活的使用相应的参数及其形式。 下面通过一个表来展示下这两者的差别。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;输出结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$1 $2 $3 ... ${N}&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$1 $2 $3 ... ${N}&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$*&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$1c$2c$3c...c${N}&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$@&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; ... &quot;${N}&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;这边的 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 是表示的 IFS 的第一个参数。一般情况下还是建议使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$@&quot;&lt;/code&gt; 。 也许你会从中发现一个小的陷阱，即当我们在使用遍历位置参数的时候，如果使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$*&quot;&lt;/code&gt; 将位置参数传到函数中，循环只会执行一次。并不是我们所期望的多次执行。 此外位置参数不添加引号时会自动扩展引号，举个例子就明白了：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# script.sh&lt;/span&gt;
showcount&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;we get&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$# &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'parameter(s)'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

showcount &lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;
showcount &lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;
showcount &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
showcount &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./script.sh &lt;span class=&quot;s1&quot;&gt;'a b'&lt;/span&gt; c d
we get 4 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
we get 4 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
we get 3 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
we get 1 parameter&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出前两者将引号中的内容扩展了。同时这个也展示了使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$*&quot;&lt;/code&gt; 作为函数参数传入是，变量个数为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此外在数组那块还会提到和位置参数相关的内容，现在暂时不过多涉及。&lt;/p&gt;

&lt;h3 id=&quot;使用-set-设置-positional-parameter&quot;&gt;使用 set 设置 positional parameter&lt;/h3&gt;

&lt;p&gt;set 的一个作用就是用来设置位置参数，现在不讨论 set 在脚本调试和其他功效上的内容，只讨论在设置位置参数时的作用。首先先看一个简单的例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;a b c
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$3&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
a b c
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边的 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1,$2,$3&lt;/code&gt; 就是位置参数。 我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt; 来修改位置参数，比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;b c
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
b c
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;a &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$3&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
a b c
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们后面修改了该位置参数，在原有的基础上，增加了一个新的参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; ， 通过这个属性，我们可以做更多的事情，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; 一下所有的位置参数之类的。 我们再来看下一个例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; hello,   world  &quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;
hello, world
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;
hello, world
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子从侧面看可以去掉多个空格，实际上的原理很简单，利用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt; 的默认输出的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;$1 $2 $3 ...&lt;/code&gt;，  注意这里没有对变量添加引号，且我们可以看到位置参数并没有被分隔开。这一定程度上可以用做 &lt;code class=&quot;highlighter-rouge&quot;&gt;trim&lt;/code&gt; 函数。&lt;/p&gt;

&lt;h3 id=&quot;here-documents-和-here-strings&quot;&gt;Here documents 和 Here strings&lt;/h3&gt;

&lt;p&gt;这两者都是重定向的一种形式。&lt;strong&gt;Here documents&lt;/strong&gt; 的语法很简单，不过由于也有两种形式，所以在使用的过程中也有一定的差别。语法如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt; &amp;lt;&amp;lt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;-]word
...
...
word
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一般用 here documents 的比较多的是在 usage 函数中。在这中间的所有的内容都是直接输出的, 不会做任何的修改，不过注意一点的是，如果使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 那么会将输出的文本中的前导tab去除掉。下面的几个例子展示了 here documents 的实际使用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抑制变量的扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;'
&amp;gt; This is my name &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
&amp;gt; EOF
This is my name &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;       # 这个变量没有被转换成相应的内容
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在管道中使用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;' | sed 's/a/b/g'
&amp;gt; abc
&amp;gt; nab
&amp;gt; EOF
bbc
nbb
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Here strings&lt;/strong&gt; 的基本语法是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;。它的主要作用是可以替代管道进行输入，我们知道使用管道的时候实际是操作是在 subshell 中进行的，所以有些变量在退出了 subshell 的环境后就不存在了。比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello world&quot;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;first second
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$first&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$second&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# nothing will output&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;遇到这种情况，一种折中的办法就是在 subshell 中进行输出，使用 group command 进行。但是如果我们想在当前的环境中使用变量，这种方式就不适合了。因此现在使用 Here strings 就比较合适了。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;first second &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$first&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$second&lt;/span&gt;
Hello World
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;looks good！很完美的解决了这个问题。&lt;/p&gt;

&lt;h3 id=&quot;多使用-printf-而不是-echo&quot;&gt;多使用 printf 而不是 echo&lt;/h3&gt;

&lt;p&gt;shell 中的 printf 在一定程度上和 C 语言中的 printf 类似，语法上基本上差别不大。熟悉 C 的话，使用这些还是很简单的。echo 默认输出换行符，且在不同的系统上的表现也不同，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; 是没办法输出来的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;$ echo -n
$ echo '-n'  # cannot output
$ echo -e '\055n'
-n
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 printf 可以做一些比较 cool 的事儿。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# 格式化输出&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d | %0o | 0x%x'&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;126&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;126&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;126&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 绘制水平线&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%.0s-'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;1..20&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数学计算&quot;&gt;数学计算&lt;/h3&gt;

&lt;p&gt;目前推荐使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(( ))&lt;/code&gt; 进行数学计算，虽然使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;  也可以完成相应的工作但是使用前者是比较稳妥的，且不容易出错。&lt;/p&gt;

&lt;p&gt;首先在 bash 中，数字的表示形式有如下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0...&lt;/code&gt;  表示为八进制数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x...&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;0X...&lt;/code&gt;  表示为十六进制数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;BASE&amp;gt;#...&lt;/code&gt;  根据 base 来解析后面的数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其余的则会被当做十进制的数来使用。 对于第三种情形，需要着重说一下，这个语法的目的是为了将其他不同 base 的值转换成十进制的值。 比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;16#abc&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
2748
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2#010101&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
21
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10#abc&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
bash: 10#abc: value too great &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;base &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;error token is &lt;span class=&quot;s2&quot;&gt;&quot;10#abc&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以我们可以看到，即使数字没有使用相应的机制标识开头也同样可以转换成十进制。同样的如果想将十进制转换成其他的进制的，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; 格式化输出。&lt;/p&gt;

&lt;p&gt;下面来说一下计算部分，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(())&lt;/code&gt; 中支持大部分的数学计算语法。逻辑运算，位操作，以及常规的数据运算都是支持的。下面通过一些基本的例子展示下数学计算：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;, a+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
5
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;, a++&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们需要注意的是，返回值是最后一个表达式的结果。 除此之外，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(())&lt;/code&gt; 中也是支持变量操作的。比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16#abc, &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16#&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;:0:2&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%s, %s\n'&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt;
2748, 39
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边涉及到了子串扩展，这个在后面详细说明。 不过并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 将会被扩展为 $((1[0]))&lt;/span&gt;
bash: 1[0]: syntax error: invalid arithmetic operator &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;error token is &lt;span class=&quot;s2&quot;&gt;&quot;[0]&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[0]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}))&lt;/span&gt; 
1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%d\n'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 解析为 $((&quot;1&quot;)) &lt;/span&gt;
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的这一点我们就得注意下，有些变量并不一一定能在数学扩展中解析出来。此外，我们也可以用变量扩展作为布尔值的判断。比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;1 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 2&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;false&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# false&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;shell 中的数学计算基本上就是这些，还有其他的内容后续继续增加。&lt;/p&gt;

&lt;h3 id=&quot;正则表达式&quot;&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;我们在写脚本时，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sed&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;awk&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;perl&lt;/code&gt; 等工具自带的正则。但是如果不是很复杂的情况， 单独使用 bash 自带的正则就可以了。bash 本身支持的是 ERE 语法，同时也支持 group 匹配。RE 的语法在这里不多说了，正则表达式在有时候会比较清晰一些。比如下面的这个例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls 
&lt;/span&gt;1_abc.txt  245_def.txt 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将上述的文件名中的数字转换成16进制的。 这个问题解决的办法很多，我们尝试使用 RE 来解决这个问题。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;convert&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'^([0-9]+)_(.*)$'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~ &lt;span class=&quot;nv&quot;&gt;$rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
    	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%04x%s'&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;BASH_REMATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[1]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;BASH_REMATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[2]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;匹配到数字部分和字符串部分然后将其通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; 输出。匹配到的分组部分保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;BASH_REMATCH &lt;/code&gt;中， 不过通过 bash 的字符串子串操作也可以轻松完成。不过在获取子串这块语法会存在一些混淆，这个后面再说，现在看看使用子串如何解决这个问题。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# bad， not safe&lt;/span&gt;
convert&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%%_*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;other&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;##*_&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'%04x%s'&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$number&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$other&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上通过子串分割更加的快捷，不过需要保证每个文件都是统一的格式，不存在其他的格式。所以使用正则的好处是对于不符合条件的文件名不进行分割，在一定程度上更加的安全一些。&lt;/p&gt;

&lt;h3 id=&quot;字符串子串&quot;&gt;字符串子串&lt;/h3&gt;

&lt;p&gt;bash 中有不少的扩展，其中包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;paramater expand&lt;/code&gt; 。 先不讨论有关变量赋值的扩展，只讨论和子串有关的部分。首先和其他脚本语言中比较类似的切片语法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter:offset[:length]}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个扩展很好理解，返回值为 parameter 从 offset 处开始的 length 个字符。 这个 offset 可以为负数，其中 length 是可选。 parameter 可以为位置参数，在这种情况下索引是默认从 1 开始的。其他的情况下索引是从 0 开始的。一个简单的例子展示一下这个是如何扩展的。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;substring.sh
&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;This is a string&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;:2:2&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;:5&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./substring.sh 1 2 3 4 5
2 
3
is a string
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个扩展对数组也是可以使用的，不过如果使用在关系型数组上，其结果是未定义的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter#word}&lt;/li&gt;
  &lt;li&gt;${parameter##word}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除掉匹配的前缀，所谓的前缀就是 word 所表示的。word 部分可以使用通配符来表示，有关通配符的内容见后面。 这个匹配一般在获取后缀名或者是目录名比较有用。 比如下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ mypath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$mypath&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
/home/user/work/shell
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mypath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;#*/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
home/user/work/shell
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mypath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;##*/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
shell
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 表明匹配最短的前缀； 两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;##&lt;/code&gt; 表明匹配最长的前缀。 前缀部分的内容需根据实际情况来决定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter%word}&lt;/li&gt;
  &lt;li&gt;${parameter%%word}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;移除掉后缀，原理同上面的。word 部分支持通配符的表示。这个一般在获取文件名或者目录的 path 比较有用。所以我们可以这样使用：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ myfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;base.name.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;myfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%.*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
base.name
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;myfile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%%.*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
base
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是也能看到这个扩展的局限性，就是匹配的结果要么最少，要么最多，没有达到一个平衡，不过这些都需要我们自己去衡量与选择。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;${parameter/pattern/string}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模式替换，实际上就是将匹配到的内容用 string 替换掉。这个功能有一些使用的技巧，整理如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;场景&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pattern 以&lt;code class=&quot;highlighter-rouge&quot;&gt;/ &lt;/code&gt;开头&lt;/td&gt;
      &lt;td&gt;替换掉所有匹配的 pattern&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pattern 以&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 开头&lt;/td&gt;
      &lt;td&gt;必须是头部就匹配到 pattern&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pattern 以&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; 开头&lt;/td&gt;
      &lt;td&gt;必须是尾部开始匹配到 pattern&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string 为空&lt;/td&gt;
      &lt;td&gt;删除掉匹配到的 pattern&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;除此之外，如果参数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; 或者  &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 的话，则对每一个参数都使用这样的匹配。下面通过几个例子来简单说明下:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;This is a string&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/is/IS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# only first matched will be replaced&lt;/span&gt;
ThIS is a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;//is/IS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# each matched will be replaced&lt;/span&gt;
ThIS IS a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/#T/t&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# replace first character&lt;/span&gt;
this is a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/%sting/STRING&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# repalce end if the string&lt;/span&gt;
This is a STRING
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/is&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# delete first matched&lt;/span&gt;
Th is a string
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;//is&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# delete all matched&lt;/span&gt;
Th  a string
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要是需要记住一些符号的使用，其他的内容，现在不在这边过多的涉及，讨论过多后更加容易混淆，这边只介绍和子串相关的内容，至于大小写转换的功能，这些提及的比较少，所以也不整理了。&lt;/p&gt;

&lt;h3 id=&quot;通配符&quot;&gt;通配符&lt;/h3&gt;

&lt;p&gt;要完整的理清统配符的内容，得单独理出一篇。不过在这边主要是说明一些最基本的。至于通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;shopt&lt;/code&gt; 打开相关的扩展之类的，暂时不涉及。&lt;/p&gt;

&lt;p&gt;实际上通配符只是一个低配版的 RE，语法标记上简化了很多。注意  &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 在通配符中没有特殊含义，仍然代表的是原本的含义。 在 bash 中一般是如下的几个标记：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;  匹配一个或者多个字符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;  匹配一个字符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[...]&lt;/code&gt; 匹配这个集合中的任意一个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们使用的最多的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; ，这在遍历文件是最常用到：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;file &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
	......
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;除此之外，我们在 case 中经常会使用到这个，比如验证输入Yes/NO。 我们可以这样做：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Yy]|&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Nn]&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;nv&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unknown character&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上我们在使用  &lt;code class=&quot;highlighter-rouge&quot;&gt;[[&lt;/code&gt;时也可以使用通配符，比如下面这样的方式：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Ee]rror &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; 
	... 
&lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外还有一些范围相关的通配符，比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;[a-h]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[:alnum:]]&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;[[:digit:]_.]&lt;/code&gt; 等，这些用法是合法的。如果你熟悉 RE，这些应该不会太陌生。 至于取反操作有的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; , 表示非。 余下的扩展部分可以看之前整理的&lt;a href=&quot;http://jesseeisen.github.io/2016/08/16/shell-glob.html&quot;&gt;shell-glob&lt;/a&gt;， 这里面有对扩展部分的例子。&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/15/bash-shell/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/15/bash-shell/</guid>
        
        <category>bash</category>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>Bash 重定向</title>
        <description>&lt;p&gt;在日常的 bash 脚本或者命令行的使用中，我们经常会使用到重定向，我们会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt; 这样简单的基于标准文件描述符的重定向。如果使用到一些比较复杂的重定向时，重定向也会因为顺序的不同而产生不同的结果。所以有必要来理一理重定向的相关问题。&lt;/p&gt;

&lt;h3 id=&quot;the-basics&quot;&gt;The basics&lt;/h3&gt;

&lt;p&gt;在 linux 上，当我们打开一个 terminal 的时候，, 默认打开了三个文件描述符：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;standard input:  &lt;strong&gt;值为 0&lt;/strong&gt;  可用&lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;表示&lt;/li&gt;
  &lt;li&gt;standard output: &lt;strong&gt;值为 1&lt;/strong&gt;  可用&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;表示&lt;/li&gt;
  &lt;li&gt;standard error: &lt;strong&gt;值为 2&lt;/strong&gt;  可用&lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;表示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这三个标准的文件描述符，我们还可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; 来打开更多的文件描述符。&lt;/p&gt;

&lt;h3 id=&quot;1output-redirection&quot;&gt;1.Output Redirection&lt;/h3&gt;

&lt;p&gt;输出重定向，基本语法 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;gt; file&lt;/code&gt; (n 表示描述符的值）。一般使用它是 &lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;gt; file&lt;/code&gt;（同样可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;command 1&amp;gt;file&lt;/code&gt;）, 它主要是将原本输出到&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;上的内容重定向到了&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;，改变的是标准输出。&lt;/p&gt;

&lt;p&gt;如果想将标准错误的结果重定向，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;command 2&amp;gt;file&lt;/code&gt;。这就将原来输出到标准错误的内容，重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;中。同样&lt;code class=&quot;highlighter-rouge&quot;&gt;command 3&amp;gt;file&lt;/code&gt;这个命令是将&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;这个文件描述符重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;2input-redirection&quot;&gt;2.Input Redirection&lt;/h3&gt;

&lt;p&gt;输入重定向，基本语法&lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;lt; file&lt;/code&gt;(n 表示描述符的值）。一般用它来改变&lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;的值。可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;lt;file&lt;/code&gt;将 file 重定向到标准输入。同样&lt;code class=&quot;highlighter-rouge&quot;&gt;command 3&amp;lt;file&lt;/code&gt; 将 file 重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;上。&lt;/p&gt;

&lt;h3 id=&quot;3pipe&quot;&gt;3.Pipe&lt;/h3&gt;

&lt;p&gt;管道 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 主要是将连接了标准输出和标准输入， &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 左边是标准输出， 右边是标准输入。&lt;/p&gt;

&lt;h3 id=&quot;duplicating&quot;&gt;Duplicating&lt;/h3&gt;

&lt;p&gt;上面介绍的是我们比较常用的三个方式，接下来是&lt;strong&gt;复制文件描述符&lt;/strong&gt;。我们经常会看到这样的用法&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;。这个重定向的意思是：&lt;strong&gt;写到文件描述符 2 的内容将写到文件描述符 1 指向的地方&lt;/strong&gt;（不说 stdout/stderr 是因为这两个可以在此之前已经被重定向了）。&lt;/p&gt;

&lt;p&gt;这边所谓的复制可以这样理解。在&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;后，这两个描述符都指向了同一个地方。复制文件描述符可以抽象成&lt;code class=&quot;highlighter-rouge&quot;&gt;m&amp;gt;&amp;amp;n&lt;/code&gt;, 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;是两个描述符。&lt;/p&gt;

&lt;p&gt;通过一个例子理解下复制：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file
line 1
line 2
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;file
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; 3 line
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
line 1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;4&amp;gt;&amp;amp;3
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; 4 line
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
line 2
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到在执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;4&amp;gt;&amp;amp;3&lt;/code&gt;后，使用描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;同样能读到&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;指向的那个文件的下一行。这就表明将&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;复制给了&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;order-of-redirection&quot;&gt;Order Of Redirection&lt;/h3&gt;

&lt;p&gt;使用重定向的顺序也是需要注意的，比如一个很经典的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Q:what’s the difference between 2&amp;gt;&amp;amp;1 &amp;gt;foo and &amp;gt;foo 2&amp;gt;&amp;amp;1, and when do I use which?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;利用这个问题来说明一下不同的顺序使用重定向会带来什么影响。首先从：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1 &amp;gt;foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;将描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;复制给描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;, 这样&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;都指向了同一个地方。 接着将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;。 但是此时&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;还是指向是&lt;strong&gt;之前&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;指向的地方&lt;/strong&gt;。所以此时&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;不是指向的同一个地方，这相当是将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;备份了一下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;foo 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;foo&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;重定向到&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;, 接着&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;复制给&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;。此时&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;都被重定向到了&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;下面的一个例子便能很好的说明这两个的区别：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;f&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is stdout&quot;&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is stderr&quot;&lt;/span&gt; 1&amp;gt;&amp;amp;2
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

f &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;foo 2&amp;gt;&amp;amp;1   &lt;span class=&quot;c&quot;&gt;# nothing printed out&lt;/span&gt;
f 2&amp;gt;&amp;amp;1 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;foo   &lt;span class=&quot;c&quot;&gt;# print &quot;This is stderr&quot; only&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两种方式没有对错，在不同的需求下使用对应的顺序。&lt;/p&gt;

&lt;h3 id=&quot;some-pratical-usages&quot;&gt;Some Pratical Usages&lt;/h3&gt;

&lt;p&gt;在一些情况下，使用重定向会引发一些错误，我们可以使用一些方式去规避它。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sed 命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sed 's/a/A/g' file &amp;gt; file&lt;/code&gt;。这个用法估计很多人在不经意间都会用到，实际上这个用法是不会有作用的。我们之所以这么做是想将 sed 做出的修改写入到文件中。所以将标准输出重定向到该文件上。问题就在这儿！ 在 sed 命令执行之前，file 先被重定向，这时 file 就被截断，内容已被清空了，所以 sed 在读文件的时候，什么都读不到。 而正确的做法是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 选项。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注： 千万不要在 sed 中将重定向的文件指定成即将用于输入的那个文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;read 命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 bash 中，我们习惯性使用如下方式来读取文件的内容：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
  &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &amp;lt; file

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个用法是没有问题的，也可以很好的执行。不过如果我们在 while 循环体内使用再次使用 read 呢？比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
   &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
   &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Continue to read?&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 1
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &amp;lt; file
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个情况下就会出错了。出错在于，此时循环体内的标准输入已经被重定向到了&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;是要从标准输入中读取，而这时只能从 file 中读取了。这和我们所期望的就有所不同了，
此时可以使用如下方式：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;file
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; 3 line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do
	&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Continue to read?&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 1
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将文件在描述符&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;上打开，通过 read 指定读取时的描述符，这样就避免了标准输入被重定向的问题。&lt;/p&gt;

&lt;h3 id=&quot;create-more-file-descriptor&quot;&gt;Create More File Descriptor&lt;/h3&gt;

&lt;p&gt;上面简单的提了一下使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;创建描述符，现在介绍一下如何创建合适类型的文件描述符。我们直接从例子来说明创建的过程：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# we have a file named foo&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;foo
hello world
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;foo    &lt;span class=&quot;c&quot;&gt;# create a fd only can used to read.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 5  word &amp;lt;&amp;amp;3 &lt;span class=&quot;c&quot;&gt;# read 5 character from foo&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$word&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
hello
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;good&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;3
&lt;span class=&quot;nt&quot;&gt;-bash&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;: write error: Bad file descriptor
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到，再往&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;里面写入的时候报错了，说明此时&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;只是一个只读的文件描述符。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;这个描述符的时候，我们需要利用复制的方式，不然 bash 会将&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;理解成普通的文件。如果当前目录下没有&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;这个文件，
bash 便会报错：No such file or directory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此我们需要用到如下的方式：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;3&amp;lt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;foo  &lt;span class=&quot;c&quot;&gt;# create a read and write fd&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 5 word &amp;lt;&amp;amp;3 &lt;span class=&quot;c&quot;&gt;#read seek the file to position 5&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; / &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;3
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;foo
hello/world
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这会儿的&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;便可读可写。同样的，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exec 3&amp;gt;foo&lt;/code&gt; 创建一个可写的文件描述符。（这个可以结合 Linux 系统编程上的 open 函数理解）&lt;/p&gt;

&lt;h3 id=&quot;close-file-descriptor&quot;&gt;Close File Descriptor&lt;/h3&gt;

&lt;p&gt;如果这个描述符不需要再使用了，可以关闭这个描述符。bash 提供了如下的关闭方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;lt;&amp;amp;-&lt;/code&gt;  关闭一个用于输入的描述符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&amp;lt;&amp;amp;-, &amp;lt;&amp;amp;-&lt;/code&gt;  关闭标准输入&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;n&amp;gt;&amp;amp;-&lt;/code&gt;  关闭一个用于输出的描述符&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;&amp;amp;-, &amp;gt;&amp;amp;-&lt;/code&gt;  关闭标准输出&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;some-abbreviations&quot;&gt;Some Abbreviations&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&amp;amp;&lt;/code&gt;  abbr  &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1 |&lt;/code&gt;  added in bash4&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;gt;/dev/null&lt;/code&gt; abbr &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些缩写可以了解一下，目的是为了能够在别人有使用的时候可以能读懂。&lt;/p&gt;

&lt;h3 id=&quot;small-example&quot;&gt;Small Example&lt;/h3&gt;

&lt;p&gt;当我们想在脚本中，希望 log 能够一边输出到终端上，一边又能写入文件中。这时候也可以使用到重定向，在 linux 中有一个命令&lt;code class=&quot;highlighter-rouge&quot;&gt;tee&lt;/code&gt;是可以将内容输出到标准输出和文件的。我们可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;来实现，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;pass&quot; | tee log&lt;/code&gt;。不过如果有很多的 log，每条都用&lt;code class=&quot;highlighter-rouge&quot;&gt;|tee log&lt;/code&gt; 会比较繁琐。所以可以结合&lt;code class=&quot;highlighter-rouge&quot;&gt;process substitute&lt;/code&gt; 和重定向来简化这个过程。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tee &lt;/span&gt;log&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pass&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样只要往标准输出的内容，都会被丢给&lt;code class=&quot;highlighter-rouge&quot;&gt;tee&lt;/code&gt;. 不过这还不能很完美的工作。原因在于&lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt;是带有缓冲的，所以如果 log 只是有关标准输出的，那么这么使用是没有问题的。不过我们一般也会将标准错误的内容也保存到 log 中的话，可能会出现打印出来的顺序和实际代码中 log 输出的顺序不一致。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;1&amp;gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tee &lt;/span&gt;log&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;2&amp;gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tee &lt;/span&gt;log&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 1 pass&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 2 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 3 pass&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;case 4 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2

&lt;span class=&quot;c&quot;&gt;#will output&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 1 pass
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 3 pass
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 2 error
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; 4 error
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是对 log 顺序有要求的话，这样的输出明显是不符合条件的。 好在 linux 中提供了两个命令&lt;code class=&quot;highlighter-rouge&quot;&gt;stdbuf&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;unbuffer&lt;/code&gt;。这两个命令的原理是不同的，具体的可自行 goole。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;echo_unbuf&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;stdbuf&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O0&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;#unbuffer echo &quot;$@&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 1 pass&quot;&lt;/span&gt;
echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 2 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2
echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 3 pass&quot;&lt;/span&gt;
echo_unbuf &lt;span class=&quot;s2&quot;&gt;&quot;case 4 error&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&amp;amp;2

&lt;span class=&quot;c&quot;&gt;#will output like output&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过封装一个&lt;code class=&quot;highlighter-rouge&quot;&gt;echo_unbuf&lt;/code&gt;，这样便能保证了 log 输出的顺序是正确的。最后如果出现了后台命令在程序结束后打印，则可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;来同步一下。&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/70963/difference-between-2-2-dev-null-dev-null-and-dev-null-21/70971#70971&quot;&gt;Difference between some redirections&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tldp.org/LDP/abs/html/io-redirection.html&quot;&gt;IO Redirection&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/08/01/redirection/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/08/01/redirection/</guid>
        
        <category>bash</category>
        
        <category>基础</category>
        
        
      </item>
    
  </channel>
</rss>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
      21B04 | Chan
    </title>
    <meta name="description" content="A PKM Site">
    <link rel="stylesheet" href="/assets/style.24207c44.css">
    <link rel="modulepreload" href="/assets/framework.ab59a038.js">
    <link rel="modulepreload" href="/assets/daily_21B04.md.061190bb.lean.js">
    <link rel="modulepreload" href="/assets/app.f759e2ae.js">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
    
  </head>
  <body>
    <div id="app"><div><main class="max-w-4xl mx-auto px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="pt-6 pb-8 space-y-2 md:space-y-5"><h3 class="text-xl leading-9 font-extrabold text-gray-900 tracking-tight sm:leading-10 md:leading-14"><a aria-label="Chan" href="/">Chan</a></h3></div><!--[--><article class="xl:divide-y xl:divide-gray-200" data-v-c3fd59da><header class="pt-6 xl:pb-10 space-y-1 text-center" data-v-c3fd59da><h3 class="text-xl leading-9 font-bold text-gray-900 tracking-tigh" data-v-c3fd59da>21B04 - Script Skill Notes</h3></header><div class="prose max-w-none pt-10 pb-8" data-v-c3fd59da><p><div class="table-of-contents"><ul><li><a href="#目录和文件">目录和文件</a></li><li><a href="#重定向">重定向</a></li><li><a href="#here-document-和-here-strings">Here document 和 Here strings</a></li><li><a href="#数学计算">数学计算</a></li><li><a href="#echo-输出">echo 输出</a></li><li><a href="#trap">trap</a></li><li><a href="#split">split</a></li><li><a href="#tee-redirection">tee redirection</a></li></ul></div></p><hr><p><i class="releated">incoming(1):</i> {<a href="/posts/19X14.html">redirection</a>}</p><p>bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。</p><h2 id="目录和文件"><a class="header-anchor" href="#目录和文件" aria-hidden="true">#</a> 目录和文件</h2><p>遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个 <code>for</code> 循环，但是实际上我们可以有几种不同的方式来完成这些任务。</p><p><strong>find</strong></p><div class="language-"><pre><code>find .   // 查找当前目录下所有的文件
find . -name &quot;*.txt&quot; -type f   //find all txt file
find . -type f -name &quot;*.txt&quot; -print0 | xargs -0 fgrep text
</code></pre></div><p><strong>for</strong></p><p>正常的思路是使用 <code>for</code> 循环去遍历，使用 <code>for</code> 循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在 <code>bash4</code> 的版本下，可以开启 <code>globstar</code> 或者 <code>dotglob</code> 这两个选项，区别在于是否要匹配隐藏的文件。</p><div class="language-"><pre><code>shopt -s globstar || exit

for f in **
do
	if [ &quot;$f&quot; =~ \.txt$ ]; then
		echo &quot;$f&quot;
	fi
done
</code></pre></div><p>这里面用到了两个技巧，一个是如果不支持 <code>globstar</code> 就退出脚本执行，另一个是 <code>if</code> 的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。</p><div class="language-"><pre><code>function walk_tree()
{
	for f in &quot;$1&quot;; do
		if [ -d &quot;$f&quot;]; then
			walk_tree &quot;$f&quot;
		else
			fullpath=`readlink -f &quot;$f&quot;`
			if [ &quot;$fullpath&quot; =~ \.txt$ ]; then
				echo &quot;$fullpath&quot;
			fi
	done
}
</code></pre></div><p>有两个可以注意的点是： <code>readlink -f</code> 可以输出文件的完整路径。同时 <code>$f</code> 本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题 <code>find</code> 是首选的。其次不需要使用递归也是一个非常棒的方式。 <code>find</code> 配合上 <code>exec</code> 和 <code>xargs</code> 同样可以执行一些简单的命令。</p><hr><h2 id="重定向"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a> 重定向</h2><p>重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是 <code>&gt;</code> ,<code>&gt;&gt;</code> 这两个。下面是简单的一些记录很处理。</p><p><strong>描述符复制</strong></p><blockquote><p><code>n&gt;&amp;m</code> 将描述符 n 指向 m 所指向的位置。</p></blockquote><p>我们一般使用 <code>exec</code> 来执行描述符之间的复制。</p><div class="language-shell"><pre><code>$ <span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
$ <span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span><span class="token file-descriptor important">&amp;3</span>
$ <span class="token builtin class-name">read</span> -u <span class="token number">4</span> line
$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$line</span>&quot;</span>
</code></pre></div><p>上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。</p><p><strong>重定向顺序</strong></p><blockquote><p><code>2&gt;&amp;1 &gt;foo</code> <strong>描述符 2 和 描述符 1 指向不同的位置。</strong></p><p><code>&gt;foo 2&gt;&amp;1</code> <strong>描述符 2 和 描述符 1 指向相同的位置。</strong></p></blockquote><p><strong>关闭描述符</strong></p><ul><li>n&lt;&amp;- 关闭一个输入的文件描述符</li><li>n&gt;&amp;- 关闭一个输出的文件描述符</li></ul><p><strong>read 命令中使用重定向</strong></p><p>常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下：</p><div class="language-shell"><pre><code><span class="token keyword">while</span> <span class="token builtin class-name">read</span> -r line<span class="token punctuation">;</span> <span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$line</span>&quot;</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
</code></pre></div><p>然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。</p><div class="language-shell"><pre><code><span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
<span class="token keyword">while</span> <span class="token builtin class-name">read</span> -u <span class="token number">3</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$line</span>&quot;</span>
	<span class="token builtin class-name">read</span> -p <span class="token string">&quot;continue to read?&quot;</span> -n <span class="token number">1</span>
<span class="token keyword">done</span>
</code></pre></div><p>这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。</p><hr><h2 id="here-document-和-here-strings"><a class="header-anchor" href="#here-document-和-here-strings" aria-hidden="true">#</a> Here document 和 Here strings</h2><p>实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。</p><p><strong>Here document</strong></p><div class="language-shell"><pre><code><span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span><span class="token punctuation">[</span>-<span class="token punctuation">]</span>word
<span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.
word
</code></pre></div><p>here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的 <code>-</code> 。使用 <code>&lt;&lt;-</code> 会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。</p><p>另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如 <code>&#39;EOF&#39;</code> 这个会抑制后面中的变量的展开。简单的示例如下：</p><div class="language-shell"><pre><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&#39;EOF&#39;</span>
<span class="token operator">&gt;</span> This is my name <span class="token variable">$name</span>
<span class="token operator">&gt;</span> EOF
This is my name <span class="token variable">$name</span>
</code></pre></div><p>同时 Here document 也是可以在管道中使用的，简单的示例如下：</p><div class="language-shell"><pre><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&#39;EOF&#39;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">&#39;s/a/b/g&#39;</span>
<span class="token operator">&gt;</span> abc
<span class="token operator">&gt;</span> nab
<span class="token operator">&gt;</span> EOF
bbc
nbb
</code></pre></div><p>还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用：</p><div class="language-shell"><pre><code><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> filename</span>
aaaa
bbb
ccc
EOF</span>
</code></pre></div><p><strong>Here strings</strong></p><p>大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。</p><div class="language-shell"><pre><code>$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;Hello World&quot;</span> <span class="token operator">|</span> <span class="token builtin class-name">read</span> first second
$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$first</span>&quot;</span> <span class="token string">&quot;<span class="token variable">$second</span>&quot;</span>
<span class="token comment"># nothing</span>
</code></pre></div><p>此时使用 here strings 则就很合适了。</p><div class="language-shell"><pre><code>$ <span class="token builtin class-name">read</span> first second <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">&quot;hello world&quot;</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$first</span>&quot;</span> <span class="token string">&quot;<span class="token variable">$second</span>&quot;</span>
hello world
</code></pre></div><hr><h2 id="数学计算"><a class="header-anchor" href="#数学计算" aria-hidden="true">#</a> 数学计算</h2><p>数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是 <code>(( ))</code> ， 有时我们还会使用 <code>$(( ))</code> 这个是 POSIX 的一个形式。</p><p>bash 中有一个语法，用来转换进制的。即：<code>&lt;base&gt;#number</code> 我们可以直接在 <code>$(( ))</code> 中使用。其次在数学计算符中可以不用使用 <code>$</code> 符来引用变量。</p><div class="language-shell"><pre><code>$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token number">3</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">&#39;%d<span class="token entity" title="\n">\n</span>&#39;</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">4</span>
</code></pre></div><p>在 <code>$(( )) </code> 中也是支持变量操作的。比如：</p><div class="language-bash"><pre><code>$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">16</span>#abc<span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">16</span>#${a<span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">2</span>}<span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token builtin class-name">printf</span> <span class="token string">&#39;%s, %s<span class="token entity" title="\n">\n</span>&#39;</span> <span class="token variable">$a</span> <span class="token variable">$b</span>
<span class="token number">2748</span>, <span class="token number">39</span>
</code></pre></div><p>注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：</p><div class="language-bash"><pre><code>$ <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>$x[<span class="token number">0</span>]<span class="token variable">))</span></span> <span class="token comment"># 将会被扩展为 $((1[0]))</span>
bash: <span class="token number">1</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>: syntax error: invalid arithmetic operator <span class="token punctuation">(</span>error token is <span class="token string">&quot;[0]&quot;</span><span class="token punctuation">)</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">&#39;%d<span class="token entity" title="\n">\n</span>&#39;</span> <span class="token variable"><span class="token variable">$((</span>${x[<span class="token number">0</span>]}<span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">&#39;%d<span class="token entity" title="\n">\n</span>&#39;</span> <span class="token variable"><span class="token variable">$((</span>&quot;$x&quot; <span class="token operator">==</span> <span class="token number">1</span><span class="token variable">))</span></span>  <span class="token comment"># 解析为 $((&quot;1&quot;))</span>
<span class="token number">1</span>
</code></pre></div><p>此外，我们也可以用变量扩展作为布尔值的判断。比如：</p><div class="language-bash"><pre><code><span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;true&quot;</span>
<span class="token keyword">else</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;false&quot;</span>
<span class="token keyword">fi</span>
<span class="token comment"># false</span>
</code></pre></div><hr><h2 id="echo-输出"><a class="header-anchor" href="#echo-输出" aria-hidden="true">#</a> echo 输出</h2><p>echo 在使用 <code>-e</code> 的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过 <code>$&#39;string&#39;</code> 的方式来进行。比如：</p><div class="language-"><pre><code>$ echo &quot;This is a line&quot;$&#39;\n&#39;
This is a line

$
</code></pre></div><hr><h2 id="trap"><a class="header-anchor" href="#trap" aria-hidden="true">#</a> trap</h2><p>trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子：</p><div class="language-"><pre><code>trap &#39;[ $? -eq 0 ] || dosomething&#39; EXIT
</code></pre></div><hr><h2 id="split"><a class="header-anchor" href="#split" aria-hidden="true">#</a> split</h2><p>split 在 shell 中并不是原生支持，需要自己实现一个函数，一般使用 read 来实现。</p><div class="language-"><pre><code>split() {
   # Usage: split &quot;string&quot; &quot;delimiter&quot;
   IFS=$&#39;\n&#39; read -d &quot;&quot; -ra arr &lt;&lt;&lt; &quot;${1//$2/$&#39;\n&#39;}&quot;
   printf &#39;%s\n&#39; &quot;${arr[@]}&quot;
}
</code></pre></div><p>这种方式在正常场景下并不会有问题，但是当我们设置了 <code>set -e</code> 后，上述实现就会提前退出。简单解释一下：</p><div class="language-"><pre><code>$ read -d &#39;&#39; &lt;&lt;&lt; &#39;Hello World&#39;
$ echo $?
1
</code></pre></div><p>这个方式在 while 循环中是非常友好的方式，但是由于设置 <code>set -e</code>, 存在返回值不为0 的时候，程序会自动退出。这也就意味着 read 之后就直接 exit 了，所以我们需要简单的规避一下:</p><div class="language-"><pre><code>split() {
   # Usage: split &quot;string&quot; &quot;delimiter&quot;
   IFS=$&#39;\n&#39; read -d &quot;&quot; -ra arr &lt;&lt;&lt; &quot;${1//$2/$&#39;\n&#39;}&quot; || true
   printf &#39;%s\n&#39; &quot;${arr[@]}&quot;
}
</code></pre></div><p>通过 <code>||</code> 将返回值重新变成 0 且逻辑上也是符合需求的。</p><h2 id="tee-redirection"><a class="header-anchor" href="#tee-redirection" aria-hidden="true">#</a> tee redirection</h2><p>在 shell 中实现 tee 对 stdout 和 stderr 的重定向，可以使用如下的方式：</p><div class="language-"><pre><code>command &gt; &gt;(tee -a stdout.log) 2&gt; &gt;(tee -a stderr.log &gt;&amp;2)
</code></pre></div><p>其中, <code>&gt;(...) (process substitution)</code> 创建一个 FIFO，同时将 command 的输出重定向到这个 FIFO 中。</p></div></article><footer class="text-right my-12" data-v-c3fd59da><p class="author-show" data-v-c3fd59da>L.K</p></footer><!--]--></main></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"4ba7c645\",\"daily_20d10.md\":\"ca3edd83\",\"daily_20q01.md\":\"6dfd4483\",\"daily_20x11.md\":\"16c672b8\",\"daily_21b04.md\":\"061190bb\",\"daily_21b05.md\":\"e11b2b95\",\"daily_21b06.md\":\"9363a8c2\",\"daily_21b07.md\":\"39afec0a\",\"daily_21b11.md\":\"5b41b59e\",\"daily_21b12.md\":\"4c306d93\",\"daily_21c04.md\":\"a882783a\",\"daily_21d09.md\":\"7541a9c0\",\"daily_21d13.md\":\"cffd3403\",\"daily_21d14.md\":\"de8825ae\",\"daily_21eo8.md\":\"2c2dc784\",\"daily_21f03.md\":\"af88893b\",\"daily_21f06.md\":\"3b89681a\",\"daily_21f08.md\":\"1eed810e\",\"daily_21f11.md\":\"84e47fdf\",\"daily_21f13.md\":\"ff550821\",\"posts_19x14.md\":\"74b0704d\",\"posts_20e01.md\":\"610cf89c\",\"posts_draw.md\":\"40330124\",\"posts_first_post.md\":\"1eb64573\",\"posts_openssl.md\":\"93f5bec6\",\"posts_tpp.md\":\"b532556d\"}")</script>
    <script type="module" async src="/assets/app.f759e2ae.js"></script>
  </body>
</html>
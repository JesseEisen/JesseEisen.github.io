<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="no-referrer"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/pwa-192x192.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#00aba9"><meta name="msapplication-TileColor" content="#00aba9"><meta name="theme-color" content="#ffffff"><script type="module" async="" crossorigin="" src="/assets/app.9a86a0a7.js"></script><link rel="modulepreload" href="/assets/vendor.57ddf3fb.js"><link rel="stylesheet" href="/assets/app.bb10de41.css"><link rel="manifest" href="/manifest.webmanifest"><link rel="modulepreload" crossorigin="" href="/assets/shell_script.3094eff7.js"><link rel="modulepreload" crossorigin="" href="/assets/ShortHR.6b6325a8.js"><link rel="stylesheet" href="/assets/ShortHR.0b651cd3.css"><link rel="modulepreload" crossorigin="" href="/assets/LinkItem.e13c2971.js"><link rel="stylesheet" href="/assets/LinkItem.bf447482.css"><meta property="og:title" content="Bash Script Skill Notes"><meta property="og:description" content="collections of bash script skill"><meta name="description" content="collections of bash script skill"><meta name="head:count" content="3"><title>Chan93</title></head><body><div id="app" data-server-rendered="true"><div h="full" flex="~ col" p="x-4"><nav z="100" text="dark-100 dark:light-900" position="fixed top-0 left-0 right-0" bg="dark:dark-500 dark:opacity-50 white opacity-75" backdrop="~ blur-lg" h="18" p="x-4" border="b-1 dark:dark-500"><div max-w="screen-lg" m="x-auto" h="full" flex="~ row" items="center" space="x-4"><a href="/" class="" flex="1"><h1 text="2xl" font="bold">🐣 WhatIf</h1></a><a href="/blogs" class=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M88 96a8 8 0 0 1 8-8h64a8 8 0 0 1 0 16H96a8 8 0 0 1-8-8zm8 40h64a8 8 0 0 0 0-16H96a8 8 0 0 0 0 16zm32 16H96a8 8 0 0 0 0 16h32a8 8 0 0 0 0-16zm96-104v108.687A15.894 15.894 0 0 1 219.313 168L168 219.313A15.894 15.894 0 0 1 156.687 224H48a16.018 16.018 0 0 1-16-16V48a16.018 16.018 0 0 1 16-16h160a16.018 16.018 0 0 1 16 16zM48 208h104v-48.008a8 8 0 0 1 8-8h48V48H48zm120-40.008v28.695l28.694-28.695z" fill="currentColor"></path></svg></a><a href="/notes" class=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M13 21v2.5l-3-2l-3 2V21h-.5A3.5 3.5 0 0 1 3 17.5V5a3 3 0 0 1 3-3h14a1 1 0 0 1 1 1v17a1 1 0 0 1-1 1h-7zm0-2h6v-3H6.5a1.5 1.5 0 0 0 0 3H7v-2h6v2zm6-5V4H6v10.035A3.53 3.53 0 0 1 6.5 14H19zM7 5h2v2H7V5zm0 3h2v2H7V8zm0 3h2v2H7v-2z" fill="currentColor"></path></svg></a><a href="/books" class=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M9 3v15h3V3H9m3 2l4 13l3-1l-4-13l-3 1M5 5v13h3V5H5M3 19v2h18v-2H3z" fill="currentColor"></path></svg></a><a href="https://github.com/jesseeisen" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33c.85 0 1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2z" fill="currentColor"></path></svg></a><a cursor="pointer"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg></a></div></nav><main flex="~ 1 row" justify="center" w="full" max-w="screen-lg" m="x-auto" p="t-18" text="dark:light-300 dark-100"><div data-v-2af502ac=""><div data-v-2af502ac=""><a flex="~ row" items="center" class="dark:text-white-900 dark:opacity-60" space="x-2" m="t-4" cursor="pointer" data-v-2af502ac=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 32 32" text="12px" data-v-2af502ac=""><path d="M14 26l1.41-1.41L7.83 17H28v-2H7.83l7.58-7.59L14 6L4 16l10 10z" fill="currentColor"></path></svg><span text="12px dark:light-50 true-gray-500" font="bold" data-v-2af502ac="">Back to prev</span></a></div><header text="center" border="b-1 dark:dark-200" p="y-10" data-v-2af502ac=""><h1 text="36px dark:light-50 dark " font=" extrabold -.015em 48px" class="post-title" data-v-2af502ac="">Bash Script Skill Notes</h1><div my="20px" data-v-2af502ac=""><span text="sm dark:light-900 dark:opacity-60 #666" m="b-2" display="block" data-v-2af502ac="">Jan 18, 2021</span></div><div text="left" flex="~" m="t-4" data-v-2af502ac=""><div flex="~ row" items="center" space="x-2" class="mx-auto" data-v-2af502ac="" data-v-22abfd34=""><img border="rounded-full" src="https://secure.gravatar.com/avatar/190aa3adff4e1451b32c354f0b5fd7f9?size=30" data-v-22abfd34=""><div flex="~ col" class="author-info" data-v-22abfd34=""><span text="500 dark:light-900 dark:opacity-80 dark-900" data-v-22abfd34="">Linkang Chan</span><br data-v-22abfd34=""><a href="https://twitter.com/JessEisen_LJ" class="text-pink-500 text-sm" target="_blank" data-v-22abfd34="">@Jesse Chan</a></div></div></div></header><div flex="~" w="100%" justify="center" data-v-2af502ac=""><article m="t-8" data-v-2af502ac=""><div w="90%" class="prose prose-lg" text="dark:light-900 dark:opacity-72" data-v-2af502ac=""><!--[--><div><div><span><i>incoming (1):</i></span><!--[--><span><a href="/notes/command">command</a></span><!--]--></div><p>bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。</p><h2 id="目录和文件"><a class="header-anchor" href="#目录和文件" aria-hidden="true">#</a>目录和文件</h2><p>遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个<code>for</code>循环，但是实际上我们可以有几种不同的方式来完成这些任务。</p><p><strong>find</strong></p><pre class="language-bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span>   // 查找当前目录下所有的文件
<span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">"*.txt"</span> -type f   //find all txt <span class="token function">file</span>
<span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -name <span class="token string">"*.txt"</span> -print0 <span class="token operator">|</span> <span class="token function">xargs</span> -0 <span class="token function">fgrep</span> text
</code></pre><p><strong>for</strong></p><p>正常的思路是使用<code>for</code>循环去遍历，使用<code>for</code>循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在<code>bash4</code>的版本下，可以开启<code>globstar</code>或者<code>dotglob</code>这两个选项，区别在于是否要匹配隐藏的文件。</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">shopt</span> -s globstar <span class="token operator">||</span> <span class="token builtin class-name">exit</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">f</span> <span class="token keyword">in</span> **
<span class="token keyword">do</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$f</span>"</span> <span class="token operator">=</span>~ <span class="token punctuation">\</span>.txt$ <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
		<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$f</span>"</span>
	<span class="token keyword">fi</span>
<span class="token keyword">done</span>
</code></pre><p>这里面用到了两个技巧，一个是如果不支持<code>globstar</code>就退出脚本执行，另一个是<code>if</code>的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。</p><pre class="language-bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">walk_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token for-or-select variable">f</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
		<span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">"<span class="token variable">$f</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
			walk_tree <span class="token string">"<span class="token variable">$f</span>"</span>
		<span class="token keyword">else</span>
			<span class="token assign-left variable">fullpath</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>readlink -f <span class="token string">"<span class="token variable">$f</span>"</span><span class="token variable">`</span></span>
			<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$fullpath</span>"</span> <span class="token operator">=</span>~ <span class="token punctuation">\</span>.txt$ <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
				<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$fullpath</span>"</span>
			<span class="token keyword">fi</span>
	<span class="token keyword">done</span>
<span class="token punctuation">}</span>
</code></pre><p>有两个可以注意的点是：<code>readlink -f</code>可以输出文件的完整路径。同时<code>$f</code>本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题<code>find</code>是首选的。其次不需要使用递归也是一个非常棒的方式。<code>find</code>配合上<code>exec</code>和<code>xargs</code>同样可以执行一些简单的命令。</p><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="重定向"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a>重定向</h2><p>重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是<code>&gt;</code>,<code>&gt;&gt;</code>这两个。下面是简单的一些记录很处理。</p><p><strong>描述符复制</strong></p><blockquote><p><code>n&gt;&amp;m</code>将描述符 n 指向 m 所指向的位置。</p></blockquote><p>我们一般使用<code>exec</code>来执行描述符之间的复制。</p><pre class="language-shell"><code class="language-shell">$ <span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
$ <span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span><span class="token file-descriptor important">&amp;3</span>
$ <span class="token builtin class-name">read</span> -u <span class="token number">4</span> line
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$line</span>"</span>
</code></pre><p>上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。</p><p><strong>重定向顺序</strong></p><blockquote><p><code>2&gt;&amp;1 &gt;foo</code><strong>描述符 2 和 描述符 1 指向不同的位置。</strong></p><p><code>&gt;foo 2&gt;&amp;1</code><strong>描述符 2 和 描述符 1 指向相同的位置。</strong></p></blockquote><p><strong>关闭描述符</strong></p><ul><li>n&lt;&amp;- 关闭一个输入的文件描述符</li><li>n&gt;&amp;- 关闭一个输出的文件描述符</li></ul><p><strong>read 命令中使用重定向</strong></p><p>常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下：</p><pre class="language-shell"><code class="language-shell"><span class="token keyword">while</span> <span class="token builtin class-name">read</span> -r line<span class="token punctuation">;</span> <span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$line</span>"</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
</code></pre><p>然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。</p><pre class="language-shell"><code class="language-shell"><span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
<span class="token keyword">while</span> <span class="token builtin class-name">read</span> -u <span class="token number">3</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$line</span>"</span>
	<span class="token builtin class-name">read</span> -p <span class="token string">"continue to read?"</span> -n <span class="token number">1</span>
<span class="token keyword">done</span>
</code></pre><p>这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。</p><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="here-document-和-here-strings"><a class="header-anchor" href="#here-document-和-here-strings" aria-hidden="true">#</a>Here document 和 Here strings</h2><p>实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。</p><p><strong>Here document</strong></p><pre class="language-shell"><code class="language-shell"><span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span><span class="token punctuation">[</span>-<span class="token punctuation">]</span>word
<span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.
word
</code></pre><p>here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的<code>-</code>。使用<code>&lt;&lt;-</code>会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。</p><p>另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如<code>'EOF'</code>这个会抑制后面中的变量的展开。简单的示例如下：</p><pre class="language-shell"><code class="language-shell">$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'EOF'</span>
<span class="token operator">&gt;</span> This is my name <span class="token variable">$name</span>
<span class="token operator">&gt;</span> EOF
This is my name <span class="token variable">$name</span>
</code></pre><p>同时 Here document 也是可以在管道中使用的，简单的示例如下：</p><pre class="language-shell"><code class="language-shell">$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'EOF'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/a/b/g'</span>
<span class="token operator">&gt;</span> abc
<span class="token operator">&gt;</span> nab
<span class="token operator">&gt;</span> EOF
bbc
nbb
</code></pre><p>还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用：</p><pre class="language-shell"><code class="language-shell"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> filename</span>
aaaa
bbb
ccc
EOF</span>
</code></pre><p><strong>Here strings</strong></p><p>大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。</p><pre class="language-shell"><code class="language-shell">$ <span class="token builtin class-name">echo</span> <span class="token string">"Hello World"</span> <span class="token operator">|</span> <span class="token builtin class-name">read</span> first second
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$first</span>"</span> <span class="token string">"<span class="token variable">$second</span>"</span>
<span class="token comment"># nothing</span>
</code></pre><p>此时使用 here strings 则就很合适了。</p><pre class="language-shell"><code class="language-shell">$ <span class="token builtin class-name">read</span> first second <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"hello world"</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$first</span>"</span> <span class="token string">"<span class="token variable">$second</span>"</span>
hello world
</code></pre><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="数学计算"><a class="header-anchor" href="#数学计算" aria-hidden="true">#</a>数学计算</h2><p>数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是<code>(( ))</code>， 有时我们还会使用<code>$(( ))</code>这个是 POSIX 的一个形式。</p><p>bash 中有一个语法，用来转换进制的。即：<code>&lt;base&gt;#number</code>我们可以直接在<code>$(( ))</code>中使用。其次在数学计算符中可以不用使用<code>$</code>符来引用变量。</p><pre class="language-shell"><code class="language-shell">$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token number">3</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">'%d<span class="token entity" title="\n">\n</span>'</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">4</span>
</code></pre><p>在<code>$(( ))</code>中也是支持变量操作的。比如：</p><pre class="language-bash"><code class="language-bash">$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">16</span>#abc<span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">16</span>#${a<span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">2</span>}<span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token builtin class-name">printf</span> <span class="token string">'%s, %s<span class="token entity" title="\n">\n</span>'</span> <span class="token variable">$a</span> <span class="token variable">$b</span>
<span class="token number">2748</span>, <span class="token number">39</span>
</code></pre><p>注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：</p><pre class="language-bash"><code class="language-bash">$ <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>$x[<span class="token number">0</span>]<span class="token variable">))</span></span> <span class="token comment"># 将会被扩展为 $((1[0]))</span>
bash: <span class="token number">1</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>: syntax error: invalid arithmetic operator <span class="token punctuation">(</span>error token is <span class="token string">"[0]"</span><span class="token punctuation">)</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">'%d<span class="token entity" title="\n">\n</span>'</span> <span class="token variable"><span class="token variable">$((</span>${x[<span class="token number">0</span>]}<span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">'%d<span class="token entity" title="\n">\n</span>'</span> <span class="token variable"><span class="token variable">$((</span>"$x" <span class="token operator">==</span> <span class="token number">1</span><span class="token variable">))</span></span>  <span class="token comment"># 解析为 $(("1"))</span>
<span class="token number">1</span>
</code></pre><p>此外，我们也可以用变量扩展作为布尔值的判断。比如：</p><pre class="language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"true"</span>
<span class="token keyword">else</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"false"</span>
<span class="token keyword">fi</span>
<span class="token comment"># false</span>
</code></pre><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="echo-输出"><a class="header-anchor" href="#echo-输出" aria-hidden="true">#</a>echo 输出</h2><p>echo 在使用<code>-e</code>的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过<code></code></p><div id="app"><code>#39;string'</code>的方式来进行。比如：<p></p><pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"This is a line"</span>$<span class="token string">'<span class="token entity" title="\n">\n</span>'</span>
This is a line

$
</code></pre><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="trap"><a class="header-anchor" href="#trap" aria-hidden="true">#</a>trap</h2><p>trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子：</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">trap</span> <span class="token string">'[ <span class="token variable">$?</span> -eq 0 ] || dosomething'</span> EXIT
</code></pre><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="split"><a class="header-anchor" href="#split" aria-hidden="true">#</a>split</h2><p>split 在 shell 中并不是原生支持，需要自己实现一个函数，一般使用 read 来实现。</p><pre class="language-bash"><code class="language-bash"><span class="token function-name function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment"># Usage: split "string" "delimiter"</span>
   <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>$<span class="token string">'<span class="token entity" title="\n">\n</span>'</span> <span class="token builtin class-name">read</span> -d <span class="token string">""</span> -ra arr <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">${1<span class="token operator">/</span><span class="token operator">/</span>$2<span class="token operator">/</span></span></span></code><div id="app"><code class="language-bash">#39;\n'}"
   <span class="token builtin class-name">printf</span> <span class="token string">'%s<span class="token entity" title="\n">\n</span>'</span> <span class="token string">"<span class="token variable">${arr<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span>
<span class="token punctuation">}</span>
</code></div></pre><p>这种方式在正常场景下并不会有问题，但是当我们设置了<code>set -e</code>后，上述实现就会提前退出。简单解释一下：</p><pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">read</span> -d <span class="token string">''</span> <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">'Hello World'</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span>
</code></pre><p>这个方式在 while 循环中是非常友好的方式，但是由于设置<code>set -e</code>, 存在返回值不为0 的时候，程序会自动退出。这也就意味着 read 之后就直接 exit 了，所以我们需要简单的规避一下:</p><pre class="language-bash"><code class="language-bash"><span class="token function-name function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment"># Usage: split "string" "delimiter"</span>
   <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>$<span class="token string">'<span class="token entity" title="\n">\n</span>'</span> <span class="token builtin class-name">read</span> -d <span class="token string">""</span> -ra arr <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">${1<span class="token operator">/</span><span class="token operator">/</span>$2<span class="token operator">/</span></span></span></code><div id="app"><code class="language-bash">#39;\n'}" <span class="token operator">||</span> <span class="token boolean">true</span>
   <span class="token builtin class-name">printf</span> <span class="token string">'%s<span class="token entity" title="\n">\n</span>'</span> <span class="token string">"<span class="token variable">${arr<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span>
<span class="token punctuation">}</span>
</code></div></pre><p>通过<code>||</code>将返回值重新变成 0 且逻辑上也是符合需求的。</p><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="tee-redirection"><a class="header-anchor" href="#tee-redirection" aria-hidden="true">#</a>tee redirection</h2><p>在 shell 中实现 tee 对 stdout 和 stderr 的重定向，可以使用如下的方式：</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">tee</span> -a stdout.log<span class="token punctuation">)</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">tee</span> -a stderr.log <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">)</span>
</code></pre><p>其中,<code>&gt;(...) (process substitution)</code>创建一个 FIFO，同时将 command 的输出重定向到这个 FIFO 中。</p><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="find"><a class="header-anchor" href="#find" aria-hidden="true">#</a>find</h2><p>我们通常需要将 find 的结果放到一个 array 中。如果 bash 版本的比较低的时候，我们可以用通过如下的方式进行：</p><pre class="language-bash"><code class="language-bash"><span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>  <span class="token builtin class-name">read</span> -r -d $<span class="token string">'<span class="token entity" title="\0">\0</span>'</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token assign-left variable">array</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token string">"<span class="token environment constant">$REPLY</span>"</span><span class="token punctuation">)</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">find</span> * -type d  -print0<span class="token punctuation">)</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">item</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">${array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$item</span>"</span>
<span class="token keyword">done</span>

<span class="token comment"># output</span>
<span class="token comment"># dirl </span>
<span class="token comment"># dir2</span>
</code></pre><p>上面是查找当前目录下的所有的目录类型。 注意这边 find 用的是<code>*</code>。这会去掉结果前面的<code>./</code>这个前缀。如果我们的 bash 版本在 4.4 以上，我们可以通过下面的一行命令完成。</p><pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">mapfile</span> -d $<span class="token string">'<span class="token entity" title="\0">\0</span>'</span> array <span class="token operator">&lt;</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">find</span> * -type d -print0<span class="token punctuation">)</span>
<span class="token comment"># or </span>
$ <span class="token builtin class-name">readarray</span> -d <span class="token string">''</span> array2 <span class="token operator">&lt;</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">find</span> * -type d -print0<span class="token punctuation">)</span>
</code></pre><p></p><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://linuxcommand.org/lc3_man_pages/mapfileh.html" target="_blank" data-v-6caa15cd="">mapfile doc</a>]:<!--[--> man mapfile<!--]--></span></div><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://helpmanual.io/builtin/readarray/" target="_blank" data-v-6caa15cd="">readarray doc</a>]:<!--[--> man readarray<!--]--></span></div><p></p><div class="outer" data-v-4cdf05f9=""><div class="short-hr" data-v-4cdf05f9=""></div></div><h2 id="set"><a class="header-anchor" href="#set" aria-hidden="true">#</a>set</h2><ul><li><code>-x</code></li></ul><p>在日常脚本中我们需要调试时，可以在脚本的开头或者是需要调试的函数附近加上<code>set -x</code>。这样在此之后的脚本都会以调试模式输出，在不想调试的代码前加上<code>set +x</code>以关闭调试功能。</p><p>在现代的 bash 脚本，支持在脚本内可以直接将调试的输出重定向到指定的文件内，方式如下：</p><pre class="language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">exec</span> <span class="token number">1</span><span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>logfile
<span class="token assign-left variable">BASH_XTRACEFD</span><span class="token operator">=</span><span class="token number">19</span>

<span class="token builtin class-name">set</span> -x
command1
command2
<span class="token punctuation">..</span>.
</code></pre><p>其中<code>BASH_XTRACEFD</code>是用来指定文件描述符给<code>set -x</code>的。</p><p></p><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://askubuntu.com/questions/811439/bash-set-x-logs-to-file" target="_blank" data-v-6caa15cd="">refernece1</a>]:<!--[--> bash set -x log to file<!--]--></span></div><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:stack-overflow.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://stackoverflow.com/questions/11229385/redirect-all-output-in-a-bash-script-when-using-set-x" target="_blank" data-v-6caa15cd="">reference2</a>]:<!--[--> redirect all output in a bash script when using set -x<!--]--></span></div><p></p></div><!--]--></div></div></article></div></div></main><footer max-w="screen-lg" m="x-auto" w="full" p="y-8" text="dark:white dark:opacity-50 sm"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 2021 © Jesse Chan</a></footer></div></div><script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,a=localStorage.getItem("color-schema")||"auto";("dark"===a||e&&"light"!==a)&&document.documentElement.classList.toggle("dark",!0)}()</script></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="no-referrer"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="apple-touch-icon" href="/pwa-192x192.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#00aba9"><meta name="msapplication-TileColor" content="#00aba9"><meta name="theme-color" content="#ffffff"><script type="module" async="" crossorigin="" src="/assets/app.252c1e4c.js"></script><link rel="modulepreload" href="/assets/vendor.80607e96.js"><link rel="stylesheet" href="/assets/app.288c200a.css"><link rel="manifest" href="/manifest.webmanifest"><link rel="modulepreload" crossorigin="" href="/assets/shell_script.2c73d53e.js"><link rel="modulepreload" crossorigin="" href="/assets/Code.fee8bdde.js"><link rel="stylesheet" href="/assets/Code.1ebb05a2.css"><link rel="modulepreload" crossorigin="" href="/assets/ShortHR.090ec3c7.js"><link rel="stylesheet" href="/assets/ShortHR.10dbff62.css"><link rel="modulepreload" crossorigin="" href="/assets/LinkItem.65bc6d8d.js"><link rel="stylesheet" href="/assets/LinkItem.bf447482.css"><meta property="og:title" content="Bash Script Skill Notes"><meta property="og:description" content="collections of bash script skill"><meta name="description" content="collections of bash script skill"><meta name="head:count" content="3"><title>Chan93</title></head><body><div id="app" data-server-rendered="true"><div h="full" flex="~ col" p="x-4"><nav z="100" text="dark-100 dark:light-900" position="fixed top-0 left-0 right-0" bg="dark:dark-500 dark:opacity-50 white opacity-75" backdrop="~ blur-lg" h="18" p="x-4" border="b-1 dark:dark-500"><div max-w="screen-lg" m="ml-4" h="full" flex="~ row" items="center" space="x-4"><a href="/" class="" flex="1"><h1 text="2xl" font="bold">🐣 WhatIf</h1></a><a href="/blogs" class=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M12 16c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2m0-6c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2m0-6c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2M6 16c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2m0-6c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2m0-6c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2m12 12c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2m0-6c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2m0-6c1.1 0 2 .9 2 2s-.9 2-2 2s-2-.9-2-2s.9-2 2-2z" fill="currentColor"></path></svg></a><a href="/notes" class=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M14.6 16.6l4.6-4.6l-4.6-4.6L16 6l6 6l-6 6l-1.4-1.4m-5.2 0L4.8 12l4.6-4.6L8 6l-6 6l6 6l1.4-1.4z" fill="currentColor"></path></svg></a><a href="/books" class=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M9 3v15h3V3H9m3 2l4 13l3-1l-4-13l-3 1M5 5v13h3V5H5M3 19v2h18v-2H3z" fill="currentColor"></path></svg></a><a href="/daily" class=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M19 19H5V8h14m-3-7v2H8V1H6v2H5c-1.11 0-2 .89-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-1V1m-1 11h-5v5h5v-5z" fill="currentColor"></path></svg></a><a href="https://github.com/jesseeisen" target="_blank" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33c.85 0 1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2z" fill="currentColor"></path></svg></a><a cursor="pointer"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg></a></div></nav><main flex="~ 1 row" justify="start" w="full" max-w="screen-lg" m="ml-4" p="t-18" text="dark:light-400 dark-300"><div data-v-610c0928=""><div data-v-610c0928=""><a flex="~ row" items="center" class="dark:text-white-900 dark:opacity-60" space="x-2" m="t-4" cursor="pointer" data-v-610c0928=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1.2em" height="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 32 32" text="12px" data-v-610c0928=""><path d="M14 26l1.41-1.41L7.83 17H28v-2H7.83l7.58-7.59L14 6L4 16l10 10z" fill="currentColor"></path></svg><span text="12px dark:light-50 true-gray-500" font="bold" data-v-610c0928="">Back to prev</span></a></div><header text="center" border="b-1 dark:dark-200" p="y-10" data-v-610c0928=""><h1 text="36px dark:light-50 dark " font=" extrabold -.015em 48px" class="post-title" data-v-610c0928="">Bash Script Skill Notes</h1><div my="20px" data-v-610c0928=""><span text="sm dark:light-900 dark:opacity-60 #666" m="b-2" display="block" data-v-610c0928="">Jan 18, 2021</span></div><div text="left" flex="~" m="t-4" data-v-610c0928=""><div flex="~ row" items="center" space="x-2" class="mx-auto" data-v-610c0928="" data-v-22abfd34=""><img border="rounded-full" src="https://secure.gravatar.com/avatar/190aa3adff4e1451b32c354f0b5fd7f9?size=30" data-v-22abfd34=""><div flex="~ col" class="author-info" data-v-22abfd34=""><span text="500 dark:light-900 dark:opacity-80 dark-900" data-v-22abfd34="">Linkang Chan</span><br data-v-22abfd34=""><a href="https://twitter.com/JessEisen_LJ" class="text-pink-500 text-sm" target="_blank" data-v-22abfd34="">@Jesse Chan</a></div></div></div></header><div flex="~" w="60%" justify="start" data-v-610c0928=""><article m="t-8" data-v-610c0928=""><div w="90%" class="prose prose-lg" text="dark:light-900 dark:opacity-72" data-v-610c0928=""><!--[--><div><div><span><i>incoming (1):</i></span><!--[--><span><a href="/notes/command">command</a></span><!--]--></div><p>bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。</p><h2 id="目录和文件"><a class="header-anchor" href="#目录和文件" aria-hidden="true">#</a>目录和文件</h2><p>遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个<code>for</code>循环，但是实际上我们可以有几种不同的方式来完成这些任务。</p><p><code class="op" data-v-46b747e9=""><!--[-->find<!--]--></code></p><pre class="language-bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span>   // 查找当前目录下所有的文件
<span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">"*.txt"</span> -type f   //find all txt <span class="token function">file</span>
<span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -name <span class="token string">"*.txt"</span> -print0 <span class="token operator">|</span> <span class="token function">xargs</span> -0 <span class="token function">fgrep</span> text
</code></pre><p><code class="op" data-v-46b747e9=""><!--[-->for<!--]--></code></p><p>正常的思路是使用<code>for</code>循环去遍历，使用<code>for</code>循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在<code>bash4</code>的版本下，可以开启<code>globstar</code>或者<code>dotglob</code>这两个选项，区别在于是否要匹配隐藏的文件。</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">shopt</span> -s globstar <span class="token operator">||</span> <span class="token builtin class-name">exit</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">f</span> <span class="token keyword">in</span> **
<span class="token keyword">do</span>
	<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$f</span>"</span> <span class="token operator">=</span>~ <span class="token punctuation">\</span>.txt$ <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
		<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$f</span>"</span>
	<span class="token keyword">fi</span>
<span class="token keyword">done</span>
</code></pre><p>这里面用到了两个技巧，一个是如果不支持<code>globstar</code>就退出脚本执行，另一个是<code>if</code>的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。</p><pre class="language-bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">walk_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token for-or-select variable">f</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
		<span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">"<span class="token variable">$f</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
			walk_tree <span class="token string">"<span class="token variable">$f</span>"</span>
		<span class="token keyword">else</span>
			<span class="token assign-left variable">fullpath</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>readlink -f <span class="token string">"<span class="token variable">$f</span>"</span><span class="token variable">`</span></span>
			<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$fullpath</span>"</span> <span class="token operator">=</span>~ <span class="token punctuation">\</span>.txt$ <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
				<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$fullpath</span>"</span>
			<span class="token keyword">fi</span>
	<span class="token keyword">done</span>
<span class="token punctuation">}</span>
</code></pre><p>有两个可以注意的点是：<code>readlink -f</code>可以输出文件的完整路径。同时<code>$f</code>本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题<code>find</code>是首选的。其次不需要使用递归也是一个非常棒的方式。<code>find</code>配合上<code>exec</code>和<code>xargs</code>同样可以执行一些简单的命令。</p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="重定向"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a>重定向</h2><p>重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是<code>&gt;</code>,<code>&gt;&gt;</code>这两个。下面是简单的一些记录很处理。</p><p><strong>描述符复制</strong></p><blockquote><p><code>n&gt;&amp;m</code>将描述符 n 指向 m 所指向的位置。</p></blockquote><p>我们一般使用<code>exec</code>来执行描述符之间的复制。</p><pre class="language-shell"><code class="language-shell">$ <span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
$ <span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span><span class="token file-descriptor important">&amp;3</span>
$ <span class="token builtin class-name">read</span> -u <span class="token number">4</span> line
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$line</span>"</span>
</code></pre><p>上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。</p><p><strong>重定向顺序</strong></p><blockquote><p><code>2&gt;&amp;1 &gt;foo</code><strong>描述符 2 和 描述符 1 指向不同的位置。</strong></p><p><code>&gt;foo 2&gt;&amp;1</code><strong>描述符 2 和 描述符 1 指向相同的位置。</strong></p></blockquote><p><strong>关闭描述符</strong></p><ul><li>n&lt;&amp;- 关闭一个输入的文件描述符</li><li>n&gt;&amp;- 关闭一个输出的文件描述符</li></ul><p><strong>read 命令中使用重定向</strong></p><p>常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下：</p><pre class="language-shell"><code class="language-shell"><span class="token keyword">while</span> <span class="token builtin class-name">read</span> -r line<span class="token punctuation">;</span> <span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$line</span>"</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
</code></pre><p>然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。</p><pre class="language-shell"><code class="language-shell"><span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>
<span class="token keyword">while</span> <span class="token builtin class-name">read</span> -u <span class="token number">3</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$line</span>"</span>
	<span class="token builtin class-name">read</span> -p <span class="token string">"continue to read?"</span> -n <span class="token number">1</span>
<span class="token keyword">done</span>
</code></pre><p>这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。</p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="here-document-和-here-strings"><a class="header-anchor" href="#here-document-和-here-strings" aria-hidden="true">#</a>Here document 和 Here strings</h2><p>实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。</p><p><code class="op" data-v-46b747e9=""><!--[-->Here document<!--]--></code></p><pre class="language-shell"><code class="language-shell"><span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span><span class="token punctuation">[</span>-<span class="token punctuation">]</span>word
<span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.
word
</code></pre><p>here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的<code>-</code>。使用<code>&lt;&lt;-</code>会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。</p><p>另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如<code>'EOF'</code>这个会抑制后面中的变量的展开。简单的示例如下：</p><pre class="language-shell"><code class="language-shell">$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'EOF'</span>
<span class="token operator">&gt;</span> This is my name <span class="token variable">$name</span>
<span class="token operator">&gt;</span> EOF
This is my name <span class="token variable">$name</span>
</code></pre><p>同时 Here document 也是可以在管道中使用的，简单的示例如下：</p><pre class="language-shell"><code class="language-shell">$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'EOF'</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/a/b/g'</span>
<span class="token operator">&gt;</span> abc
<span class="token operator">&gt;</span> nab
<span class="token operator">&gt;</span> EOF
bbc
nbb
</code></pre><p>还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用：</p><pre class="language-shell"><code class="language-shell"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> filename</span>
aaaa
bbb
ccc
EOF</span>
</code></pre><p><code class="op" data-v-46b747e9=""><!--[-->Here strings<!--]--></code></p><p>大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。</p><pre class="language-shell"><code class="language-shell">$ <span class="token builtin class-name">echo</span> <span class="token string">"Hello World"</span> <span class="token operator">|</span> <span class="token builtin class-name">read</span> first second
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$first</span>"</span> <span class="token string">"<span class="token variable">$second</span>"</span>
<span class="token comment"># nothing</span>
</code></pre><p>此时使用 here strings 则就很合适了。</p><pre class="language-shell"><code class="language-shell">$ <span class="token builtin class-name">read</span> first second <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"hello world"</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$first</span>"</span> <span class="token string">"<span class="token variable">$second</span>"</span>
hello world
</code></pre><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="数学计算"><a class="header-anchor" href="#数学计算" aria-hidden="true">#</a>数学计算</h2><p>数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是<code>(( ))</code>， 有时我们还会使用<code>$(( ))</code>这个是 POSIX 的一个形式。</p><p>bash 中有一个语法，用来转换进制的。即：<code>&lt;base&gt;#number</code>我们可以直接在<code>$(( ))</code>中使用。其次在数学计算符中可以不用使用<code>$</code>符来引用变量。</p><pre class="language-shell"><code class="language-shell">$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token number">3</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">'%d<span class="token entity" title="\n">\n</span>'</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">4</span>
</code></pre><p>在<code>$(( ))</code>中也是支持变量操作的。比如：</p><pre class="language-bash"><code class="language-bash">$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">16</span>#abc<span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">16</span>#${a<span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">2</span>}<span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token builtin class-name">printf</span> <span class="token string">'%s, %s<span class="token entity" title="\n">\n</span>'</span> <span class="token variable">$a</span> <span class="token variable">$b</span>
<span class="token number">2748</span>, <span class="token number">39</span>
</code></pre><p>注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：</p><pre class="language-bash"><code class="language-bash">$ <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>$x[<span class="token number">0</span>]<span class="token variable">))</span></span> <span class="token comment"># 将会被扩展为 $((1[0]))</span>
bash: <span class="token number">1</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>: syntax error: invalid arithmetic operator <span class="token punctuation">(</span>error token is <span class="token string">"[0]"</span><span class="token punctuation">)</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">'%d<span class="token entity" title="\n">\n</span>'</span> <span class="token variable"><span class="token variable">$((</span>${x[<span class="token number">0</span>]}<span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">printf</span> <span class="token string">'%d<span class="token entity" title="\n">\n</span>'</span> <span class="token variable"><span class="token variable">$((</span>"$x" <span class="token operator">==</span> <span class="token number">1</span><span class="token variable">))</span></span>  <span class="token comment"># 解析为 $(("1"))</span>
<span class="token number">1</span>
</code></pre><p>此外，我们也可以用变量扩展作为布尔值的判断。比如：</p><pre class="language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"true"</span>
<span class="token keyword">else</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"false"</span>
<span class="token keyword">fi</span>
<span class="token comment"># false</span>
</code></pre><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="echo-输出"><a class="header-anchor" href="#echo-输出" aria-hidden="true">#</a>echo 输出</h2><p>echo 在使用<code>-e</code>的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过<code></code></p><div id="app"><code>#39;string'</code>的方式来进行。比如：<p></p><pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"This is a line"</span>$<span class="token string">'<span class="token entity" title="\n">\n</span>'</span>
This is a line

$
</code></pre><h3 id="e-问题"><a class="header-anchor" href="#e-问题" aria-hidden="true">#</a><code>-e</code>问题</h3><p>在日常编写脚本的过程中，我们习惯于使用 echo 来完成内容的输出。大部分情况下 echo 是可以正常工作的。但是有时 echo 会因为一些奇怪的问题出现一些不可预期的结果。</p><pre class="language-bash"><code class="language-bash">$ <span class="token assign-left variable">a</span><span class="token operator">=</span>-e
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>

$
</code></pre><p>此时便什么都不会输出，即使我们对变量加上<code>"$a"</code>也不会输出任何内容，同样的, 如果变量的内容是<code>-n/-E</code>也会有同样的问题。这些内容是 echo 的相关选项。同样的问题在 zipecho 命令会有，因为这个命令中使用了 echo 和 sed 的组合。</p><p>因此比较推荐的是使用 printf 作为首选的打印输出。如果实在想用 echo ，上面的问题也是有一个规避方式的，即：</p><pre class="language-bash"><code class="language-bash">$ <span class="token assign-left variable">a</span><span class="token operator">=</span>-e
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span> "</span>
-e
</code></pre><p>在变量后增加一个空格，此时则会被解释为字符串，而不是一个选项。</p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="trap"><a class="header-anchor" href="#trap" aria-hidden="true">#</a>trap</h2><p>trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子：</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">trap</span> <span class="token string">'[ <span class="token variable">$?</span> -eq 0 ] || dosomething'</span> EXIT
</code></pre><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="split"><a class="header-anchor" href="#split" aria-hidden="true">#</a>split</h2><p>split 在 shell 中并不是原生支持，需要自己实现一个函数，一般使用 read 来实现。</p><pre class="language-bash"><code class="language-bash"><span class="token function-name function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment"># Usage: split "string" "delimiter"</span>
   <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>$<span class="token string">'<span class="token entity" title="\n">\n</span>'</span> <span class="token builtin class-name">read</span> -d <span class="token string">""</span> -ra arr <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">${1<span class="token operator">/</span><span class="token operator">/</span>$2<span class="token operator">/</span></span></span></code><div id="app"><code class="language-bash">#39;\n'}"
   <span class="token builtin class-name">printf</span> <span class="token string">'%s<span class="token entity" title="\n">\n</span>'</span> <span class="token string">"<span class="token variable">${arr<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span>
<span class="token punctuation">}</span>
</code></div></pre><p>这种方式在正常场景下并不会有问题，但是当我们设置了<code>set -e</code>后，上述实现就会提前退出。简单解释一下：</p><pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">read</span> -d <span class="token string">''</span> <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">'Hello World'</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span>
</code></pre><p>这个方式在 while 循环中是非常友好的方式，但是由于设置<code>set -e</code>, 存在返回值不为0 的时候，程序会自动退出。这也就意味着 read 之后就直接 exit 了，所以我们需要简单的规避一下:</p><pre class="language-bash"><code class="language-bash"><span class="token function-name function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment"># Usage: split "string" "delimiter"</span>
   <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>$<span class="token string">'<span class="token entity" title="\n">\n</span>'</span> <span class="token builtin class-name">read</span> -d <span class="token string">""</span> -ra arr <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">${1<span class="token operator">/</span><span class="token operator">/</span>$2<span class="token operator">/</span></span></span></code><div id="app"><code class="language-bash">#39;\n'}" <span class="token operator">||</span> <span class="token boolean">true</span>
   <span class="token builtin class-name">printf</span> <span class="token string">'%s<span class="token entity" title="\n">\n</span>'</span> <span class="token string">"<span class="token variable">${arr<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span>
<span class="token punctuation">}</span>
</code></div></pre><p>通过<code>||</code>将返回值重新变成 0 且逻辑上也是符合需求的。</p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="tee-redirection"><a class="header-anchor" href="#tee-redirection" aria-hidden="true">#</a>tee redirection</h2><p>在 shell 中实现 tee 对 stdout 和 stderr 的重定向，可以使用如下的方式：</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">tee</span> -a stdout.log<span class="token punctuation">)</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">tee</span> -a stderr.log <span class="token operator">&gt;</span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">)</span>
</code></pre><p>其中,<code>&gt;(...) (process substitution)</code>创建一个 FIFO，同时将 command 的输出重定向到这个 FIFO 中。</p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="find"><a class="header-anchor" href="#find" aria-hidden="true">#</a>find</h2><p>我们通常需要将 find 的结果放到一个 array 中。如果 bash 版本的比较低的时候，我们可以用通过如下的方式进行：</p><pre class="language-bash"><code class="language-bash"><span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>  <span class="token builtin class-name">read</span> -r -d $<span class="token string">'<span class="token entity" title="\0">\0</span>'</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token assign-left variable">array</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token string">"<span class="token environment constant">$REPLY</span>"</span><span class="token punctuation">)</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">find</span> * -type d  -print0<span class="token punctuation">)</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">item</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">${array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$item</span>"</span>
<span class="token keyword">done</span>

<span class="token comment"># output</span>
<span class="token comment"># dirl </span>
<span class="token comment"># dir2</span>
</code></pre><p>上面是查找当前目录下的所有的目录类型。 注意这边 find 用的是<code>*</code>。这会去掉结果前面的<code>./</code>这个前缀。如果我们的 bash 版本在 4.4 以上，我们可以通过下面的一行命令完成。</p><pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">mapfile</span> -d $<span class="token string">'<span class="token entity" title="\0">\0</span>'</span> array <span class="token operator">&lt;</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">find</span> * -type d -print0<span class="token punctuation">)</span>
<span class="token comment"># or </span>
$ <span class="token builtin class-name">readarray</span> -d <span class="token string">''</span> array2 <span class="token operator">&lt;</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">find</span> * -type d -print0<span class="token punctuation">)</span>
</code></pre><p></p><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://linuxcommand.org/lc3_man_pages/mapfileh.html" target="_blank" data-v-6caa15cd="">mapfile doc</a>]:<!--[--> man mapfile<!--]--></span></div><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://helpmanual.io/builtin/readarray/" target="_blank" data-v-6caa15cd="">readarray doc</a>]:<!--[--> man readarray<!--]--></span></div><p></p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="set"><a class="header-anchor" href="#set" aria-hidden="true">#</a>set</h2><p><code class="op" data-v-46b747e9=""><!--[-->-x<!--]--></code></p><p>在日常脚本中我们需要调试时，可以在脚本的开头或者是需要调试的函数附近加上<code>set -x</code>。这样在此之后的脚本都会以调试模式输出，在不想调试的代码前加上<code>set +x</code>以关闭调试功能。</p><p>在现代的 bash 脚本，支持在脚本内可以直接将调试的输出重定向到指定的文件内，方式如下：</p><pre class="language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">exec</span> <span class="token number">1</span><span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>logfile
<span class="token assign-left variable">BASH_XTRACEFD</span><span class="token operator">=</span><span class="token number">19</span>

<span class="token builtin class-name">set</span> -x
command1
command2
<span class="token punctuation">..</span>.
</code></pre><p>其中<code>BASH_XTRACEFD</code>是用来指定文件描述符给<code>set -x</code>的。</p><p></p><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://askubuntu.com/questions/811439/bash-set-x-logs-to-file" target="_blank" data-v-6caa15cd="">refernece1</a>]:<!--[--> bash set -x log to file<!--]--></span></div><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:stack-overflow.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://stackoverflow.com/questions/11229385/redirect-all-output-in-a-bash-script-when-using-set-x" target="_blank" data-v-6caa15cd="">reference2</a>]:<!--[--> redirect all output in a bash script when using set -x<!--]--></span></div><p></p><p><code class="op" data-v-46b747e9=""><!--[-->-e<!--]--></code></p><p>Abort script at first error, when a command exits with non-zero status (except in until or while loops, if-tests, list constructs)</p><blockquote><p>-e Exit immediately if a pipeline (which may consist of a single simple command), a list, or a compound command (see SHELL GRAMMAR above), exits with a non-zero status.<br>The shell does not exit if the command that fails is part of the command list immediately following a while or until keyword, part of the test following the if or elif reserved words, part of any command executed in a &amp;&amp; or || list except the command following the final &amp;&amp; or ||, any command in a pipeline but the last, or if the command’s return value is being inverted with !.<br>If a compound command other than a subshell returns a non-zero status because a command failed while -e was being ignored, the shell does not exit.<br>A trap on ERR, if set, is executed before the shell exits. This option applies to the shell environment and each subshell environment separately (see COMMAND EXECUTION ENVIRONMENT above), and may cause subshells to exit before executing all the commands in the subshell. If a compound command or shell function executes in a context where -e is being ignored, none of the commands executed within the compound command or function body will be affected by the -e setting, even if -e is set and a command returns a failure status. If a compound command or shell function sets -e while executing in a context where -e is ignored, that setting will not have any effect until the compound command or the command containing the function call completes.</p></blockquote><p>其中需要注意的是:<strong>The shell does not exit if the command that fails is part of the command list immediately following a while or until keyword, part of the test following the if or elif reserved words, part of any command executed in a &amp;&amp; or || list except the command following the final &amp;&amp; or ||, any command in a pipeline but the last, or if the command’s return value is being inverted with !.</strong>这种情况下会失效。</p><p>比如：</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">set</span> -e
<span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token string">"will print"</span>
<span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token string">"not print"</span>
<span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token string">"will print"</span>
</code></pre><p>这是因为使用了<code>&amp;&amp;</code>之后，shell 会认为<code>&amp;&amp;</code>左侧部分是被 test 过了，再加上短路原则，右侧部分不会执行到，所以<code>set -e</code>便没有被触发。 实际上<code>&amp;&amp;</code>是一个<strong>list constructs</strong>。这种情况下就不会触发<code>set -e</code>了。</p><p></p><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://tldp.org/LDP/abs/html/options.html" target="_blank" data-v-6caa15cd="">TLDP Reference</a>]:<!--[--> Set Releated Info<!--]--></span></div><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:stack-overflow.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://stackoverflow.com/a/47625345/4168837" target="_blank" data-v-6caa15cd="">StackOverflow</a>]:<!--[--> Why does set -e; true &amp;&amp; false &amp;&amp; true not exit?<!--]--></span></div><p></p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="check-file"><a class="header-anchor" href="#check-file" aria-hidden="true">#</a>check file</h2><p>Linux 系统上，一切皆文件，但是文件也有不同的类型，当我们需要在脚本中判断某个文件是否存在时，可以通过内置的 flag 来判断：</p><ul><li>-f file(<strong>not directory or device file</strong>)</li><li>-d directory</li><li>-c character device</li><li>-b block device</li><li>-p named pipe</li><li>-S socket</li><li>-e file exists</li><li>-r readable</li><li>-w writable</li><li>-x executable</li><li>-s file is not zero size</li><li>-O you are owner of file</li><li>-G group-id of file same as yours</li><li>-N file modified since it was last read</li></ul><pre class="language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> -f /etc/passwd <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"File exists"</span>
<span class="token keyword">fi</span>
</code></pre><p></p><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://tldp.org/LDP/abs/html/fto.html" target="_blank" data-v-6caa15cd="">tldp</a>]:<!--[--> File test operators<!--]--></span></div><p></p><div class="outer" data-v-a0e12a16=""><div class="short-hr" data-v-a0e12a16=""></div></div><h2 id="parameters-substitution"><a class="header-anchor" href="#parameters-substitution" aria-hidden="true">#</a>Parameters Substitution</h2><pre class="language-bash"><code class="language-bash">+ <span class="token variable">${var}</span>            Value of var <span class="token punctuation">(</span>same as <span class="token variable">$var</span><span class="token punctuation">)</span>	 
+ <span class="token variable">${var-$DEFAULT}</span>   If var not set, evaluate expression as <span class="token variable">$DEFAULT</span> *
+ <span class="token variable">${var<span class="token operator">:-</span>$DEFAULT}</span>	If var not <span class="token builtin class-name">set</span> or is empty, evaluate expression as <span class="token variable">$DEFAULT</span> *
+ <span class="token variable">${var=$DEFAULT}</span>   If var not set, evaluate expression as <span class="token variable">$DEFAULT</span> *
+ <span class="token variable">${var<span class="token operator">:=</span>$DEFAULT}</span>	If var not <span class="token builtin class-name">set</span> or is empty, evaluate expression as <span class="token variable">$DEFAULT</span> *
+ <span class="token variable">${var+$OTHER}</span>	    If var set, evaluate expression as <span class="token variable">$OTHER</span>, otherwise as null string
+ <span class="token variable">${var<span class="token operator">:+</span>$OTHER}</span>    If var set, evaluate expression as <span class="token variable">$OTHER</span>, otherwise as null string
+ <span class="token variable">${var?$ERR_MSG}</span>   If var not set, print <span class="token variable">$ERR_MSG</span> and abort script with an <span class="token builtin class-name">exit</span> status of <span class="token number">1</span>.*
+ <span class="token variable">${var<span class="token operator">:?</span>$ERR_MSG}</span>  If var not set, print <span class="token variable">$ERR_MSG</span> and abort script with an <span class="token builtin class-name">exit</span> status of <span class="token number">1</span>.*
+ <span class="token variable">${<span class="token operator">!</span>varprefix*}</span>    Matches all previously declared variables beginning with varprefix
+ <span class="token variable">${<span class="token operator">!</span>varprefix@}</span>    Matches all previously declared variables beginning with varprefix
</code></pre><p></p><div class="list-item" data-v-6caa15cd=""><span data-v-6caa15cd="">[<span data-v-6caa15cd=""><img style="display:inline-block;margin-right:2px;margin-top:1px;margin-bottom:2px" src="https://api.iconify.design/mdi:link-variant.svg" data-v-6caa15cd=""></span><a class="item-show" href="https://tldp.org/LDP/abs/html/refcards.html#AEN22728" target="_blank" data-v-6caa15cd="">tldp</a>]:<!--[--> Reference Cards<!--]--></span></div><p></p><h2 id="array-as-parameter"><a class="header-anchor" href="#array-as-parameter" aria-hidden="true">#</a>array as parameter</h2><p>在 bash 中将数组作为函数参数传递时，方式与其他的语言略有不同。具体操作如下：</p><pre class="language-bash"><code class="language-bash"><span class="token function-name function">copyfiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token assign-left variable">dst</span><span class="token operator">=</span><span class="token variable">$1</span>
	<span class="token builtin class-name">shift</span>
	<span class="token assign-left variable">srcs</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$@</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token for-or-select variable">src</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$srcs</span>{@}"</span><span class="token punctuation">;</span><span class="token keyword">do</span>
	   <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.
	<span class="token keyword">done</span>
<span class="token punctuation">}</span>

copyfiles <span class="token string">"<span class="token variable">$dst</span>"</span> <span class="token string">"<span class="token variable">${srcs<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>"</span>
</code></pre><h2 id="readarray"><a class="header-anchor" href="#readarray" aria-hidden="true">#</a>readarray</h2><p>在 bash 4+ 版本里面引入了 readarray 内建命令，用于读取指定的内容到数组内。</p><h2 id="debug-shell-script"><a class="header-anchor" href="#debug-shell-script" aria-hidden="true">#</a>debug shell script</h2><pre class="language-bash"><code class="language-bash">$ <span class="token punctuation">(</span>exec <span class="token number">11</span><span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> log <span class="token punctuation">;</span>
<span class="token builtin class-name">export</span> <span class="token environment constant">SHELLOPTS</span> <span class="token assign-left variable">BASH_XTRACEFD</span><span class="token operator">=</span><span class="token number">111</span> <span class="token assign-left variable"><span class="token environment constant">PS4</span></span><span class="token operator">=</span><span class="token string">'(<span class="token environment constant">$BASH_SOURCE</span>:<span class="token variable">$LINENO</span>:<span class="token variable">$FUNCNAME</span>): '</span> <span class="token punctuation">;</span>
<span class="token builtin class-name">set</span> -x <span class="token punctuation">;</span> ./cih.sh<span class="token punctuation">)</span>
</code></pre></div><!--]--></div></div></article></div></div></main><footer max-w="screen-lg" m="ml-4" w="full" p="y-8" text="dark:white dark:opacity-50 sm"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 2025 © Jesse Chan</a></footer></div></div><script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,a=localStorage.getItem("color-schema")||"auto";("dark"===a||e&&"light"!==a)&&document.documentElement.classList.toggle("dark",!0)}()</script></body></html>
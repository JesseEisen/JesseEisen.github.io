<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
      Bash Redirection | Chan
    </title>
    <meta name="description" content="A PKM Site">
    <link rel="stylesheet" href="/assets/style.d7943dd3.css">
    <link rel="modulepreload" href="/assets/framework.ab59a038.js">
    <link rel="modulepreload" href="/assets/posts_19X14.md.74b0704d.lean.js">
    <link rel="modulepreload" href="/assets/app.9bbc2295.js">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
    
  </head>
  <body>
    <div id="app"><div><main class="max-w-4xl mx-auto px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="pt-6 pb-8 space-y-2 md:space-y-5"><h3 class="text-xl leading-9 font-extrabold text-gray-900 tracking-tight sm:leading-10 md:leading-14"><a aria-label="Chan" href="/">Chan</a></h3></div><!--[--><article class="xl:divide-y xl:divide-gray-200" data-v-c610b9ce><header class="pt-6 xl:pb-10 space-y-1 text-center" data-v-c610b9ce><dl data-v-c610b9ce><dt class="sr-only">Published on</dt><dd class="text-base leading-8 font-medium text-gray-500"><time datetime="2019-12-01T12:00:00.000Z">December 1, 2019</time></dd></dl><h1 class="text-3xl leading-9 font-extrabold text-gray-900 tracking-tigh sm:text-4xl sm:leading-10 md:text-5xl md:leanding-14" data-v-c610b9ce>Bash Redirection</h1></header><div class="prose max-w-none pt-10 pb-8" data-v-c610b9ce><p><i class="releated">incoming(1):</i> {<a href="/daily/21B04.html">shell</a>}</p><p>我们经常会在命令行或者脚本中使用重定向，大多数时间我们使用<code>&gt;</code>,<code>&gt;&gt;</code> 这样简单的基于标准文件描述符的重定向。当使用到一些比较复杂的重定向时，重定向也会因为顺序的不同而产生不同的结果。所以有必要来理一理重定向的相关场景。</p><p>当我们在终端下操作时，默认打开了三个文件描述符：</p><ul><li>standard input: <strong>值为 0</strong> 可用<code>stdin</code>表示</li><li>standard output: <strong>值为 1</strong> 可用<code>stdout</code>表示</li><li>standard error: <strong>值为 2</strong> 可用<code>stderr</code>表示</li></ul><p>除了这三个标准的文件描述符，我们还可以通过 <code>exec</code> 来打开更多的文件描述符。</p><h2 id="output-redirection"><a class="header-anchor" href="#output-redirection" aria-hidden="true">#</a> Output Redirection</h2><p>输出重定向，基本语法 <code>n&gt; file</code> (n 表示描述符的值）。一般使用它是 <code>command &gt; file</code>（同样可以使用<code>command 1&gt;file</code>）, 它主要是将原本输出到<code>stdout</code>上的内容重定向到了<code>file</code>，改变的是标准输出。</p><p>如果想将标准错误的结果重定向，可以使用<code>command 2&gt;file</code>。这就将原来输出到标准错误的内容，重定向到<code>file</code>中。同样<code>command 3&gt;file</code>这个命令是将<code>3</code>这个文件描述符重定向到<code>file</code>.</p><h2 id="input-redirection"><a class="header-anchor" href="#input-redirection" aria-hidden="true">#</a> Input Redirection</h2><p>输入重定向，基本语法<code>n&lt; file</code>(n 表示描述符的值）。一般用它来改变<code>stdin</code>的值。可以使用<code>command &lt;file</code>将 file 重定向到标准输入。同样<code>command 3&lt;file</code> 将 file 重定向到<code>3</code>上。</p><h2 id="pipe"><a class="header-anchor" href="#pipe" aria-hidden="true">#</a> Pipe</h2><p>管道 <code>|</code> 主要是将连接了标准输出和标准输入， <code>|</code> 左边是标准输出， 右边是标准输入。</p><h2 id="duplicating"><a class="header-anchor" href="#duplicating" aria-hidden="true">#</a> Duplicating</h2><p>上面介绍的是我们比较常用的三个方式，接下来是<strong>复制文件描述符</strong>。我们经常会看到这样的用法<code>2&gt;&amp;1</code>。这个重定向的意思是：<strong>写到文件描述符 2 的内容将写到文件描述符 1 指向的地方</strong>（不说 stdout/stderr 是因为这两个可以在此之前已经被重定向了）。</p><p>这边所谓的复制可以这样理解。在<code>2&gt;&amp;1</code>后，这两个描述符都指向了同一个地方。复制文件描述符可以抽象成<code>m&gt;&amp;n</code>, 其中<code>m</code>和<code>n</code>是两个描述符。</p><p>通过一个例子理解下复制：</p><div class="language-"><pre><code>$ cat file
line 1
line 2
$ exec 3&lt;file
$ read -u 3 line
$ echo &quot;$line&quot;
line 1
$ exec 4&gt;&amp;3
$ read -u 4 line
$ echo &quot;$line&quot;
line 2
</code></pre></div><p>可以看到在执行了<code>4&gt;&amp;3</code>后，使用描述符<code>4</code>同样能读到<code>3</code>指向的那个文件的下一行。这就表明将<code>3</code>复制给了<code>4</code>。</p><h2 id="order-of-redirection"><a class="header-anchor" href="#order-of-redirection" aria-hidden="true">#</a> Order Of Redirection</h2><p>使用重定向的顺序也是需要注意的，比如一个很经典的问题：</p><blockquote><p>Q:what&#39;s the difference between 2&gt;&amp;1 &gt;foo and &gt;foo 2&gt;&amp;1, and when do I use which?</p></blockquote><p>利用这个问题来说明一下不同的顺序使用重定向会带来什么影响。首先从：</p><ul><li><code>2&gt;&amp;1 &gt;foo</code></li></ul><p>首先<code>2&gt;&amp;1</code>将描述符<code>1</code>复制给描述符<code>2</code>, 这样<code>1</code>和<code>2</code>都指向了同一个地方。 接着将<code>1</code> 重定向到<code>file</code>。 但是此时<code>2</code>还是指向是<strong>之前<code>1</code>指向的地方</strong>。所以此时<code>2</code>和<code>1</code>不是指向的同一个地方，这相当是将<code>1</code>备份了一下。</p><ul><li><code>&gt;foo 2&gt;&amp;1</code></li></ul><p>首先<code>&gt;foo</code>将<code>1</code>重定向到<code>foo</code>, 接着<code>2&gt;&amp;1</code>, 将<code>1</code>复制给<code>2</code>。此时<code>1</code>和<code>2</code>都被重定向到了<code>foo</code>上。</p><p>下面的一个例子便能很好的说明这两个的区别：</p><div class="language-"><pre><code>f() {
	echo &quot;This is stdout&quot;
	echo &quot;This is stderr&quot; 1&gt;&amp;2
}

f &gt;foo 2&gt;&amp;1   # nothing printed out
f 2&gt;&amp;1 &gt;foo   # print &quot;This is stderr&quot; only
</code></pre></div><p>这两种方式没有对错，在不同的需求下使用对应的顺序。</p><h2 id="some-pratical-usages"><a class="header-anchor" href="#some-pratical-usages" aria-hidden="true">#</a> Some Pratical Usages</h2><p>在一些情况下，使用重定向会引发一些错误，我们可以使用一些方式去规避它。</p><ul><li>sed 命令</li></ul><p><code>sed &#39;s/a/A/g&#39; file &gt; file</code>。这个用法估计很多人在不经意间都会用到，实际上这个用法是不会有作用的。我们之所以这么做是想将 sed 做出的修改写入到文件中。所以将标准输出重定向到该文件上。问题就在这儿！ 在 sed 命令执行之前，file 先被重定向，这时 file 就被截断，内容已被清空了，所以 sed 在读文件的时候，什么都读不到。 而正确的做法是使用<code>-i</code> 选项。</p><blockquote><p>注： 千万不要在 sed 中将重定向的文件指定成即将用于输入的那个文件。</p></blockquote><ul><li>read 命令</li></ul><p>在 bash 中，我们习惯性使用如下方式来读取文件的内容：</p><div class="language-"><pre><code>while read -r line; do
  echo &quot;$line&quot;
done &lt; file

</code></pre></div><p>这个用法是没有问题的，也可以很好的执行。不过如果我们在 while 循环体内使用再次使用 read 呢？比如：</p><div class="language-"><pre><code>while read -r line; do
   echo &quot;$line&quot;
   read -p &quot;Continue to read?&quot; -n 1
done &lt; file
</code></pre></div><p>这个情况下就会出错了。出错在于，此时循环体内的标准输入已经被重定向到了<code>file</code>, 而<code>read</code>是要从标准输入中读取，而这时只能从 file 中读取了。这和我们所期望的就有所不同了， 此时可以使用如下方式：</p><div class="language-"><pre><code>exec 3&lt;file
while read -u 3 line;do
	echo &quot;$line&quot;
	read -p &quot;Continue to read?&quot; -n 1
done
</code></pre></div><p>将文件在描述符<code>3</code>上打开，通过 read 指定读取时的描述符，这样就避免了标准输入被重定向的问题。</p><h2 id="create-more-file-descriptor"><a class="header-anchor" href="#create-more-file-descriptor" aria-hidden="true">#</a> Create More File Descriptor</h2><p>上面简单的提了一下使用<code>exec</code>创建描述符，现在介绍一下如何创建合适类型的文件描述符。我们直接从例子来说明创建的过程：</p><div class="language-"><pre><code># we have a file named foo
$ cat foo
hello world
$ exec 3&lt;foo    # create a fd only can used to read.
$ read -n 5  word &lt;&amp;3 # read 5 character from foo
$ echo &quot;$word&quot;
hello
$ echo &quot;good&quot; &gt;&amp;3
-bash: echo: write error: Bad file descriptor
</code></pre></div><p>我们可以看到，再往<code>3</code>里面写入的时候报错了，说明此时<code>3</code>只是一个只读的文件描述符。</p><blockquote><p>注意在使用<code>3</code>这个描述符的时候，我们需要利用复制的方式，不然 bash 会将<code>3</code>理解成普通的文件。如果当前目录下没有<code>3</code>这个文件， bash 便会报错：No such file or directory</p></blockquote><p>因此我们需要用到如下的方式：</p><div class="language-"><pre><code>$ exec 3&lt;&gt;foo  # create a read and write fd
$ read -n 5 word &lt;&amp;3 #read seek the file to position 5
$ echo -n / &gt;&amp;3
$ cat foo
hello/world
</code></pre></div><p>这会儿的<code>3</code>便可读可写。同样的，可以使用<code>exec 3&gt;foo</code> 创建一个可写的文件描述符。（这个可以结合 Linux 系统编程上的 open 函数理解）</p><h2 id="close-file-descriptor"><a class="header-anchor" href="#close-file-descriptor" aria-hidden="true">#</a> Close File Descriptor</h2><p>如果这个描述符不需要再使用了，可以关闭这个描述符。bash 提供了如下的关闭方式：</p><ul><li><code>n&lt;&amp;-</code> 关闭一个用于输入的描述符</li><li><code>0&lt;&amp;-, &lt;&amp;-</code> 关闭标准输入</li><li><code>n&gt;&amp;-</code> 关闭一个用于输出的描述符</li><li><code>1&gt;&amp;-, &gt;&amp;-</code> 关闭标准输出</li></ul><h2 id="abbreviation"><a class="header-anchor" href="#abbreviation" aria-hidden="true">#</a> Abbreviation</h2><ul><li><code>|&amp;</code> abbr <code>2&gt;&amp;1 |</code> added in bash4</li><li><code>&amp;&gt;/dev/null</code> abbr <code>&gt;/dev/null 2&gt;&amp;1</code></li></ul><p>这些缩写可以了解一下，目的是为了能够在别人有使用的时候可以能读懂。</p><h2 id="small-example"><a class="header-anchor" href="#small-example" aria-hidden="true">#</a> Small Example</h2><p>当我们想在脚本中，希望 log 能够一边输出到终端上，一边又能写入文件中。这时候也可以使用到重定向，在 linux 中有一个命令<code>tee</code>是可以将内容输出到标准输出和文件的。我们可以用<code>|</code>来实现，比如：<code>echo &quot;pass&quot; | tee log</code>。不过如果有很多的 log，每条都用<code>|tee log</code> 会比较繁琐。所以可以结合<code>process substitute</code> 和重定向来简化这个过程。</p><div class="language-"><pre><code>exec &gt; &gt;(tee log)
echo &quot;pass&quot;
</code></pre></div><p>这样只要往标准输出的内容，都会被丢给<code>tee</code>. 不过这还不能很完美的工作。原因在于<code>echo</code>是带有缓冲的，所以如果 log 只是有关标准输出的，那么这么使用是没有问题的。不过我们一般也会将标准错误的内容也保存到 log 中的话，可能会出现打印出来的顺序和实际代码中 log 输出的顺序不一致。</p><div class="language-"><pre><code>exec 1&gt; &gt;(tee log)
exec 2&gt; &gt;(tee log)

echo &quot;case 1 pass&quot;
echo &quot;case 2 error&quot; &gt;&amp;2
echo &quot;case 3 pass&quot;
echo &quot;case 4 error&quot; &gt;&amp;2

#will output
case 1 pass
case 3 pass
case 2 error
case 4 error
</code></pre></div><p>如果是对 log 顺序有要求的话，这样的输出明显是不符合条件的。 好在 linux 中提供了两个命令<code>stdbuf</code>和<code>unbuffer</code>。这两个命令的原理是不同的，具体的可自行 goole。</p><div class="language-"><pre><code>echo_unbuf{
	stdbuf -O0 echo &quot;$@&quot;
	#unbuffer echo &quot;$@&quot;
}

echo_unbuf &quot;case 1 pass&quot;
echo_unbuf &quot;case 2 error&quot; &gt;&amp;2
echo_unbuf &quot;case 3 pass&quot;
echo_unbuf &quot;case 4 error&quot; &gt;&amp;2

#will output like output
</code></pre></div><p>通过封装一个<code>echo_unbuf</code>，这样便能保证了 log 输出的顺序是正确的。最后如果出现了后台命令在程序结束后打印，则可以使用<code>sync</code>来同步一下。</p><h2 id="reference"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><ol><li>[<a href="http://unix.stackexchange.com/questions/70963/difference-between-2-2-dev-null-dev-null-and-dev-null-21/70971#70971" target="_blank" rel="noopener noreferrer">Difference between some redirections</a>]</li><li>[<a href="http://www.tldp.org/LDP/abs/html/io-redirection.html" target="_blank" rel="noopener noreferrer">IO Redirection</a>]</li></ol></div></article><footer class="text-right my-12" data-v-c610b9ce><p class="author-show" data-v-c610b9ce>Chan</p></footer><!--]--></main></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"4ba7c645\",\"daily_20d10.md\":\"ca3edd83\",\"daily_20q01.md\":\"6dfd4483\",\"daily_20x11.md\":\"16c672b8\",\"daily_21b04.md\":\"4291f926\",\"daily_21b05.md\":\"e11b2b95\",\"daily_21b06.md\":\"89c066ca\",\"daily_21b07.md\":\"5ec50885\",\"daily_21b11.md\":\"5b41b59e\",\"daily_21b12.md\":\"4c306d93\",\"daily_21c04.md\":\"9db68789\",\"daily_21d09.md\":\"7541a9c0\",\"daily_21d13.md\":\"cffd3403\",\"daily_21d14.md\":\"de8825ae\",\"posts_19x14.md\":\"74b0704d\",\"posts_20e01.md\":\"610cf89c\",\"posts_draw.md\":\"40330124\",\"posts_first_post.md\":\"1eb64573\",\"posts_openssl.md\":\"93f5bec6\",\"posts_tpp.md\":\"b532556d\"}")</script>
    <script type="module" async src="/assets/app.9bbc2295.js"></script>
  </body>
</html>
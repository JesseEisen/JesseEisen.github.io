import{l as e,f as a,A as s}from"./framework.ab59a038.js";const n='{"title":"Talking About Openssl","description":"","frontmatter":{"title":"Talking About Openssl","date":"2020-03-11T00:00:00.000Z","author":"Chan"},"headers":[{"level":2,"title":"命令行","slug":"命令行"},{"level":3,"title":"摘要","slug":"摘要"},{"level":3,"title":"HMAC","slug":"hmac"},{"level":2,"title":"加密","slug":"加密"},{"level":3,"title":"对称加密","slug":"对称加密"}],"relativePath":"posts/openssl.md","lastUpdated":1612683779753}',r={},o=s('<p>之前的经验都是使用 libcurl 时需要附带上 openssl 的支持。并未直接上手使用 libssl 库的操作。最近得幸体验了一下 openssl ，浅浅的了解了一些加密算法。文章内容是基于 <code>openssl 1.1.1g</code> 版本。在此之前可以阅读 <a href="https://halfrost.com/tag/cryptography/" target="_blank" rel="noopener noreferrer">halfrost 有关加密的一系列文章</a>。 本篇文章不会过多的描述算法的原理，会比较侧重于实际使用。命令行和加密算法的接口使用。</p><p>我们还需要明确两个概念：摘要、加解密。 摘要一般是用于数字签名和消息认证，比如常用的 MD5/SHA 等，特点就是对于同一消息内容，使用同一个摘要算法得到的结果总是一样的，而当修改原消息其中的任意一个字符，都会引起最终摘要的结果的不同。摘要不会对消息体本身有任何的修改。而加密算法则是对消息本身进行混淆，使得呈现出来的密文无法直接阅读理解其中的内容，同时还需要保证在拥有解密方法的一方可以正确的还原出明文信息。</p><p>正常加密后的密文所组成的内容都是杂乱无规律的，所以大多数情况我们会通过 base64 的二进制表现方法输出内容。 base64 只是一种编码模式，其规则是固定的，所以任何人都可以可以正向和逆向的解析。64 指的是 [a-zA-z0-9] 这 62 个字符，同时另加两个可打印字符，一般为 <code>/</code> 和 <code>+</code> 这两个字符。 我们还会看到 base64 编码后的内容中还有 <code>=</code> 这个字符一般用来作为后缀使用。</p><h2 id="命令行"><a class="header-anchor" href="#命令行" aria-hidden="true">#</a> 命令行</h2><p>一般情况下，我们优先使用命令行来做验证，如果命令行可以执行通过，那么后面的接口调用就是一个水到渠成的过程了。openssl 提供了目前主流的摘要/加解密算法，功能很全面。</p><h3 id="摘要"><a class="header-anchor" href="#摘要" aria-hidden="true">#</a> 摘要</h3><p>在 Linux 中，计算摘要的命令也有很多，比如：<code>md5sum sha1sum sha224sum sha256sum sha384sum sha512sum</code> 等。我们同样可以用他们来计算摘要。使用 openssl 计算摘要也是很简单的。</p><div class="language-"><pre><code>$ openssl md5  filename\n$ openssl sha  filename\n$ openssl sha256 filename\n$ ....\n</code></pre></div><p>你会发现，这个和直接使用 Linux 命令差别不大。但是我们常用的方式是：对明文计算出摘要，然后会把摘要加密保存。这样在解开密文后，对解密后的内容做一次摘要，然后和解密后的摘要进行比对，如果一致，则表明明文没有被篡改。我们可以使用 openssl 模拟这个过程。</p><div class="language-"><pre><code># 使用 rsa 私玥对摘要加密\n$ openssl dgst -sha256 -sign rsaPrivateKey.pem -out data.sig rawfile\n$ ls -lh data.sig\nPermissions Size User  Date Modified Name\n.rw-r--r--   256 jesse  6 6  9:55    data.sig\n\n# 验证\n$ openssl dgst -sha256 -verify rsaPubkey.pem -signature data.sig rawfile\nVerified OK\n\n## 我们在 rawfile 最后添加一个字符， 再次验证一下\n$ echo &quot;=&quot; &gt;&gt; rawfile\n$ openssl dgst -sha256 -verify rsaPubkey.pem -signature data.sig rawfile\nVerification Failure\n</code></pre></div><p>可以看到只有是同一份文件，其计算出来的摘要才是一致的。这个是一个基本的数字签名的形式。上面加密的过程中使用到了 rsa 的公私钥文件。关于 rsa 的内容会在下面说到。</p><p>上述命令我们是将摘要加密后保存到文件中，我们可以看下这个文件的内容，并尝试将其输出 base64 的编码格式。</p><div class="language-"><pre><code>$ cat data.sig\nwd�ʟ���ї���)jHs�8��L]X�.�2�����7Ψ`���L�4�z�:j;jAÖ��\n+��h[��\\��_)���ީ����i�C��֟l�aZ.���+��������%b�ǧ�&amp;x�.�R�T��=5�̒4��O��V+g+���*�y������J�9|]���os��o\n                                      w��;&quot;y�I��V�4�ȼ\n                                                     x�PӻQb�TZ�\n$ cat data.sig | openssl base64\nE5Ybyw0ftJed78n0/9GXkZx9ie8wLM0vuFVJ/wM66RlYDkR6Ql+Lh+s3zqhg1dsV\nqB1M8zTxiHqvOmoEO2pBw5a7sg13ZInKn7sJpq6zKWpIc8U49txMXVjeLpYyoKHg\nywvxGucumk1ReMaCtJOS5yViqcen4SZ41S6qUuJUEeGe6T0SNefMkjSby0/m1FYr\nZyvFEwQEmuQquXmfF4Kp5db7SpsfOXxdkxep029zvY9vDSvf/xNoW7nHXK2eXymM\njfqiDt6ptu/v2mnfQ8DQ1p9sxWFaLsh/ke8rxOvgAsUMd4mGOyJ5+EkAjMFWkTSW\nyLwLeN1Q07tRYgGqVFoarw==\n</code></pre></div><p>可以看到原始的内容就是一堆二进制的数，在终端上直接显示大多是乱码，而编码成 base64 格式后，输出的内容比较可读。</p><h3 id="hmac"><a class="header-anchor" href="#hmac" aria-hidden="true">#</a> HMAC</h3><p><strong>HMAC</strong>（Hash-based message authentication code ）算法，原本的名称 Keyed-hash message authentication code。 注意其中的 keyed-hash 。也就是说在生成摘要的时候需要基于一个 key。 正常的 MAC 算法是可以通过碰撞来破解的。但是如果在 hash 的过程中加入了 key，也可以称之为 salt 的话，这就会加大碰撞的难度。我们一般会使用如下的命令来生成 HMAC 的摘要。</p><div class="language-"><pre><code>$ echo &quot;Hello&quot; | openssl sha256 -hmac &quot;world&quot;\n(stdin)= f4e006393210bb62c76d1ae02fa54a5b1d3bc0eb8a79ef8df1a6268eb028e63e\n\n</code></pre></div><p>而当没有 <code>world</code> 的话，一般无法计算生成出相同的散列值的。如果你熟悉一些云存储服务器的 SDK。 一般会分配一个 secretKey ，然后生成在请求头中加入中的 verify 字段中使用 HMAC-SHA1 的散列。这个 secretKey 客户端和服务端都有的。因此可以作为一个校验。</p><p><strong>有关摘要可以通过 <code>openssl dgst -help</code> 查看选项，虽然没有 -help 这个选项，但是会触发打印用法。</strong></p><h2 id="加密"><a class="header-anchor" href="#加密" aria-hidden="true">#</a> 加密</h2><p>我们为了让信息完整，正确，可信任的从一方传输到另一方，可以说是费劲心思。想兼容用户体验好和不可破解这两个目的方式可以说是非常的难。目前以软件做的加解密都有一定的机会被破解掉。下面主要是从几种常见的加密算法说起，看看 openssl 是如何来完成这些的。这个过程是为了我们在使用 API 的时候打一下一些基础。</p><h3 id="对称加密"><a class="header-anchor" href="#对称加密" aria-hidden="true">#</a> 对称加密</h3><p>对称加密就是通过同一个密钥能够实现加密和解密。只要第三方不知道这个密钥，就很难破解传输的密文。使用的比较多的是 AES 算法。这种加密方式需要通信双方已经协商好了密钥，而这个密钥不会在公共网络上进行传输。基于此场景下。则安全性就能得到一定的保证。但是如果密钥泄漏，所有的一切隐藏就无济于事了。</p><p>对称加密的原理也比较好理解，就是一个异或计算。 <code>a^b = c; c^b = a;</code> b 就是那个密钥。</p>',24);r.render=function(s,n,r,t,d,l){return e(),a("div",null,[o])};export default r;export{n as __pageData};

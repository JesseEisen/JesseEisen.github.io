import{l as s,f as n,A as a}from"./framework.ab59a038.js";const e='{"title":"21B04","description":"","frontmatter":{"title":"21B04","subtitle":"Script Skill Notes","date":"2021-01-18T00:00:00.000Z","category":"shell script"},"headers":[{"level":2,"title":"目录和文件","slug":"目录和文件"},{"level":2,"title":"重定向","slug":"重定向"},{"level":2,"title":"Here document 和 Here strings","slug":"here-document-和-here-strings"},{"level":2,"title":"数学计算","slug":"数学计算"},{"level":2,"title":"echo 输出","slug":"echo-输出"},{"level":2,"title":"trap","slug":"trap"}],"relativePath":"daily/21B04.md","lastUpdated":1612856534584}',t={},o=a('<p><div class="table-of-contents"><ul><li><a href="#目录和文件">目录和文件</a></li><li><a href="#重定向">重定向</a></li><li><a href="#here-document-和-here-strings">Here document 和 Here strings</a></li><li><a href="#数学计算">数学计算</a></li><li><a href="#echo-输出">echo 输出</a></li><li><a href="#trap">trap</a></li></ul></div></p><hr><p><i class="releated">incoming(1):</i> {<a href="/posts/19X14.html">redirection</a>}</p><p>bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。</p><h2 id="目录和文件"><a class="header-anchor" href="#目录和文件" aria-hidden="true">#</a> 目录和文件</h2><p>遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个 <code>for</code> 循环，但是实际上我们可以有几种不同的方式来完成这些任务。</p><p><strong>find</strong></p><div class="language-"><pre><code>find .   // 查找当前目录下所有的文件\nfind . -name &quot;*.txt&quot; -type f   //find all txt file\nfind . -type f -name &quot;*.txt&quot; -print0 | xargs -0 fgrep text\n</code></pre></div><p><strong>for</strong></p><p>正常的思路是使用 <code>for</code> 循环去遍历，使用 <code>for</code> 循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在 <code>bash4</code> 的版本下，可以开启 <code>globstar</code> 或者 <code>dotglob</code> 这两个选项，区别在于是否要匹配隐藏的文件。</p><div class="language-"><pre><code>shopt -s globstar || exit\n\nfor f in **\ndo\n\tif [ &quot;$f&quot; =~ \\.txt$ ]; then\n\t\techo &quot;$f&quot;\n\tfi\ndone\n</code></pre></div><p>这里面用到了两个技巧，一个是如果不支持 <code>globstar</code> 就退出脚本执行，另一个是 <code>if</code> 的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。</p><div class="language-"><pre><code>function walk_tree()\n{\n\tfor f in &quot;$1&quot;; do\n\t\tif [ -d &quot;$f&quot;]; then\n\t\t\twalk_tree &quot;$f&quot;\n\t\telse\n\t\t\tfullpath=`readlink -f &quot;$f&quot;`\n\t\t\tif [ &quot;$fullpath&quot; =~ \\.txt$ ]; then\n\t\t\t\techo &quot;$fullpath&quot;\n\t\t\tfi\n\tdone\n}\n</code></pre></div><p>有两个可以注意的点是： <code>readlink -f</code> 可以输出文件的完整路径。同时 <code>$f</code> 本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题 <code>find</code> 是首选的。其次不需要使用递归也是一个非常棒的方式。 <code>find</code> 配合上 <code>exec</code> 和 <code>xargs</code> 同样可以执行一些简单的命令。</p><hr><h2 id="重定向"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a> 重定向</h2><p>重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是 <code>&gt;</code> ,<code>&gt;&gt;</code> 这两个。下面是简单的一些记录很处理。</p><p><strong>描述符复制</strong></p><blockquote><p><code>n&gt;&amp;m</code> 将描述符 n 指向 m 所指向的位置。</p></blockquote><p>我们一般使用 <code>exec</code> 来执行描述符之间的复制。</p><div class="language-shell"><pre><code>$ <span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>\n$ <span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span><span class="token file-descriptor important">&amp;3</span>\n$ <span class="token builtin class-name">read</span> -u <span class="token number">4</span> line\n$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$line</span>&quot;</span>\n</code></pre></div><p>上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。</p><p><strong>重定向顺序</strong></p><blockquote><p><code>2&gt;&amp;1 &gt;foo</code> <strong>描述符 2 和 描述符 1 指向不同的位置。</strong></p><p><code>&gt;foo 2&gt;&amp;1</code> <strong>描述符 2 和 描述符 1 指向相同的位置。</strong></p></blockquote><p><strong>关闭描述符</strong></p><ul><li>n&lt;&amp;- 关闭一个输入的文件描述符</li><li>n&gt;&amp;- 关闭一个输出的文件描述符</li></ul><p><strong>read 命令中使用重定向</strong></p><p>常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下：</p><div class="language-shell"><pre><code><span class="token keyword">while</span> <span class="token builtin class-name">read</span> -r line<span class="token punctuation">;</span> <span class="token keyword">do</span>\n\t<span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$line</span>&quot;</span>\n<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token function">file</span>\n</code></pre></div><p>然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。</p><div class="language-shell"><pre><code><span class="token builtin class-name">exec</span> <span class="token number">3</span> <span class="token operator">&lt;</span> <span class="token function">file</span>\n<span class="token keyword">while</span> <span class="token builtin class-name">read</span> -u <span class="token number">3</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span>\n\t<span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$line</span>&quot;</span>\n\t<span class="token builtin class-name">read</span> -p <span class="token string">&quot;continue to read?&quot;</span> -n <span class="token number">1</span>\n<span class="token keyword">done</span>\n</code></pre></div><p>这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。</p><hr><h2 id="here-document-和-here-strings"><a class="header-anchor" href="#here-document-和-here-strings" aria-hidden="true">#</a> Here document 和 Here strings</h2><p>实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。</p><p><strong>Here document</strong></p><div class="language-shell"><pre><code><span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span><span class="token punctuation">[</span>-<span class="token punctuation">]</span>word\n<span class="token punctuation">..</span>.\n<span class="token punctuation">..</span>.\nword\n</code></pre></div><p>here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的 <code>-</code> 。使用 <code>&lt;&lt;-</code> 会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。</p><p>另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如 <code>&#39;EOF&#39;</code> 这个会抑制后面中的变量的展开。简单的示例如下：</p><div class="language-shell"><pre><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&#39;EOF&#39;</span>\n<span class="token operator">&gt;</span> This is my name <span class="token variable">$name</span>\n<span class="token operator">&gt;</span> EOF\nThis is my name <span class="token variable">$name</span>\n</code></pre></div><p>同时 Here document 也是可以在管道中使用的，简单的示例如下：</p><div class="language-shell"><pre><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&#39;EOF&#39;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">&#39;s/a/b/g&#39;</span>\n<span class="token operator">&gt;</span> abc\n<span class="token operator">&gt;</span> nab\n<span class="token operator">&gt;</span> EOF\nbbc\nnbb\n</code></pre></div><p>还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用：</p><div class="language-shell"><pre><code><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> filename</span>\naaaa\nbbb\nccc\nEOF</span>\n</code></pre></div><p><strong>Here strings</strong></p><p>大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。</p><div class="language-shell"><pre><code>$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;Hello World&quot;</span> <span class="token operator">|</span> <span class="token builtin class-name">read</span> first second\n$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$first</span>&quot;</span> <span class="token string">&quot;<span class="token variable">$second</span>&quot;</span>\n<span class="token comment"># nothing</span>\n</code></pre></div><p>此时使用 here strings 则就很合适了。</p><div class="language-shell"><pre><code>$ <span class="token builtin class-name">read</span> first second <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">&quot;hello world&quot;</span>\n$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$first</span>&quot;</span> <span class="token string">&quot;<span class="token variable">$second</span>&quot;</span>\nhello world\n</code></pre></div><hr><h2 id="数学计算"><a class="header-anchor" href="#数学计算" aria-hidden="true">#</a> 数学计算</h2><p>数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是 <code>(( ))</code> ， 有时我们还会使用 <code>$(( ))</code> 这个是 POSIX 的一个形式。</p><p>bash 中有一个语法，用来转换进制的。即：<code>&lt;base&gt;#number</code> 我们可以直接在 <code>$(( ))</code> 中使用。其次在数学计算符中可以不用使用 <code>$</code> 符来引用变量。</p><div class="language-shell"><pre><code>$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">))</span></span>\n$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>\n<span class="token number">3</span>\n$ <span class="token builtin class-name">printf</span> <span class="token string">&#39;%d<span class="token entity" title="\\n">\\n</span>&#39;</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">3</span><span class="token variable">))</span></span>\n<span class="token number">4</span>\n</code></pre></div><p>在 <code>$(( )) </code> 中也是支持变量操作的。比如：</p><div class="language-bash"><pre><code>$ <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">=</span><span class="token number">16</span>#abc<span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">16</span>#${a<span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">2</span>}<span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token builtin class-name">printf</span> <span class="token string">&#39;%s, %s<span class="token entity" title="\\n">\\n</span>&#39;</span> <span class="token variable">$a</span> <span class="token variable">$b</span>\n<span class="token number">2748</span>, <span class="token number">39</span>\n</code></pre></div><p>注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：</p><div class="language-bash"><pre><code>$ <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">1</span>\n$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>$x[<span class="token number">0</span>]<span class="token variable">))</span></span> <span class="token comment"># 将会被扩展为 $((1[0]))</span>\nbash: <span class="token number">1</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>: syntax error: invalid arithmetic operator <span class="token punctuation">(</span>error token is <span class="token string">&quot;[0]&quot;</span><span class="token punctuation">)</span>\n$ <span class="token builtin class-name">printf</span> <span class="token string">&#39;%d<span class="token entity" title="\\n">\\n</span>&#39;</span> <span class="token variable"><span class="token variable">$((</span>${x[<span class="token number">0</span>]}<span class="token variable">))</span></span>\n<span class="token number">1</span>\n$ <span class="token builtin class-name">printf</span> <span class="token string">&#39;%d<span class="token entity" title="\\n">\\n</span>&#39;</span> <span class="token variable"><span class="token variable">$((</span>&quot;$x&quot; <span class="token operator">==</span> <span class="token number">1</span><span class="token variable">))</span></span>  <span class="token comment"># 解析为 $((&quot;1&quot;))</span>\n<span class="token number">1</span>\n</code></pre></div><p>此外，我们也可以用变量扩展作为布尔值的判断。比如：</p><div class="language-bash"><pre><code><span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>\n\t<span class="token builtin class-name">echo</span> <span class="token string">&quot;true&quot;</span>\n<span class="token keyword">else</span>\n\t<span class="token builtin class-name">echo</span> <span class="token string">&quot;false&quot;</span>\n<span class="token keyword">fi</span>\n<span class="token comment"># false</span>\n</code></pre></div><hr><h2 id="echo-输出"><a class="header-anchor" href="#echo-输出" aria-hidden="true">#</a> echo 输出</h2><p>echo 在使用 <code>-e</code> 的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过 <code>$&#39;string&#39;</code> 的方式来进行。比如：</p><div class="language-"><pre><code>$ echo &quot;This is a line&quot;$&#39;\\n&#39;\nThis is a line\n\n$\n</code></pre></div><hr><h2 id="trap"><a class="header-anchor" href="#trap" aria-hidden="true">#</a> trap</h2><p>trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子：</p><div class="language-"><pre><code>trap &#39;[ $? -eq 0 ] || dosomething&#39; EXIT\n</code></pre></div>',68);t.render=function(a,e,t,p,l,c){return s(),n("div",null,[o])};export default t;export{e as __pageData};

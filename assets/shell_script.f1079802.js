import{_ as s}from"./InComing.vue_vue&type=script&setup=true&lang.9cec361a.js";import{_ as n}from"./Code.fee8bdde.js";import{_ as a}from"./ShortHR.090ec3c7.js";import{_ as e}from"./LinkItem.65bc6d8d.js";import{_ as t}from"./app.449ba84e.js";import{h as l,o,a as c,w as p,b as r,k as i}from"./vendor.80607e96.js";const u=r("p",null,"bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。",-1),k=r("h2",{id:"目录和文件"},[r("a",{class:"header-anchor",href:"#目录和文件","aria-hidden":"true"},"#"),i(" 目录和文件")],-1),d=r("p",null,[i("遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个 "),r("code",null,"for"),i(" 循环，但是实际上我们可以有几种不同的方式来完成这些任务。")],-1),h=i("find"),b=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token function"},"find"),i(),r("span",{class:"token builtin class-name"},"."),i("   // 查找当前目录下所有的文件\n"),r("span",{class:"token function"},"find"),i(),r("span",{class:"token builtin class-name"},"."),i(" -name "),r("span",{class:"token string"},'"*.txt"'),i(" -type f   //find all txt "),r("span",{class:"token function"},"file"),i("\n"),r("span",{class:"token function"},"find"),i(),r("span",{class:"token builtin class-name"},"."),i(" -type f -name "),r("span",{class:"token string"},'"*.txt"'),i(" -print0 "),r("span",{class:"token operator"},"|"),i(),r("span",{class:"token function"},"xargs"),i(" -0 "),r("span",{class:"token function"},"fgrep"),i(" text\n")])],-1),m=i("for"),g=r("p",null,[i("正常的思路是使用 "),r("code",null,"for"),i(" 循环去遍历，使用 "),r("code",null,"for"),i(" 循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在 "),r("code",null,"bash4"),i(" 的版本下，可以开启 "),r("code",null,"globstar"),i(" 或者 "),r("code",null,"dotglob"),i(" 这两个选项，区别在于是否要匹配隐藏的文件。")],-1),f=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token builtin class-name"},"shopt"),i(" -s globstar "),r("span",{class:"token operator"},"||"),i(),r("span",{class:"token builtin class-name"},"exit"),i("\n\n"),r("span",{class:"token keyword"},"for"),i(),r("span",{class:"token for-or-select variable"},"f"),i(),r("span",{class:"token keyword"},"in"),i(" **\n"),r("span",{class:"token keyword"},"do"),i("\n\t"),r("span",{class:"token keyword"},"if"),i(),r("span",{class:"token punctuation"},"["),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$f"),i('"')]),i(),r("span",{class:"token operator"},"="),i("~ "),r("span",{class:"token punctuation"},"\\"),i(".txt$ "),r("span",{class:"token punctuation"},"]"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"then"),i("\n\t\t"),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$f"),i('"')]),i("\n\t"),r("span",{class:"token keyword"},"fi"),i("\n"),r("span",{class:"token keyword"},"done"),i("\n")])],-1),v=r("p",null,[i("这里面用到了两个技巧，一个是如果不支持 "),r("code",null,"globstar"),i(" 就退出脚本执行，另一个是 "),r("code",null,"if"),i(" 的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。")],-1),$=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token keyword"},"function"),i(),r("span",{class:"token function-name function"},"walk_tree"),r("span",{class:"token punctuation"},"("),r("span",{class:"token punctuation"},")"),i("\n"),r("span",{class:"token punctuation"},"{"),i("\n\t"),r("span",{class:"token keyword"},"for"),i(),r("span",{class:"token for-or-select variable"},"f"),i(),r("span",{class:"token keyword"},"in"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$1"),i('"')]),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"do"),i("\n\t\t"),r("span",{class:"token keyword"},"if"),i(),r("span",{class:"token punctuation"},"["),i(" -d "),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$f"),i('"')]),r("span",{class:"token punctuation"},"]"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"then"),i("\n\t\t\twalk_tree "),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$f"),i('"')]),i("\n\t\t"),r("span",{class:"token keyword"},"else"),i("\n\t\t\t"),r("span",{class:"token assign-left variable"},"fullpath"),r("span",{class:"token operator"},"="),r("span",{class:"token variable"},[r("span",{class:"token variable"},"`"),i("readlink -f "),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$f"),i('"')]),r("span",{class:"token variable"},"`")]),i("\n\t\t\t"),r("span",{class:"token keyword"},"if"),i(),r("span",{class:"token punctuation"},"["),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$fullpath"),i('"')]),i(),r("span",{class:"token operator"},"="),i("~ "),r("span",{class:"token punctuation"},"\\"),i(".txt$ "),r("span",{class:"token punctuation"},"]"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"then"),i("\n\t\t\t\t"),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$fullpath"),i('"')]),i("\n\t\t\t"),r("span",{class:"token keyword"},"fi"),i("\n\t"),r("span",{class:"token keyword"},"done"),i("\n"),r("span",{class:"token punctuation"},"}"),i("\n")])],-1),y=r("p",null,[i("有两个可以注意的点是： "),r("code",null,"readlink -f"),i(" 可以输出文件的完整路径。同时 "),r("code",null,"$f"),i(" 本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题 "),r("code",null,"find"),i(" 是首选的。其次不需要使用递归也是一个非常棒的方式。 "),r("code",null,"find"),i(" 配合上 "),r("code",null,"exec"),i(" 和 "),r("code",null,"xargs"),i(" 同样可以执行一些简单的命令。")],-1),w=r("h2",{id:"重定向"},[r("a",{class:"header-anchor",href:"#重定向","aria-hidden":"true"},"#"),i(" 重定向")],-1),x=r("p",null,[i("重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是 "),r("code",null,">"),i(" ,"),r("code",null,">>"),i(" 这两个。下面是简单的一些记录很处理。")],-1),E=r("p",null,[r("strong",null,"描述符复制")],-1),_=r("blockquote",null,[r("p",null,[r("code",null,"n>&m"),i(" 将描述符 n 指向 m 所指向的位置。")])],-1),S=r("p",null,[i("我们一般使用 "),r("code",null,"exec"),i(" 来执行描述符之间的复制。")],-1),T=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[i("$ "),r("span",{class:"token builtin class-name"},"exec"),i(),r("span",{class:"token number"},"3"),i(),r("span",{class:"token operator"},"<"),i(),r("span",{class:"token function"},"file"),i("\n$ "),r("span",{class:"token builtin class-name"},"exec"),i(),r("span",{class:"token operator"},[r("span",{class:"token file-descriptor important"},"4"),i(">")]),r("span",{class:"token file-descriptor important"},"&3"),i("\n$ "),r("span",{class:"token builtin class-name"},"read"),i(" -u "),r("span",{class:"token number"},"4"),i(" line\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$line"),i('"')]),i("\n")])],-1),F=r("p",null,"上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。",-1),R=r("p",null,[r("strong",null,"重定向顺序")],-1),I=r("blockquote",null,[r("p",null,[r("code",null,"2>&1 >foo"),i(),r("strong",null,"描述符 2 和 描述符 1 指向不同的位置。")]),r("p",null,[r("code",null,">foo 2>&1"),i(),r("strong",null,"描述符 2 和 描述符 1 指向相同的位置。")])],-1),A=r("p",null,[r("strong",null,"关闭描述符")],-1),L=r("ul",null,[r("li",null,"n<&- 关闭一个输入的文件描述符"),r("li",null,"n>&- 关闭一个输出的文件描述符")],-1),O=r("p",null,[r("strong",null,"read 命令中使用重定向")],-1),H=r("p",null,"常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下：",-1),D=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[r("span",{class:"token keyword"},"while"),i(),r("span",{class:"token builtin class-name"},"read"),i(" -r line"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"do"),i("\n\t"),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$line"),i('"')]),i("\n"),r("span",{class:"token keyword"},"done"),i(),r("span",{class:"token operator"},"<"),i(),r("span",{class:"token function"},"file"),i("\n")])],-1),N=r("p",null,"然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。",-1),U=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[r("span",{class:"token builtin class-name"},"exec"),i(),r("span",{class:"token number"},"3"),i(),r("span",{class:"token operator"},"<"),i(),r("span",{class:"token function"},"file"),i("\n"),r("span",{class:"token keyword"},"while"),i(),r("span",{class:"token builtin class-name"},"read"),i(" -u "),r("span",{class:"token number"},"3"),i(" line"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"do"),i("\n\t"),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$line"),i('"')]),i("\n\t"),r("span",{class:"token builtin class-name"},"read"),i(" -p "),r("span",{class:"token string"},'"continue to read?"'),i(" -n "),r("span",{class:"token number"},"1"),i("\n"),r("span",{class:"token keyword"},"done"),i("\n")])],-1),M=r("p",null,"这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。",-1),C=r("h2",{id:"here-document-和-here-strings"},[r("a",{class:"header-anchor",href:"#here-document-和-here-strings","aria-hidden":"true"},"#"),i(" Here document 和 Here strings")],-1),B=r("p",null,"实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。",-1),P=i("Here document"),X=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[r("span",{class:"token builtin class-name"},"command"),i(),r("span",{class:"token operator"},"<<"),r("span",{class:"token punctuation"},"["),i("-"),r("span",{class:"token punctuation"},"]"),i("word\n"),r("span",{class:"token punctuation"},".."),i(".\n"),r("span",{class:"token punctuation"},".."),i(".\nword\n")])],-1),j=r("p",null,[i("here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的 "),r("code",null,"-"),i(" 。使用 "),r("code",null,"<<-"),i(" 会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。")],-1),q=r("p",null,[i("另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如 "),r("code",null,"'EOF'"),i(" 这个会抑制后面中的变量的展开。简单的示例如下：")],-1),z=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[i("$ "),r("span",{class:"token function"},"cat"),i(),r("span",{class:"token operator"},"<<"),i(),r("span",{class:"token string"},"'EOF'"),i("\n"),r("span",{class:"token operator"},">"),i(" This is my name "),r("span",{class:"token variable"},"$name"),i("\n"),r("span",{class:"token operator"},">"),i(" EOF\nThis is my name "),r("span",{class:"token variable"},"$name"),i("\n")])],-1),G=r("p",null,"同时 Here document 也是可以在管道中使用的，简单的示例如下：",-1),W=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[i("$ "),r("span",{class:"token function"},"cat"),i(),r("span",{class:"token operator"},"<<"),i(),r("span",{class:"token string"},"'EOF'"),i(),r("span",{class:"token operator"},"|"),i(),r("span",{class:"token function"},"sed"),i(),r("span",{class:"token string"},"'s/a/b/g'"),i("\n"),r("span",{class:"token operator"},">"),i(" abc\n"),r("span",{class:"token operator"},">"),i(" nab\n"),r("span",{class:"token operator"},">"),i(" EOF\nbbc\nnbb\n")])],-1),J=r("p",null,"还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用：",-1),V=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[r("span",{class:"token function"},"cat"),i(),r("span",{class:"token operator"},"<<"),i(),r("span",{class:"token string"},[i("EOF"),r("span",{class:"token bash punctuation"},[i(),r("span",{class:"token operator"},">"),i(" filename")]),i("\naaaa\nbbb\nccc\nEOF")]),i("\n")])],-1),Y=i("Here strings"),Z=r("p",null,"大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。",-1),K=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[i("$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"Hello World"'),i(),r("span",{class:"token operator"},"|"),i(),r("span",{class:"token builtin class-name"},"read"),i(" first second\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$first"),i('"')]),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$second"),i('"')]),i("\n"),r("span",{class:"token comment"},"# nothing"),i("\n")])],-1),Q=r("p",null,"此时使用 here strings 则就很合适了。",-1),ss=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[i("$ "),r("span",{class:"token builtin class-name"},"read"),i(" first second "),r("span",{class:"token operator"},"<<<"),i(),r("span",{class:"token string"},'"hello world"'),i("\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$first"),i('"')]),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$second"),i('"')]),i("\nhello world\n")])],-1),ns=r("h2",{id:"数学计算"},[r("a",{class:"header-anchor",href:"#数学计算","aria-hidden":"true"},"#"),i(" 数学计算")],-1),as=r("p",null,[i("数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是 "),r("code",null,"(( ))"),i(" ， 有时我们还会使用 "),r("code",null,"$(( ))"),i(" 这个是 POSIX 的一个形式。")],-1),es=r("p",null,[i("bash 中有一个语法，用来转换进制的。即："),r("code",null,"<base>#number"),i(" 我们可以直接在 "),r("code",null,"$(( ))"),i(" 中使用。其次在数学计算符中可以不用使用 "),r("code",null,"$"),i(" 符来引用变量。")],-1),ts=r("pre",{class:"language-shell"},[r("code",{class:"language-shell"},[i("$ "),r("span",{class:"token variable"},[r("span",{class:"token punctuation"},"(("),i("a"),r("span",{class:"token operator"},"="),r("span",{class:"token number"},"1"),r("span",{class:"token punctuation"},","),i(" a"),r("span",{class:"token operator"},"+"),r("span",{class:"token operator"},"="),r("span",{class:"token number"},"2"),r("span",{class:"token punctuation"},"))")]),i("\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token variable"},"$a"),i("\n"),r("span",{class:"token number"},"3"),i("\n$ "),r("span",{class:"token builtin class-name"},"printf"),i(),r("span",{class:"token string"},[i("'%d"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token variable"},[r("span",{class:"token variable"},"$(("),r("span",{class:"token number"},"1"),r("span",{class:"token operator"},"+"),r("span",{class:"token number"},"3"),r("span",{class:"token variable"},"))")]),i("\n"),r("span",{class:"token number"},"4"),i("\n")])],-1),ls=r("p",null,[i("在 "),r("code",null,"$(( )) "),i(" 中也是支持变量操作的。比如：")],-1),os=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token variable"},[r("span",{class:"token punctuation"},"(("),i("a"),r("span",{class:"token operator"},"="),r("span",{class:"token number"},"16"),i("#abc"),r("span",{class:"token punctuation"},","),i(" b"),r("span",{class:"token operator"},"="),r("span",{class:"token number"},"16"),i("#${a"),r("span",{class:"token operator"},":"),r("span",{class:"token number"},"0"),r("span",{class:"token operator"},":"),r("span",{class:"token number"},"2"),i("}"),r("span",{class:"token punctuation"},"))")]),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token builtin class-name"},"printf"),i(),r("span",{class:"token string"},[i("'%s, %s"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token variable"},"$a"),i(),r("span",{class:"token variable"},"$b"),i("\n"),r("span",{class:"token number"},"2748"),i(", "),r("span",{class:"token number"},"39"),i("\n")])],-1),cs=r("p",null,"注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：",-1),ps=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token assign-left variable"},"x"),r("span",{class:"token operator"},"="),r("span",{class:"token number"},"1"),i("\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token variable"},[r("span",{class:"token variable"},"$(("),i("$x["),r("span",{class:"token number"},"0"),i("]"),r("span",{class:"token variable"},"))")]),i(),r("span",{class:"token comment"},"# 将会被扩展为 $((1[0]))"),i("\nbash: "),r("span",{class:"token number"},"1"),r("span",{class:"token punctuation"},"["),r("span",{class:"token number"},"0"),r("span",{class:"token punctuation"},"]"),i(": syntax error: invalid arithmetic operator "),r("span",{class:"token punctuation"},"("),i("error token is "),r("span",{class:"token string"},'"[0]"'),r("span",{class:"token punctuation"},")"),i("\n$ "),r("span",{class:"token builtin class-name"},"printf"),i(),r("span",{class:"token string"},[i("'%d"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token variable"},[r("span",{class:"token variable"},"$(("),i("${x["),r("span",{class:"token number"},"0"),i("]}"),r("span",{class:"token variable"},"))")]),i("\n"),r("span",{class:"token number"},"1"),i("\n$ "),r("span",{class:"token builtin class-name"},"printf"),i(),r("span",{class:"token string"},[i("'%d"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token variable"},[r("span",{class:"token variable"},"$(("),i('"$x" '),r("span",{class:"token operator"},"=="),i(),r("span",{class:"token number"},"1"),r("span",{class:"token variable"},"))")]),i("  "),r("span",{class:"token comment"},'# 解析为 $(("1"))'),i("\n"),r("span",{class:"token number"},"1"),i("\n")])],-1),rs=r("p",null,"此外，我们也可以用变量扩展作为布尔值的判断。比如：",-1),is=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token keyword"},"if"),i(),r("span",{class:"token variable"},[r("span",{class:"token punctuation"},"(("),r("span",{class:"token number"},"1"),i(),r("span",{class:"token operator"},"=="),i(),r("span",{class:"token number"},"2"),r("span",{class:"token punctuation"},"))")]),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"then"),i("\n\t"),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"true"'),i("\n"),r("span",{class:"token keyword"},"else"),i("\n\t"),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"false"'),i("\n"),r("span",{class:"token keyword"},"fi"),i("\n"),r("span",{class:"token comment"},"# false"),i("\n")])],-1),us=r("h2",{id:"echo-输出"},[r("a",{class:"header-anchor",href:"#echo-输出","aria-hidden":"true"},"#"),i(" echo 输出")],-1),ks=r("p",null,[i("echo 在使用 "),r("code",null,"-e"),i(" 的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过 "),r("code",null,"$'string'"),i(" 的方式来进行。比如：")],-1),ds=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"This is a line"'),i("$"),r("span",{class:"token string"},[i("'"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i("\nThis is a line\n\n$\n")])],-1),hs=r("h3",{id:"e-问题"},[r("a",{class:"header-anchor",href:"#e-问题","aria-hidden":"true"},"#"),i(),r("code",null,"-e"),i(" 问题")],-1),bs=r("p",null,"在日常编写脚本的过程中，我们习惯于使用 echo 来完成内容的输出。大部分情况下 echo 是可以正常工作的。但是有时 echo 会因为一些奇怪的问题出现一些不可预期的结果。",-1),ms=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token assign-left variable"},"a"),r("span",{class:"token operator"},"="),i("-e\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token variable"},"$a"),i("\n\n$\n")])],-1),gs=r("p",null,[i("此时便什么都不会输出，即使我们对变量加上 "),r("code",null,'"$a"'),i(" 也不会输出任何内容，同样的, 如果变量的内容是 "),r("code",null,"-n/-E"),i(" 也会有同样的问题。这些内容是 echo 的相关选项。同样的问题在 zipecho 命令会有，因为这个命令中使用了 echo 和 sed 的组合。")],-1),fs=r("p",null,"因此比较推荐的是使用 printf 作为首选的打印输出。如果实在想用 echo ，上面的问题也是有一个规避方式的，即：",-1),vs=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token assign-left variable"},"a"),r("span",{class:"token operator"},"="),i("-e\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$a"),i(' "')]),i("\n-e\n")])],-1),$s=r("p",null,"在变量后增加一个空格，此时则会被解释为字符串，而不是一个选项。",-1),ys=r("h2",{id:"trap"},[r("a",{class:"header-anchor",href:"#trap","aria-hidden":"true"},"#"),i(" trap")],-1),ws=r("p",null,"trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子：",-1),xs=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token builtin class-name"},"trap"),i(),r("span",{class:"token string"},[i("'[ "),r("span",{class:"token variable"},"$?"),i(" -eq 0 ] || dosomething'")]),i(" EXIT\n")])],-1),Es=r("h2",{id:"split"},[r("a",{class:"header-anchor",href:"#split","aria-hidden":"true"},"#"),i(" split")],-1),_s=r("p",null,"split 在 shell 中并不是原生支持，需要自己实现一个函数，一般使用 read 来实现。",-1),Ss=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token function-name function"},"split"),r("span",{class:"token punctuation"},"("),r("span",{class:"token punctuation"},")"),i(),r("span",{class:"token punctuation"},"{"),i("\n   "),r("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),i("\n   "),r("span",{class:"token assign-left variable"},[r("span",{class:"token environment constant"},"IFS")]),r("span",{class:"token operator"},"="),i("$"),r("span",{class:"token string"},[i("'"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token builtin class-name"},"read"),i(" -d "),r("span",{class:"token string"},'""'),i(" -ra arr "),r("span",{class:"token operator"},"<<<"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},[i("${1"),r("span",{class:"token operator"},"/"),r("span",{class:"token operator"},"/"),i("$2"),r("span",{class:"token operator"},"/"),i("$'\\n'}")]),i('"')]),i("\n   "),r("span",{class:"token builtin class-name"},"printf"),i(),r("span",{class:"token string"},[i("'%s"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},[i("${arr"),r("span",{class:"token punctuation"},"["),i("@"),r("span",{class:"token punctuation"},"]"),i("}")]),i('"')]),i("\n"),r("span",{class:"token punctuation"},"}"),i("\n")])],-1),Ts=r("p",null,[i("这种方式在正常场景下并不会有问题，但是当我们设置了 "),r("code",null,"set -e"),i(" 后，上述实现就会提前退出。简单解释一下：")],-1),Fs=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token builtin class-name"},"read"),i(" -d "),r("span",{class:"token string"},"''"),i(),r("span",{class:"token operator"},"<<<"),i(),r("span",{class:"token string"},"'Hello World'"),i("\n$ "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token variable"},"$?"),i("\n"),r("span",{class:"token number"},"1"),i("\n")])],-1),Rs=r("p",null,[i("这个方式在 while 循环中是非常友好的方式，但是由于设置 "),r("code",null,"set -e"),i(", 存在返回值不为0 的时候，程序会自动退出。这也就意味着 read 之后就直接 exit 了，所以我们需要简单的规避一下:")],-1),Is=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token function-name function"},"split"),r("span",{class:"token punctuation"},"("),r("span",{class:"token punctuation"},")"),i(),r("span",{class:"token punctuation"},"{"),i("\n   "),r("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),i("\n   "),r("span",{class:"token assign-left variable"},[r("span",{class:"token environment constant"},"IFS")]),r("span",{class:"token operator"},"="),i("$"),r("span",{class:"token string"},[i("'"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token builtin class-name"},"read"),i(" -d "),r("span",{class:"token string"},'""'),i(" -ra arr "),r("span",{class:"token operator"},"<<<"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},[i("${1"),r("span",{class:"token operator"},"/"),r("span",{class:"token operator"},"/"),i("$2"),r("span",{class:"token operator"},"/"),i("$'\\n'}")]),i('"')]),i(),r("span",{class:"token operator"},"||"),i(),r("span",{class:"token boolean"},"true"),i("\n   "),r("span",{class:"token builtin class-name"},"printf"),i(),r("span",{class:"token string"},[i("'%s"),r("span",{class:"token entity",title:"\\n"},"\\n"),i("'")]),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},[i("${arr"),r("span",{class:"token punctuation"},"["),i("@"),r("span",{class:"token punctuation"},"]"),i("}")]),i('"')]),i("\n"),r("span",{class:"token punctuation"},"}"),i("\n")])],-1),As=r("p",null,[i("通过 "),r("code",null,"||"),i(" 将返回值重新变成 0 且逻辑上也是符合需求的。")],-1),Ls=r("h2",{id:"tee-redirection"},[r("a",{class:"header-anchor",href:"#tee-redirection","aria-hidden":"true"},"#"),i(" tee redirection")],-1),Os=r("p",null,"在 shell 中实现 tee 对 stdout 和 stderr 的重定向，可以使用如下的方式：",-1),Hs=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token builtin class-name"},"command"),i(),r("span",{class:"token operator"},">"),i(),r("span",{class:"token operator"},">"),r("span",{class:"token punctuation"},"("),r("span",{class:"token function"},"tee"),i(" -a stdout.log"),r("span",{class:"token punctuation"},")"),i(),r("span",{class:"token operator"},[r("span",{class:"token file-descriptor important"},"2"),i(">")]),i(),r("span",{class:"token operator"},">"),r("span",{class:"token punctuation"},"("),r("span",{class:"token function"},"tee"),i(" -a stderr.log "),r("span",{class:"token operator"},">"),r("span",{class:"token file-descriptor important"},"&2"),r("span",{class:"token punctuation"},")"),i("\n")])],-1),Ds=r("p",null,[i("其中, "),r("code",null,">(...) (process substitution)"),i(" 创建一个 FIFO，同时将 command 的输出重定向到这个 FIFO 中。")],-1),Ns=r("h2",{id:"find"},[r("a",{class:"header-anchor",href:"#find","aria-hidden":"true"},"#"),i(" find")],-1),Us=r("p",null,"我们通常需要将 find 的结果放到一个 array 中。如果 bash 版本的比较低的时候，我们可以用通过如下的方式进行：",-1),Ms=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token assign-left variable"},"array"),r("span",{class:"token operator"},"="),r("span",{class:"token punctuation"},"("),r("span",{class:"token punctuation"},")"),i("\n"),r("span",{class:"token keyword"},"while"),i(),r("span",{class:"token assign-left variable"},[r("span",{class:"token environment constant"},"IFS")]),r("span",{class:"token operator"},"="),i("  "),r("span",{class:"token builtin class-name"},"read"),i(" -r -d $"),r("span",{class:"token string"},[i("'"),r("span",{class:"token entity",title:"\\0"},"\\0"),i("'")]),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"do"),i("\n    "),r("span",{class:"token assign-left variable"},"array"),r("span",{class:"token operator"},"+="),r("span",{class:"token punctuation"},"("),r("span",{class:"token string"},[i('"'),r("span",{class:"token environment constant"},"$REPLY"),i('"')]),r("span",{class:"token punctuation"},")"),i("\n"),r("span",{class:"token keyword"},"done"),i(),r("span",{class:"token operator"},"<"),i(),r("span",{class:"token operator"},"<"),r("span",{class:"token punctuation"},"("),r("span",{class:"token function"},"find"),i(" * -type d  -print0"),r("span",{class:"token punctuation"},")"),i("\n\n"),r("span",{class:"token keyword"},"for"),i(),r("span",{class:"token for-or-select variable"},"item"),i(),r("span",{class:"token keyword"},"in"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},[i("${array"),r("span",{class:"token punctuation"},"["),i("@"),r("span",{class:"token punctuation"},"]"),i("}")]),i('"')]),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"do"),i("\n  "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$item"),i('"')]),i("\n"),r("span",{class:"token keyword"},"done"),i("\n\n"),r("span",{class:"token comment"},"# output"),i("\n"),r("span",{class:"token comment"},"# dirl "),i("\n"),r("span",{class:"token comment"},"# dir2"),i("\n")])],-1),Cs=r("p",null,[i("上面是查找当前目录下的所有的目录类型。 注意这边 find 用的是 "),r("code",null,"*"),i("。这会去掉结果前面的 "),r("code",null,"./"),i(" 这个前缀。如果我们的 bash 版本在 4.4 以上，我们可以通过下面的一行命令完成。")],-1),Bs=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token builtin class-name"},"mapfile"),i(" -d $"),r("span",{class:"token string"},[i("'"),r("span",{class:"token entity",title:"\\0"},"\\0"),i("'")]),i(" array "),r("span",{class:"token operator"},"<"),i(),r("span",{class:"token operator"},"<"),r("span",{class:"token punctuation"},"("),r("span",{class:"token function"},"find"),i(" * -type d -print0"),r("span",{class:"token punctuation"},")"),i("\n"),r("span",{class:"token comment"},"# or "),i("\n$ "),r("span",{class:"token builtin class-name"},"readarray"),i(" -d "),r("span",{class:"token string"},"''"),i(" array2 "),r("span",{class:"token operator"},"<"),i(),r("span",{class:"token operator"},"<"),r("span",{class:"token punctuation"},"("),r("span",{class:"token function"},"find"),i(" * -type d -print0"),r("span",{class:"token punctuation"},")"),i("\n")])],-1),Ps=i(" man mapfile "),Xs=i(" man readarray "),js=r("h2",{id:"set"},[r("a",{class:"header-anchor",href:"#set","aria-hidden":"true"},"#"),i(" set")],-1),qs=i("-x"),zs=r("p",null,[i("在日常脚本中我们需要调试时，可以在脚本的开头或者是需要调试的函数附近加上 "),r("code",null,"set -x"),i("。这样在此之后的脚本都会以调试模式输出，在不想调试的代码前加上 "),r("code",null,"set +x"),i(" 以关闭调试功能。")],-1),Gs=r("p",null,"在现代的 bash 脚本，支持在脚本内可以直接将调试的输出重定向到指定的文件内，方式如下：",-1),Ws=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token shebang important"},"#!/bin/bash"),i("\n\n"),r("span",{class:"token builtin class-name"},"exec"),i(),r("span",{class:"token number"},"1"),r("span",{class:"token operator"},[r("span",{class:"token file-descriptor important"},"9"),i(">")]),i("logfile\n"),r("span",{class:"token assign-left variable"},"BASH_XTRACEFD"),r("span",{class:"token operator"},"="),r("span",{class:"token number"},"19"),i("\n\n"),r("span",{class:"token builtin class-name"},"set"),i(" -x\ncommand1\ncommand2\n"),r("span",{class:"token punctuation"},".."),i(".\n")])],-1),Js=r("p",null,[i("其中 "),r("code",null,"BASH_XTRACEFD"),i(" 是用来指定文件描述符给 "),r("code",null,"set -x"),i(" 的。")],-1),Vs=i("bash set -x log to file"),Ys=i("redirect all output in a bash script when using set -x"),Zs=i("-e"),Ks=r("p",null,"Abort script at first error, when a command exits with non-zero status (except in until or while loops, if-tests, list constructs)",-1),Qs=r("blockquote",null,[r("p",null,[i("-e Exit immediately if a pipeline (which may consist of a single simple command), a list, or a compound command (see SHELL GRAMMAR above), exits with a non-zero status."),r("br"),i(" The shell does not exit if the command that fails is part of the command list immediately following a while or until keyword, part of the test following the if or elif reserved words, part of any command executed in a && or || list except the command following the final && or ||, any command in a pipeline but the last, or if the command’s return value is being inverted with !."),r("br"),i(" If a compound command other than a subshell returns a non-zero status because a command failed while -e was being ignored, the shell does not exit."),r("br"),i(" A trap on ERR, if set, is executed before the shell exits. This option applies to the shell environment and each subshell environment separately (see COMMAND EXECUTION ENVIRONMENT above), and may cause subshells to exit before executing all the commands in the subshell. If a compound command or shell function executes in a context where -e is being ignored, none of the commands executed within the compound command or function body will be affected by the -e setting, even if -e is set and a command returns a failure status. If a compound command or shell function sets -e while executing in a context where -e is ignored, that setting will not have any effect until the compound command or the command containing the function call completes.")])],-1),sn=r("p",null,[i("其中需要注意的是: "),r("strong",null,"The shell does not exit if the command that fails is part of the command list immediately following a while or until keyword, part of the test following the if or elif reserved words, part of any command executed in a && or || list except the command following the final && or ||, any command in a pipeline but the last, or if the command’s return value is being inverted with !."),i(" 这种情况下会失效。")],-1),nn=r("p",null,"比如：",-1),an=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token builtin class-name"},"set"),i(" -e\n"),r("span",{class:"token boolean"},"false"),i(),r("span",{class:"token operator"},"&&"),i(),r("span",{class:"token boolean"},"true"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"will print"'),i("\n"),r("span",{class:"token boolean"},"true"),i(),r("span",{class:"token operator"},"&&"),i(),r("span",{class:"token boolean"},"false"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"not print"'),i("\n"),r("span",{class:"token boolean"},"true"),i(),r("span",{class:"token operator"},"&&"),i(),r("span",{class:"token boolean"},"false"),i(),r("span",{class:"token operator"},"||"),i(),r("span",{class:"token boolean"},"true"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"will print"'),i("\n")])],-1),en=r("p",null,[i("这是因为使用了 "),r("code",null,"&&"),i(" 之后，shell 会认为 "),r("code",null,"&&"),i(" 左侧部分是被 test 过了，再加上短路原则，右侧部分不会执行到，所以 "),r("code",null,"set -e"),i(" 便没有被触发。 实际上 "),r("code",null,"&&"),i(" 是一个 "),r("strong",null,"list constructs"),i("。这种情况下就不会触发 "),r("code",null,"set -e"),i(" 了。")],-1),tn=i(" Set Releated Info "),ln=i(" Why does set -e; true && false && true not exit? "),on=r("h2",{id:"check-file"},[r("a",{class:"header-anchor",href:"#check-file","aria-hidden":"true"},"#"),i(" check file")],-1),cn=r("p",null,"Linux 系统上，一切皆文件，但是文件也有不同的类型，当我们需要在脚本中判断某个文件是否存在时，可以通过内置的 flag 来判断：",-1),pn=r("ul",null,[r("li",null,[i("-f file("),r("strong",null,"not directory or device file"),i(")")]),r("li",null,"-d directory"),r("li",null,"-c character device"),r("li",null,"-b block device"),r("li",null,"-p named pipe"),r("li",null,"-S socket"),r("li",null,"-e file exists"),r("li",null,"-r readable"),r("li",null,"-w writable"),r("li",null,"-x executable"),r("li",null,"-s file is not zero size"),r("li",null,"-O you are owner of file"),r("li",null,"-G group-id of file same as yours"),r("li",null,"-N file modified since it was last read")],-1),rn=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token keyword"},"if"),i(),r("span",{class:"token punctuation"},"["),i(" -f /etc/passwd "),r("span",{class:"token punctuation"},"]"),r("span",{class:"token punctuation"},";"),i(),r("span",{class:"token keyword"},"then"),i("\n  "),r("span",{class:"token builtin class-name"},"echo"),i(),r("span",{class:"token string"},'"File exists"'),i("\n"),r("span",{class:"token keyword"},"fi"),i("\n")])],-1),un=i("File test operators"),kn=r("h2",{id:"parameters-substitution"},[r("a",{class:"header-anchor",href:"#parameters-substitution","aria-hidden":"true"},"#"),i(" Parameters Substitution")],-1),dn=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("+ "),r("span",{class:"token variable"},"${var}"),i("            Value of var "),r("span",{class:"token punctuation"},"("),i("same as "),r("span",{class:"token variable"},"$var"),r("span",{class:"token punctuation"},")"),i("\t \n+ "),r("span",{class:"token variable"},"${var-$DEFAULT}"),i("   If var not set, evaluate expression as "),r("span",{class:"token variable"},"$DEFAULT"),i(" *\n+ "),r("span",{class:"token variable"},[i("${var"),r("span",{class:"token operator"},":-"),i("$DEFAULT}")]),i("\tIf var not "),r("span",{class:"token builtin class-name"},"set"),i(" or is empty, evaluate expression as "),r("span",{class:"token variable"},"$DEFAULT"),i(" *\n+ "),r("span",{class:"token variable"},"${var=$DEFAULT}"),i("   If var not set, evaluate expression as "),r("span",{class:"token variable"},"$DEFAULT"),i(" *\n+ "),r("span",{class:"token variable"},[i("${var"),r("span",{class:"token operator"},":="),i("$DEFAULT}")]),i("\tIf var not "),r("span",{class:"token builtin class-name"},"set"),i(" or is empty, evaluate expression as "),r("span",{class:"token variable"},"$DEFAULT"),i(" *\n+ "),r("span",{class:"token variable"},"${var+$OTHER}"),i("\t    If var set, evaluate expression as "),r("span",{class:"token variable"},"$OTHER"),i(", otherwise as null string\n+ "),r("span",{class:"token variable"},[i("${var"),r("span",{class:"token operator"},":+"),i("$OTHER}")]),i("    If var set, evaluate expression as "),r("span",{class:"token variable"},"$OTHER"),i(", otherwise as null string\n+ "),r("span",{class:"token variable"},"${var?$ERR_MSG}"),i("   If var not set, print "),r("span",{class:"token variable"},"$ERR_MSG"),i(" and abort script with an "),r("span",{class:"token builtin class-name"},"exit"),i(" status of "),r("span",{class:"token number"},"1"),i(".*\n+ "),r("span",{class:"token variable"},[i("${var"),r("span",{class:"token operator"},":?"),i("$ERR_MSG}")]),i("  If var not set, print "),r("span",{class:"token variable"},"$ERR_MSG"),i(" and abort script with an "),r("span",{class:"token builtin class-name"},"exit"),i(" status of "),r("span",{class:"token number"},"1"),i(".*\n+ "),r("span",{class:"token variable"},[i("${"),r("span",{class:"token operator"},"!"),i("varprefix*}")]),i("    Matches all previously declared variables beginning with varprefix\n+ "),r("span",{class:"token variable"},[i("${"),r("span",{class:"token operator"},"!"),i("varprefix@}")]),i("    Matches all previously declared variables beginning with varprefix\n")])],-1),hn=i("Reference Cards"),bn=r("h2",{id:"array-as-parameter"},[r("a",{class:"header-anchor",href:"#array-as-parameter","aria-hidden":"true"},"#"),i(" array as parameter")],-1),mn=r("p",null,"在 bash 中将数组作为函数参数传递时，方式与其他的语言略有不同。具体操作如下：",-1),gn=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[r("span",{class:"token function-name function"},"copyfiles"),r("span",{class:"token punctuation"},"("),r("span",{class:"token punctuation"},")"),i(),r("span",{class:"token punctuation"},"{"),i("\n\t"),r("span",{class:"token assign-left variable"},"dst"),r("span",{class:"token operator"},"="),r("span",{class:"token variable"},"$1"),i("\n\t"),r("span",{class:"token builtin class-name"},"shift"),i("\n\t"),r("span",{class:"token assign-left variable"},"srcs"),r("span",{class:"token operator"},"="),r("span",{class:"token punctuation"},"("),r("span",{class:"token variable"},"$@"),r("span",{class:"token punctuation"},")"),i("\n\n\t"),r("span",{class:"token keyword"},"for"),i(),r("span",{class:"token for-or-select variable"},"src"),i(),r("span",{class:"token keyword"},"in"),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$srcs"),i('{@}"')]),r("span",{class:"token punctuation"},";"),r("span",{class:"token keyword"},"do"),i("\n\t   "),r("span",{class:"token punctuation"},".."),r("span",{class:"token punctuation"},".."),r("span",{class:"token punctuation"},".."),i(".\n\t"),r("span",{class:"token keyword"},"done"),i("\n"),r("span",{class:"token punctuation"},"}"),i("\n\ncopyfiles "),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},"$dst"),i('"')]),i(),r("span",{class:"token string"},[i('"'),r("span",{class:"token variable"},[i("${srcs"),r("span",{class:"token punctuation"},"["),i("@"),r("span",{class:"token punctuation"},"]"),i("}")]),i('"')]),i("\n")])],-1),fn=r("h2",{id:"readarray"},[r("a",{class:"header-anchor",href:"#readarray","aria-hidden":"true"},"#"),i(" readarray")],-1),vn=r("p",null,"在 bash 4+ 版本里面引入了 readarray 内建命令，用于读取指定的内容到数组内。",-1),$n=r("h2",{id:"debug-shell-script"},[r("a",{class:"header-anchor",href:"#debug-shell-script","aria-hidden":"true"},"#"),i(" debug shell script")],-1),yn=r("pre",{class:"language-bash"},[r("code",{class:"language-bash"},[i("$ "),r("span",{class:"token punctuation"},"("),i("exec "),r("span",{class:"token number"},"11"),r("span",{class:"token operator"},[r("span",{class:"token file-descriptor important"},"1"),i(">")]),i(" log "),r("span",{class:"token punctuation"},";"),i("\n"),r("span",{class:"token builtin class-name"},"export"),i(),r("span",{class:"token environment constant"},"SHELLOPTS"),i(),r("span",{class:"token assign-left variable"},"BASH_XTRACEFD"),r("span",{class:"token operator"},"="),r("span",{class:"token number"},"111"),i(),r("span",{class:"token assign-left variable"},[r("span",{class:"token environment constant"},"PS4")]),r("span",{class:"token operator"},"="),r("span",{class:"token string"},[i("'("),r("span",{class:"token environment constant"},"$BASH_SOURCE"),i(":"),r("span",{class:"token variable"},"$LINENO"),i(":"),r("span",{class:"token variable"},"$FUNCNAME"),i("): '")]),i(),r("span",{class:"token punctuation"},";"),i("\n"),r("span",{class:"token builtin class-name"},"set"),i(" -x "),r("span",{class:"token punctuation"},";"),i(" ./cih.sh"),r("span",{class:"token punctuation"},")"),i("\n")])],-1),wn={expose:[],setup(i){const wn={title:"Bash Script Skill Notes",date:"2021-01-18T00:00:00.000Z",author:"Linkang Chan",twitter:"JessEisen_LJ",description:"collections of bash script skill",public:!0,tag:"21B04 bash",meta:[{property:"og:title",content:"Bash Script Skill Notes"},{property:"og:description",content:"collections of bash script skill"},{name:"description",content:"collections of bash script skill"}]};return l({title:"Bash Script Skill Notes",meta:[{property:"og:title",content:"Bash Script Skill Notes"},{property:"og:description",content:"collections of bash script skill"},{name:"description",content:"collections of bash script skill"}]}),(l,i)=>{const xn=s,En=n,_n=a,Sn=e,Tn=t;return o(),c(Tn,{frontmatter:wn},{default:p((()=>[r("div",null,[r(xn,{comings:[{text:"command",url:"/notes/command"}]}),u,k,d,r("p",null,[r(En,{op:""},{default:p((()=>[h])),_:1})]),b,r("p",null,[r(En,{op:""},{default:p((()=>[m])),_:1})]),g,f,v,$,y,r(_n),w,x,E,_,S,T,F,R,I,A,L,O,H,D,N,U,M,r(_n),C,B,r("p",null,[r(En,{op:""},{default:p((()=>[P])),_:1})]),X,j,q,z,G,W,J,V,r("p",null,[r(En,{op:""},{default:p((()=>[Y])),_:1})]),Z,K,Q,ss,r(_n),ns,as,es,ts,ls,os,cs,ps,rs,is,r(_n),us,ks,ds,hs,bs,ms,gs,fs,vs,$s,r(_n),ys,ws,xs,r(_n),Es,_s,Ss,Ts,Fs,Rs,Is,As,r(_n),Ls,Os,Hs,Ds,r(_n),Ns,Us,Ms,Cs,Bs,r("p",null,[r(Sn,{text:"mapfile doc",url:"https://linuxcommand.org/lc3_man_pages/mapfileh.html"},{default:p((()=>[Ps])),_:1}),r(Sn,{text:"readarray doc",url:"https://helpmanual.io/builtin/readarray/"},{default:p((()=>[Xs])),_:1})]),r(_n),js,r("p",null,[r(En,{op:""},{default:p((()=>[qs])),_:1})]),zs,Gs,Ws,Js,r("p",null,[r(Sn,{text:"refernece1",url:"https://askubuntu.com/questions/811439/bash-set-x-logs-to-file"},{default:p((()=>[Vs])),_:1}),r(Sn,{text:"reference2",url:"https://stackoverflow.com/questions/11229385/redirect-all-output-in-a-bash-script-when-using-set-x"},{default:p((()=>[Ys])),_:1})]),r("p",null,[r(En,{op:""},{default:p((()=>[Zs])),_:1})]),Ks,Qs,sn,nn,an,en,r("p",null,[r(Sn,{text:"TLDP Reference",url:"https://tldp.org/LDP/abs/html/options.html"},{default:p((()=>[tn])),_:1}),r(Sn,{text:"StackOverflow",url:"https://stackoverflow.com/a/47625345/4168837"},{default:p((()=>[ln])),_:1})]),r(_n),on,cn,pn,rn,r("p",null,[r(Sn,{text:"tldp",url:"https://tldp.org/LDP/abs/html/fto.html"},{default:p((()=>[un])),_:1})]),r(_n),kn,dn,r("p",null,[r(Sn,{text:"tldp",url:"https://tldp.org/LDP/abs/html/refcards.html#AEN22728"},{default:p((()=>[hn])),_:1})]),bn,mn,gn,fn,vn,$n,yn])])),_:1})}}};export default wn;

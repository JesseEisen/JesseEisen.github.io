import{_ as n}from"./LinkItem.0d5b252e.js";import{_ as s}from"./app.81df611e.js";import{h as a,o as e,a as l,w as t,b as o,k as c}from"./vendor.57ddf3fb.js";const p=o("p",null,"bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。",-1),r=o("h2",{id:"目录和文件"},[o("a",{class:"header-anchor",href:"#目录和文件","aria-hidden":"true"},"#"),c(" 目录和文件")],-1),i=o("p",null,[c("遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个 "),o("code",null,"for"),c(" 循环，但是实际上我们可以有几种不同的方式来完成这些任务。")],-1),u=o("p",null,[o("strong",null,"find")],-1),k=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token function"},"find"),c(),o("span",{class:"token builtin class-name"},"."),c("   // 查找当前目录下所有的文件\n"),o("span",{class:"token function"},"find"),c(),o("span",{class:"token builtin class-name"},"."),c(" -name "),o("span",{class:"token string"},'"*.txt"'),c(" -type f   //find all txt "),o("span",{class:"token function"},"file"),c("\n"),o("span",{class:"token function"},"find"),c(),o("span",{class:"token builtin class-name"},"."),c(" -type f -name "),o("span",{class:"token string"},'"*.txt"'),c(" -print0 "),o("span",{class:"token operator"},"|"),c(),o("span",{class:"token function"},"xargs"),c(" -0 "),o("span",{class:"token function"},"fgrep"),c(" text\n")])],-1),d=o("p",null,[o("strong",null,"for")],-1),b=o("p",null,[c("正常的思路是使用 "),o("code",null,"for"),c(" 循环去遍历，使用 "),o("code",null,"for"),c(" 循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在 "),o("code",null,"bash4"),c(" 的版本下，可以开启 "),o("code",null,"globstar"),c(" 或者 "),o("code",null,"dotglob"),c(" 这两个选项，区别在于是否要匹配隐藏的文件。")],-1),g=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token builtin class-name"},"shopt"),c(" -s globstar "),o("span",{class:"token operator"},"||"),c(),o("span",{class:"token builtin class-name"},"exit"),c("\n\n"),o("span",{class:"token keyword"},"for"),c(),o("span",{class:"token for-or-select variable"},"f"),c(),o("span",{class:"token keyword"},"in"),c(" **\n"),o("span",{class:"token keyword"},"do"),c("\n\t"),o("span",{class:"token keyword"},"if"),c(),o("span",{class:"token punctuation"},"["),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$f"),c('"')]),c(),o("span",{class:"token operator"},"="),c("~ "),o("span",{class:"token punctuation"},"\\"),c(".txt$ "),o("span",{class:"token punctuation"},"]"),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"then"),c("\n\t\t"),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$f"),c('"')]),c("\n\t"),o("span",{class:"token keyword"},"fi"),c("\n"),o("span",{class:"token keyword"},"done"),c("\n")])],-1),h=o("p",null,[c("这里面用到了两个技巧，一个是如果不支持 "),o("code",null,"globstar"),c(" 就退出脚本执行，另一个是 "),o("code",null,"if"),c(" 的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。")],-1),m=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token keyword"},"function"),c(),o("span",{class:"token function-name function"},"walk_tree"),o("span",{class:"token punctuation"},"("),o("span",{class:"token punctuation"},")"),c("\n"),o("span",{class:"token punctuation"},"{"),c("\n\t"),o("span",{class:"token keyword"},"for"),c(),o("span",{class:"token for-or-select variable"},"f"),c(),o("span",{class:"token keyword"},"in"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$1"),c('"')]),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"do"),c("\n\t\t"),o("span",{class:"token keyword"},"if"),c(),o("span",{class:"token punctuation"},"["),c(" -d "),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$f"),c('"')]),o("span",{class:"token punctuation"},"]"),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"then"),c("\n\t\t\twalk_tree "),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$f"),c('"')]),c("\n\t\t"),o("span",{class:"token keyword"},"else"),c("\n\t\t\t"),o("span",{class:"token assign-left variable"},"fullpath"),o("span",{class:"token operator"},"="),o("span",{class:"token variable"},[o("span",{class:"token variable"},"`"),c("readlink -f "),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$f"),c('"')]),o("span",{class:"token variable"},"`")]),c("\n\t\t\t"),o("span",{class:"token keyword"},"if"),c(),o("span",{class:"token punctuation"},"["),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$fullpath"),c('"')]),c(),o("span",{class:"token operator"},"="),c("~ "),o("span",{class:"token punctuation"},"\\"),c(".txt$ "),o("span",{class:"token punctuation"},"]"),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"then"),c("\n\t\t\t\t"),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$fullpath"),c('"')]),c("\n\t\t\t"),o("span",{class:"token keyword"},"fi"),c("\n\t"),o("span",{class:"token keyword"},"done"),c("\n"),o("span",{class:"token punctuation"},"}"),c("\n")])],-1),f=o("p",null,[c("有两个可以注意的点是： "),o("code",null,"readlink -f"),c(" 可以输出文件的完整路径。同时 "),o("code",null,"$f"),c(" 本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题 "),o("code",null,"find"),c(" 是首选的。其次不需要使用递归也是一个非常棒的方式。 "),o("code",null,"find"),c(" 配合上 "),o("code",null,"exec"),c(" 和 "),o("code",null,"xargs"),c(" 同样可以执行一些简单的命令。")],-1),$=o("hr",null,null,-1),y=o("h2",{id:"重定向"},[o("a",{class:"header-anchor",href:"#重定向","aria-hidden":"true"},"#"),c(" 重定向")],-1),v=o("p",null,[c("重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是 "),o("code",null,">"),c(" ,"),o("code",null,">>"),c(" 这两个。下面是简单的一些记录很处理。")],-1),w=o("p",null,[o("strong",null,"描述符复制")],-1),x=o("blockquote",null,[o("p",null,[o("code",null,"n>&m"),c(" 将描述符 n 指向 m 所指向的位置。")])],-1),F=o("p",null,[c("我们一般使用 "),o("code",null,"exec"),c(" 来执行描述符之间的复制。")],-1),T=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[c("$ "),o("span",{class:"token builtin class-name"},"exec"),c(),o("span",{class:"token number"},"3"),c(),o("span",{class:"token operator"},"<"),c(),o("span",{class:"token function"},"file"),c("\n$ "),o("span",{class:"token builtin class-name"},"exec"),c(),o("span",{class:"token operator"},[o("span",{class:"token file-descriptor important"},"4"),c(">")]),o("span",{class:"token file-descriptor important"},"&3"),c("\n$ "),o("span",{class:"token builtin class-name"},"read"),c(" -u "),o("span",{class:"token number"},"4"),c(" line\n$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$line"),c('"')]),c("\n")])],-1),_=o("p",null,"上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。",-1),E=o("p",null,[o("strong",null,"重定向顺序")],-1),I=o("blockquote",null,[o("p",null,[o("code",null,"2>&1 >foo"),c(),o("strong",null,"描述符 2 和 描述符 1 指向不同的位置。")]),o("p",null,[o("code",null,">foo 2>&1"),c(),o("strong",null,"描述符 2 和 描述符 1 指向相同的位置。")])],-1),O=o("p",null,[o("strong",null,"关闭描述符")],-1),H=o("ul",null,[o("li",null,"n<&- 关闭一个输入的文件描述符"),o("li",null,"n>&- 关闭一个输出的文件描述符")],-1),A=o("p",null,[o("strong",null,"read 命令中使用重定向")],-1),B=o("p",null,"常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下：",-1),S=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[o("span",{class:"token keyword"},"while"),c(),o("span",{class:"token builtin class-name"},"read"),c(" -r line"),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"do"),c("\n\t"),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$line"),c('"')]),c("\n"),o("span",{class:"token keyword"},"done"),c(),o("span",{class:"token operator"},"<"),c(),o("span",{class:"token function"},"file"),c("\n")])],-1),q=o("p",null,"然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。",-1),X=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[o("span",{class:"token builtin class-name"},"exec"),c(),o("span",{class:"token number"},"3"),c(),o("span",{class:"token operator"},"<"),c(),o("span",{class:"token function"},"file"),c("\n"),o("span",{class:"token keyword"},"while"),c(),o("span",{class:"token builtin class-name"},"read"),c(" -u "),o("span",{class:"token number"},"3"),c(" line"),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"do"),c("\n\t"),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$line"),c('"')]),c("\n\t"),o("span",{class:"token builtin class-name"},"read"),c(" -p "),o("span",{class:"token string"},'"continue to read?"'),c(" -n "),o("span",{class:"token number"},"1"),c("\n"),o("span",{class:"token keyword"},"done"),c("\n")])],-1),L=o("p",null,"这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。",-1),j=o("hr",null,null,-1),C=o("h2",{id:"here-document-和-here-strings"},[o("a",{class:"header-anchor",href:"#here-document-和-here-strings","aria-hidden":"true"},"#"),c(" Here document 和 Here strings")],-1),R=o("p",null,"实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。",-1),D=o("p",null,[o("strong",null,"Here document")],-1),J=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[o("span",{class:"token builtin class-name"},"command"),c(),o("span",{class:"token operator"},"<<"),o("span",{class:"token punctuation"},"["),c("-"),o("span",{class:"token punctuation"},"]"),c("word\n"),o("span",{class:"token punctuation"},".."),c(".\n"),o("span",{class:"token punctuation"},".."),c(".\nword\n")])],-1),P=o("p",null,[c("here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的 "),o("code",null,"-"),c(" 。使用 "),o("code",null,"<<-"),c(" 会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。")],-1),U=o("p",null,[c("另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如 "),o("code",null,"'EOF'"),c(" 这个会抑制后面中的变量的展开。简单的示例如下：")],-1),W=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[c("$ "),o("span",{class:"token function"},"cat"),c(),o("span",{class:"token operator"},"<<"),c(),o("span",{class:"token string"},"'EOF'"),c("\n"),o("span",{class:"token operator"},">"),c(" This is my name "),o("span",{class:"token variable"},"$name"),c("\n"),o("span",{class:"token operator"},">"),c(" EOF\nThis is my name "),o("span",{class:"token variable"},"$name"),c("\n")])],-1),Y=o("p",null,"同时 Here document 也是可以在管道中使用的，简单的示例如下：",-1),Z=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[c("$ "),o("span",{class:"token function"},"cat"),c(),o("span",{class:"token operator"},"<<"),c(),o("span",{class:"token string"},"'EOF'"),c(),o("span",{class:"token operator"},"|"),c(),o("span",{class:"token function"},"sed"),c(),o("span",{class:"token string"},"'s/a/b/g'"),c("\n"),o("span",{class:"token operator"},">"),c(" abc\n"),o("span",{class:"token operator"},">"),c(" nab\n"),o("span",{class:"token operator"},">"),c(" EOF\nbbc\nnbb\n")])],-1),z=o("p",null,"还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用：",-1),G=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[o("span",{class:"token function"},"cat"),c(),o("span",{class:"token operator"},"<<"),c(),o("span",{class:"token string"},[c("EOF"),o("span",{class:"token bash punctuation"},[c(),o("span",{class:"token operator"},">"),c(" filename")]),c("\naaaa\nbbb\nccc\nEOF")]),c("\n")])],-1),K=o("p",null,[o("strong",null,"Here strings")],-1),M=o("p",null,"大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。",-1),N=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[c("$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},'"Hello World"'),c(),o("span",{class:"token operator"},"|"),c(),o("span",{class:"token builtin class-name"},"read"),c(" first second\n$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$first"),c('"')]),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$second"),c('"')]),c("\n"),o("span",{class:"token comment"},"# nothing"),c("\n")])],-1),Q=o("p",null,"此时使用 here strings 则就很合适了。",-1),V=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[c("$ "),o("span",{class:"token builtin class-name"},"read"),c(" first second "),o("span",{class:"token operator"},"<<<"),c(),o("span",{class:"token string"},'"hello world"'),c("\n$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$first"),c('"')]),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$second"),c('"')]),c("\nhello world\n")])],-1),nn=o("hr",null,null,-1),sn=o("h2",{id:"数学计算"},[o("a",{class:"header-anchor",href:"#数学计算","aria-hidden":"true"},"#"),c(" 数学计算")],-1),an=o("p",null,[c("数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是 "),o("code",null,"(( ))"),c(" ， 有时我们还会使用 "),o("code",null,"$(( ))"),c(" 这个是 POSIX 的一个形式。")],-1),en=o("p",null,[c("bash 中有一个语法，用来转换进制的。即："),o("code",null,"<base>#number"),c(" 我们可以直接在 "),o("code",null,"$(( ))"),c(" 中使用。其次在数学计算符中可以不用使用 "),o("code",null,"$"),c(" 符来引用变量。")],-1),ln=o("pre",{class:"language-shell"},[o("code",{class:"language-shell"},[c("$ "),o("span",{class:"token variable"},[o("span",{class:"token punctuation"},"(("),c("a"),o("span",{class:"token operator"},"="),o("span",{class:"token number"},"1"),o("span",{class:"token punctuation"},","),c(" a"),o("span",{class:"token operator"},"+"),o("span",{class:"token operator"},"="),o("span",{class:"token number"},"2"),o("span",{class:"token punctuation"},"))")]),c("\n$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token variable"},"$a"),c("\n"),o("span",{class:"token number"},"3"),c("\n$ "),o("span",{class:"token builtin class-name"},"printf"),c(),o("span",{class:"token string"},[c("'%d"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token variable"},[o("span",{class:"token variable"},"$(("),o("span",{class:"token number"},"1"),o("span",{class:"token operator"},"+"),o("span",{class:"token number"},"3"),o("span",{class:"token variable"},"))")]),c("\n"),o("span",{class:"token number"},"4"),c("\n")])],-1),tn=o("p",null,[c("在 "),o("code",null,"$(( )) "),c(" 中也是支持变量操作的。比如：")],-1),on=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[c("$ "),o("span",{class:"token variable"},[o("span",{class:"token punctuation"},"(("),c("a"),o("span",{class:"token operator"},"="),o("span",{class:"token number"},"16"),c("#abc"),o("span",{class:"token punctuation"},","),c(" b"),o("span",{class:"token operator"},"="),o("span",{class:"token number"},"16"),c("#${a"),o("span",{class:"token operator"},":"),o("span",{class:"token number"},"0"),o("span",{class:"token operator"},":"),o("span",{class:"token number"},"2"),c("}"),o("span",{class:"token punctuation"},"))")]),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token builtin class-name"},"printf"),c(),o("span",{class:"token string"},[c("'%s, %s"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token variable"},"$a"),c(),o("span",{class:"token variable"},"$b"),c("\n"),o("span",{class:"token number"},"2748"),c(", "),o("span",{class:"token number"},"39"),c("\n")])],-1),cn=o("p",null,"注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：",-1),pn=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[c("$ "),o("span",{class:"token assign-left variable"},"x"),o("span",{class:"token operator"},"="),o("span",{class:"token number"},"1"),c("\n$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token variable"},[o("span",{class:"token variable"},"$(("),c("$x["),o("span",{class:"token number"},"0"),c("]"),o("span",{class:"token variable"},"))")]),c(),o("span",{class:"token comment"},"# 将会被扩展为 $((1[0]))"),c("\nbash: "),o("span",{class:"token number"},"1"),o("span",{class:"token punctuation"},"["),o("span",{class:"token number"},"0"),o("span",{class:"token punctuation"},"]"),c(": syntax error: invalid arithmetic operator "),o("span",{class:"token punctuation"},"("),c("error token is "),o("span",{class:"token string"},'"[0]"'),o("span",{class:"token punctuation"},")"),c("\n$ "),o("span",{class:"token builtin class-name"},"printf"),c(),o("span",{class:"token string"},[c("'%d"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token variable"},[o("span",{class:"token variable"},"$(("),c("${x["),o("span",{class:"token number"},"0"),c("]}"),o("span",{class:"token variable"},"))")]),c("\n"),o("span",{class:"token number"},"1"),c("\n$ "),o("span",{class:"token builtin class-name"},"printf"),c(),o("span",{class:"token string"},[c("'%d"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token variable"},[o("span",{class:"token variable"},"$(("),c('"$x" '),o("span",{class:"token operator"},"=="),c(),o("span",{class:"token number"},"1"),o("span",{class:"token variable"},"))")]),c("  "),o("span",{class:"token comment"},'# 解析为 $(("1"))'),c("\n"),o("span",{class:"token number"},"1"),c("\n")])],-1),rn=o("p",null,"此外，我们也可以用变量扩展作为布尔值的判断。比如：",-1),un=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token keyword"},"if"),c(),o("span",{class:"token variable"},[o("span",{class:"token punctuation"},"(("),o("span",{class:"token number"},"1"),c(),o("span",{class:"token operator"},"=="),c(),o("span",{class:"token number"},"2"),o("span",{class:"token punctuation"},"))")]),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"then"),c("\n\t"),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},'"true"'),c("\n"),o("span",{class:"token keyword"},"else"),c("\n\t"),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},'"false"'),c("\n"),o("span",{class:"token keyword"},"fi"),c("\n"),o("span",{class:"token comment"},"# false"),c("\n")])],-1),kn=o("hr",null,null,-1),dn=o("h2",{id:"echo-输出"},[o("a",{class:"header-anchor",href:"#echo-输出","aria-hidden":"true"},"#"),c(" echo 输出")],-1),bn=o("p",null,[c("echo 在使用 "),o("code",null,"-e"),c(" 的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过 "),o("code",null,"$'string'"),c(" 的方式来进行。比如：")],-1),gn=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[c("$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},'"This is a line"'),c("$"),o("span",{class:"token string"},[c("'"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c("\nThis is a line\n\n$\n")])],-1),hn=o("hr",null,null,-1),mn=o("h2",{id:"trap"},[o("a",{class:"header-anchor",href:"#trap","aria-hidden":"true"},"#"),c(" trap")],-1),fn=o("p",null,"trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子：",-1),$n=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token builtin class-name"},"trap"),c(),o("span",{class:"token string"},[c("'[ "),o("span",{class:"token variable"},"$?"),c(" -eq 0 ] || dosomething'")]),c(" EXIT\n")])],-1),yn=o("hr",null,null,-1),vn=o("h2",{id:"split"},[o("a",{class:"header-anchor",href:"#split","aria-hidden":"true"},"#"),c(" split")],-1),wn=o("p",null,"split 在 shell 中并不是原生支持，需要自己实现一个函数，一般使用 read 来实现。",-1),xn=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token function-name function"},"split"),o("span",{class:"token punctuation"},"("),o("span",{class:"token punctuation"},")"),c(),o("span",{class:"token punctuation"},"{"),c("\n   "),o("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),c("\n   "),o("span",{class:"token assign-left variable"},[o("span",{class:"token environment constant"},"IFS")]),o("span",{class:"token operator"},"="),c("$"),o("span",{class:"token string"},[c("'"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token builtin class-name"},"read"),c(" -d "),o("span",{class:"token string"},'""'),c(" -ra arr "),o("span",{class:"token operator"},"<<<"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},[c("${1"),o("span",{class:"token operator"},"/"),o("span",{class:"token operator"},"/"),c("$2"),o("span",{class:"token operator"},"/"),c("$'\\n'}")]),c('"')]),c("\n   "),o("span",{class:"token builtin class-name"},"printf"),c(),o("span",{class:"token string"},[c("'%s"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},[c("${arr"),o("span",{class:"token punctuation"},"["),c("@"),o("span",{class:"token punctuation"},"]"),c("}")]),c('"')]),c("\n"),o("span",{class:"token punctuation"},"}"),c("\n")])],-1),Fn=o("p",null,[c("这种方式在正常场景下并不会有问题，但是当我们设置了 "),o("code",null,"set -e"),c(" 后，上述实现就会提前退出。简单解释一下：")],-1),Tn=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[c("$ "),o("span",{class:"token builtin class-name"},"read"),c(" -d "),o("span",{class:"token string"},"''"),c(),o("span",{class:"token operator"},"<<<"),c(),o("span",{class:"token string"},"'Hello World'"),c("\n$ "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token variable"},"$?"),c("\n"),o("span",{class:"token number"},"1"),c("\n")])],-1),_n=o("p",null,[c("这个方式在 while 循环中是非常友好的方式，但是由于设置 "),o("code",null,"set -e"),c(", 存在返回值不为0 的时候，程序会自动退出。这也就意味着 read 之后就直接 exit 了，所以我们需要简单的规避一下:")],-1),En=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token function-name function"},"split"),o("span",{class:"token punctuation"},"("),o("span",{class:"token punctuation"},")"),c(),o("span",{class:"token punctuation"},"{"),c("\n   "),o("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),c("\n   "),o("span",{class:"token assign-left variable"},[o("span",{class:"token environment constant"},"IFS")]),o("span",{class:"token operator"},"="),c("$"),o("span",{class:"token string"},[c("'"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token builtin class-name"},"read"),c(" -d "),o("span",{class:"token string"},'""'),c(" -ra arr "),o("span",{class:"token operator"},"<<<"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},[c("${1"),o("span",{class:"token operator"},"/"),o("span",{class:"token operator"},"/"),c("$2"),o("span",{class:"token operator"},"/"),c("$'\\n'}")]),c('"')]),c(),o("span",{class:"token operator"},"||"),c(),o("span",{class:"token boolean"},"true"),c("\n   "),o("span",{class:"token builtin class-name"},"printf"),c(),o("span",{class:"token string"},[c("'%s"),o("span",{class:"token entity",title:"\\n"},"\\n"),c("'")]),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},[c("${arr"),o("span",{class:"token punctuation"},"["),c("@"),o("span",{class:"token punctuation"},"]"),c("}")]),c('"')]),c("\n"),o("span",{class:"token punctuation"},"}"),c("\n")])],-1),In=o("p",null,[c("通过 "),o("code",null,"||"),c(" 将返回值重新变成 0 且逻辑上也是符合需求的。")],-1),On=o("h2",{id:"tee-redirection"},[o("a",{class:"header-anchor",href:"#tee-redirection","aria-hidden":"true"},"#"),c(" tee redirection")],-1),Hn=o("p",null,"在 shell 中实现 tee 对 stdout 和 stderr 的重定向，可以使用如下的方式：",-1),An=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token builtin class-name"},"command"),c(),o("span",{class:"token operator"},">"),c(),o("span",{class:"token operator"},">"),o("span",{class:"token punctuation"},"("),o("span",{class:"token function"},"tee"),c(" -a stdout.log"),o("span",{class:"token punctuation"},")"),c(),o("span",{class:"token operator"},[o("span",{class:"token file-descriptor important"},"2"),c(">")]),c(),o("span",{class:"token operator"},">"),o("span",{class:"token punctuation"},"("),o("span",{class:"token function"},"tee"),c(" -a stderr.log "),o("span",{class:"token operator"},">"),o("span",{class:"token file-descriptor important"},"&2"),o("span",{class:"token punctuation"},")"),c("\n")])],-1),Bn=o("p",null,[c("其中, "),o("code",null,">(...) (process substitution)"),c(" 创建一个 FIFO，同时将 command 的输出重定向到这个 FIFO 中。")],-1),Sn=o("h2",{id:"find"},[o("a",{class:"header-anchor",href:"#find","aria-hidden":"true"},"#"),c(" find")],-1),qn=o("p",null,"我们通常需要将 find 的结果放到一个 array 中。如果 bash 版本的比较低的时候，我们可以用通过如下的方式进行：",-1),Xn=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token assign-left variable"},"array"),o("span",{class:"token operator"},"="),o("span",{class:"token punctuation"},"("),o("span",{class:"token punctuation"},")"),c("\n"),o("span",{class:"token keyword"},"while"),c(),o("span",{class:"token assign-left variable"},[o("span",{class:"token environment constant"},"IFS")]),o("span",{class:"token operator"},"="),c("  "),o("span",{class:"token builtin class-name"},"read"),c(" -r -d $"),o("span",{class:"token string"},[c("'"),o("span",{class:"token entity",title:"\\0"},"\\0"),c("'")]),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"do"),c("\n    "),o("span",{class:"token assign-left variable"},"array"),o("span",{class:"token operator"},"+="),o("span",{class:"token punctuation"},"("),o("span",{class:"token string"},[c('"'),o("span",{class:"token environment constant"},"$REPLY"),c('"')]),o("span",{class:"token punctuation"},")"),c("\n"),o("span",{class:"token keyword"},"done"),c(),o("span",{class:"token operator"},"<"),c(),o("span",{class:"token operator"},"<"),o("span",{class:"token punctuation"},"("),o("span",{class:"token function"},"find"),c(" * -type d  -print0"),o("span",{class:"token punctuation"},")"),c("\n\n"),o("span",{class:"token keyword"},"for"),c(),o("span",{class:"token for-or-select variable"},"item"),c(),o("span",{class:"token keyword"},"in"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},[c("${array"),o("span",{class:"token punctuation"},"["),c("@"),o("span",{class:"token punctuation"},"]"),c("}")]),c('"')]),o("span",{class:"token punctuation"},";"),c(),o("span",{class:"token keyword"},"do"),c("\n  "),o("span",{class:"token builtin class-name"},"echo"),c(),o("span",{class:"token string"},[c('"'),o("span",{class:"token variable"},"$item"),c('"')]),c("\n"),o("span",{class:"token keyword"},"done"),c("\n\n"),o("span",{class:"token comment"},"# output"),c("\n"),o("span",{class:"token comment"},"# dirl "),c("\n"),o("span",{class:"token comment"},"# dir2"),c("\n")])],-1),Ln=o("p",null,[c("上面是查找当前目录下的所有的目录类型。 注意这边 find 用的是 "),o("code",null,"*"),c("。这会去掉结果前面的 "),o("code",null,"./"),c(" 这个前缀。如果我们的 bash 版本在 4.4 以上，我们可以通过下面的一行命令完成。")],-1),jn=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[c("$ "),o("span",{class:"token builtin class-name"},"mapfile"),c(" -d $"),o("span",{class:"token string"},[c("'"),o("span",{class:"token entity",title:"\\0"},"\\0"),c("'")]),c(" array "),o("span",{class:"token operator"},"<"),c(),o("span",{class:"token operator"},"<"),o("span",{class:"token punctuation"},"("),o("span",{class:"token function"},"find"),c(" * -type d -print0"),o("span",{class:"token punctuation"},")"),c("\n"),o("span",{class:"token comment"},"# or "),c("\n$ "),o("span",{class:"token builtin class-name"},"readarray"),c(" -d "),o("span",{class:"token string"},"''"),c(" array2 "),o("span",{class:"token operator"},"<"),c(),o("span",{class:"token operator"},"<"),o("span",{class:"token punctuation"},"("),o("span",{class:"token function"},"find"),c(" * -type d -print0"),o("span",{class:"token punctuation"},")"),c("\n")])],-1),Cn=c(" man mapfile "),Rn=c(" man readarray "),Dn=o("h2",{id:"set"},[o("a",{class:"header-anchor",href:"#set","aria-hidden":"true"},"#"),c(" set")],-1),Jn=o("ul",null,[o("li",null,[o("code",null,"-x")])],-1),Pn=o("p",null,[c("在日常脚本中我们需要调试时，可以在脚本的开头或者是需要调试的函数附近加上 "),o("code",null,"set -x"),c("。这样在此之后的脚本都会以调试模式输出，在不想调试的代码前加上 "),o("code",null,"set +x"),c(" 以关闭调试功能。")],-1),Un=o("p",null,"在现代的 bash 脚本，支持在脚本内可以直接将调试的输出重定向到指定的文件内，方式如下：",-1),Wn=o("pre",{class:"language-bash"},[o("code",{class:"language-bash"},[o("span",{class:"token shebang important"},"#!/bin/bash"),c("\n\n"),o("span",{class:"token builtin class-name"},"exec"),c(),o("span",{class:"token number"},"1"),o("span",{class:"token operator"},[o("span",{class:"token file-descriptor important"},"9"),c(">")]),c("logfile\n"),o("span",{class:"token assign-left variable"},"BASH_XTRACEFD"),o("span",{class:"token operator"},"="),o("span",{class:"token number"},"19"),c("\n\n"),o("span",{class:"token builtin class-name"},"set"),c(" -x\ncommand1\ncommand2\n"),o("span",{class:"token punctuation"},".."),c(".\n")])],-1),Yn=o("p",null,[c("其中 "),o("code",null,"BASH_XTRACEFD"),c(" 是用来指定文件描述符给 "),o("code",null,"set -x"),c(" 的。")],-1),Zn=c("bash set -x log to file"),zn=c("redirect all output in a bash script when using set -x"),Gn={expose:[],setup(c){const Gn={title:"Bash In Action",date:"2021-05-01T00:00:00.000Z",author:"Linkang Chan",twitter:"JessEisen_LJ",description:"This is bash shell notes",public:!0,tag:"tech",meta:[{property:"og:title",content:"Bash In Action"},{property:"og:description",content:"This is bash shell notes"},{name:"description",content:"This is bash shell notes"}]};return a({title:"Bash In Action",meta:[{property:"og:title",content:"Bash In Action"},{property:"og:description",content:"This is bash shell notes"},{name:"description",content:"This is bash shell notes"}]}),(a,c)=>{const Kn=n,Mn=s;return e(),l(Mn,{frontmatter:Gn},{default:t((()=>[o("div",null,[p,r,i,u,k,d,b,g,h,m,f,$,y,v,w,x,F,T,_,E,I,O,H,A,B,S,q,X,L,j,C,R,D,J,P,U,W,Y,Z,z,G,K,M,N,Q,V,nn,sn,an,en,ln,tn,on,cn,pn,rn,un,kn,dn,bn,gn,hn,mn,fn,$n,yn,vn,wn,xn,Fn,Tn,_n,En,In,On,Hn,An,Bn,Sn,qn,Xn,Ln,jn,o("p",null,[o(Kn,{text:"mapfile doc",url:"https://linuxcommand.org/lc3_man_pages/mapfileh.html"},{default:t((()=>[Cn])),_:1}),o(Kn,{text:"readarray doc",url:"https://helpmanual.io/builtin/readarray/"},{default:t((()=>[Rn])),_:1})]),Dn,Jn,Pn,Un,Wn,Yn,o("p",null,[o(Kn,{text:"refernece1",url:"https://askubuntu.com/questions/811439/bash-set-x-logs-to-file"},{default:t((()=>[Zn])),_:1}),o(Kn,{text:"reference2",url:"https://stackoverflow.com/questions/11229385/redirect-all-output-in-a-bash-script-when-using-set-x"},{default:t((()=>[zn])),_:1})])])])),_:1})}}};export default Gn;

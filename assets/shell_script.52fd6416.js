import{_ as s}from"./InComing.vue_vue&type=script&setup=true&lang.f72f157d.js";import{_ as n}from"./ShortHR.7059e527.js";import{_ as a}from"./LinkItem.e13c2971.js";import{_ as e}from"./app.7a11c0f4.js";import{h as t,o as l,a as o,w as c,b as p,k as r}from"./vendor.57ddf3fb.js";const i=p("p",null,"bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。",-1),u=p("h2",{id:"目录和文件"},[p("a",{class:"header-anchor",href:"#目录和文件","aria-hidden":"true"},"#"),r(" 目录和文件")],-1),k=p("p",null,[r("遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个 "),p("code",null,"for"),r(" 循环，但是实际上我们可以有几种不同的方式来完成这些任务。")],-1),d=p("p",null,[p("strong",null,"find")],-1),b=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token function"},"find"),r(),p("span",{class:"token builtin class-name"},"."),r("   // 查找当前目录下所有的文件\n"),p("span",{class:"token function"},"find"),r(),p("span",{class:"token builtin class-name"},"."),r(" -name "),p("span",{class:"token string"},'"*.txt"'),r(" -type f   //find all txt "),p("span",{class:"token function"},"file"),r("\n"),p("span",{class:"token function"},"find"),r(),p("span",{class:"token builtin class-name"},"."),r(" -type f -name "),p("span",{class:"token string"},'"*.txt"'),r(" -print0 "),p("span",{class:"token operator"},"|"),r(),p("span",{class:"token function"},"xargs"),r(" -0 "),p("span",{class:"token function"},"fgrep"),r(" text\n")])],-1),g=p("p",null,[p("strong",null,"for")],-1),h=p("p",null,[r("正常的思路是使用 "),p("code",null,"for"),r(" 循环去遍历，使用 "),p("code",null,"for"),r(" 循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在 "),p("code",null,"bash4"),r(" 的版本下，可以开启 "),p("code",null,"globstar"),r(" 或者 "),p("code",null,"dotglob"),r(" 这两个选项，区别在于是否要匹配隐藏的文件。")],-1),m=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token builtin class-name"},"shopt"),r(" -s globstar "),p("span",{class:"token operator"},"||"),r(),p("span",{class:"token builtin class-name"},"exit"),r("\n\n"),p("span",{class:"token keyword"},"for"),r(),p("span",{class:"token for-or-select variable"},"f"),r(),p("span",{class:"token keyword"},"in"),r(" **\n"),p("span",{class:"token keyword"},"do"),r("\n\t"),p("span",{class:"token keyword"},"if"),r(),p("span",{class:"token punctuation"},"["),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$f"),r('"')]),r(),p("span",{class:"token operator"},"="),r("~ "),p("span",{class:"token punctuation"},"\\"),r(".txt$ "),p("span",{class:"token punctuation"},"]"),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"then"),r("\n\t\t"),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$f"),r('"')]),r("\n\t"),p("span",{class:"token keyword"},"fi"),r("\n"),p("span",{class:"token keyword"},"done"),r("\n")])],-1),f=p("p",null,[r("这里面用到了两个技巧，一个是如果不支持 "),p("code",null,"globstar"),r(" 就退出脚本执行，另一个是 "),p("code",null,"if"),r(" 的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。")],-1),$=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token keyword"},"function"),r(),p("span",{class:"token function-name function"},"walk_tree"),p("span",{class:"token punctuation"},"("),p("span",{class:"token punctuation"},")"),r("\n"),p("span",{class:"token punctuation"},"{"),r("\n\t"),p("span",{class:"token keyword"},"for"),r(),p("span",{class:"token for-or-select variable"},"f"),r(),p("span",{class:"token keyword"},"in"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$1"),r('"')]),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"do"),r("\n\t\t"),p("span",{class:"token keyword"},"if"),r(),p("span",{class:"token punctuation"},"["),r(" -d "),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$f"),r('"')]),p("span",{class:"token punctuation"},"]"),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"then"),r("\n\t\t\twalk_tree "),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$f"),r('"')]),r("\n\t\t"),p("span",{class:"token keyword"},"else"),r("\n\t\t\t"),p("span",{class:"token assign-left variable"},"fullpath"),p("span",{class:"token operator"},"="),p("span",{class:"token variable"},[p("span",{class:"token variable"},"`"),r("readlink -f "),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$f"),r('"')]),p("span",{class:"token variable"},"`")]),r("\n\t\t\t"),p("span",{class:"token keyword"},"if"),r(),p("span",{class:"token punctuation"},"["),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$fullpath"),r('"')]),r(),p("span",{class:"token operator"},"="),r("~ "),p("span",{class:"token punctuation"},"\\"),r(".txt$ "),p("span",{class:"token punctuation"},"]"),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"then"),r("\n\t\t\t\t"),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$fullpath"),r('"')]),r("\n\t\t\t"),p("span",{class:"token keyword"},"fi"),r("\n\t"),p("span",{class:"token keyword"},"done"),r("\n"),p("span",{class:"token punctuation"},"}"),r("\n")])],-1),y=p("p",null,[r("有两个可以注意的点是： "),p("code",null,"readlink -f"),r(" 可以输出文件的完整路径。同时 "),p("code",null,"$f"),r(" 本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题 "),p("code",null,"find"),r(" 是首选的。其次不需要使用递归也是一个非常棒的方式。 "),p("code",null,"find"),r(" 配合上 "),p("code",null,"exec"),r(" 和 "),p("code",null,"xargs"),r(" 同样可以执行一些简单的命令。")],-1),v=p("h2",{id:"重定向"},[p("a",{class:"header-anchor",href:"#重定向","aria-hidden":"true"},"#"),r(" 重定向")],-1),w=p("p",null,[r("重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是 "),p("code",null,">"),r(" ,"),p("code",null,">>"),r(" 这两个。下面是简单的一些记录很处理。")],-1),x=p("p",null,[p("strong",null,"描述符复制")],-1),_=p("blockquote",null,[p("p",null,[p("code",null,"n>&m"),r(" 将描述符 n 指向 m 所指向的位置。")])],-1),F=p("p",null,[r("我们一般使用 "),p("code",null,"exec"),r(" 来执行描述符之间的复制。")],-1),S=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[r("$ "),p("span",{class:"token builtin class-name"},"exec"),r(),p("span",{class:"token number"},"3"),r(),p("span",{class:"token operator"},"<"),r(),p("span",{class:"token function"},"file"),r("\n$ "),p("span",{class:"token builtin class-name"},"exec"),r(),p("span",{class:"token operator"},[p("span",{class:"token file-descriptor important"},"4"),r(">")]),p("span",{class:"token file-descriptor important"},"&3"),r("\n$ "),p("span",{class:"token builtin class-name"},"read"),r(" -u "),p("span",{class:"token number"},"4"),r(" line\n$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$line"),r('"')]),r("\n")])],-1),E=p("p",null,"上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。",-1),H=p("p",null,[p("strong",null,"重定向顺序")],-1),I=p("blockquote",null,[p("p",null,[p("code",null,"2>&1 >foo"),r(),p("strong",null,"描述符 2 和 描述符 1 指向不同的位置。")]),p("p",null,[p("code",null,">foo 2>&1"),r(),p("strong",null,"描述符 2 和 描述符 1 指向相同的位置。")])],-1),O=p("p",null,[p("strong",null,"关闭描述符")],-1),T=p("ul",null,[p("li",null,"n<&- 关闭一个输入的文件描述符"),p("li",null,"n>&- 关闭一个输出的文件描述符")],-1),B=p("p",null,[p("strong",null,"read 命令中使用重定向")],-1),j=p("p",null,"常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下：",-1),q=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[p("span",{class:"token keyword"},"while"),r(),p("span",{class:"token builtin class-name"},"read"),r(" -r line"),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"do"),r("\n\t"),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$line"),r('"')]),r("\n"),p("span",{class:"token keyword"},"done"),r(),p("span",{class:"token operator"},"<"),r(),p("span",{class:"token function"},"file"),r("\n")])],-1),X=p("p",null,"然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。",-1),A=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[p("span",{class:"token builtin class-name"},"exec"),r(),p("span",{class:"token number"},"3"),r(),p("span",{class:"token operator"},"<"),r(),p("span",{class:"token function"},"file"),r("\n"),p("span",{class:"token keyword"},"while"),r(),p("span",{class:"token builtin class-name"},"read"),r(" -u "),p("span",{class:"token number"},"3"),r(" line"),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"do"),r("\n\t"),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$line"),r('"')]),r("\n\t"),p("span",{class:"token builtin class-name"},"read"),r(" -p "),p("span",{class:"token string"},'"continue to read?"'),r(" -n "),p("span",{class:"token number"},"1"),r("\n"),p("span",{class:"token keyword"},"done"),r("\n")])],-1),C=p("p",null,"这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。",-1),L=p("h2",{id:"here-document-和-here-strings"},[p("a",{class:"header-anchor",href:"#here-document-和-here-strings","aria-hidden":"true"},"#"),r(" Here document 和 Here strings")],-1),N=p("p",null,"实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。",-1),R=p("p",null,[p("strong",null,"Here document")],-1),D=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[p("span",{class:"token builtin class-name"},"command"),r(),p("span",{class:"token operator"},"<<"),p("span",{class:"token punctuation"},"["),r("-"),p("span",{class:"token punctuation"},"]"),r("word\n"),p("span",{class:"token punctuation"},".."),r(".\n"),p("span",{class:"token punctuation"},".."),r(".\nword\n")])],-1),J=p("p",null,[r("here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的 "),p("code",null,"-"),r(" 。使用 "),p("code",null,"<<-"),r(" 会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。")],-1),P=p("p",null,[r("另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如 "),p("code",null,"'EOF'"),r(" 这个会抑制后面中的变量的展开。简单的示例如下：")],-1),U=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[r("$ "),p("span",{class:"token function"},"cat"),r(),p("span",{class:"token operator"},"<<"),r(),p("span",{class:"token string"},"'EOF'"),r("\n"),p("span",{class:"token operator"},">"),r(" This is my name "),p("span",{class:"token variable"},"$name"),r("\n"),p("span",{class:"token operator"},">"),r(" EOF\nThis is my name "),p("span",{class:"token variable"},"$name"),r("\n")])],-1),W=p("p",null,"同时 Here document 也是可以在管道中使用的，简单的示例如下：",-1),Y=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[r("$ "),p("span",{class:"token function"},"cat"),r(),p("span",{class:"token operator"},"<<"),r(),p("span",{class:"token string"},"'EOF'"),r(),p("span",{class:"token operator"},"|"),r(),p("span",{class:"token function"},"sed"),r(),p("span",{class:"token string"},"'s/a/b/g'"),r("\n"),p("span",{class:"token operator"},">"),r(" abc\n"),p("span",{class:"token operator"},">"),r(" nab\n"),p("span",{class:"token operator"},">"),r(" EOF\nbbc\nnbb\n")])],-1),Z=p("p",null,"还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用：",-1),z=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[p("span",{class:"token function"},"cat"),r(),p("span",{class:"token operator"},"<<"),r(),p("span",{class:"token string"},[r("EOF"),p("span",{class:"token bash punctuation"},[r(),p("span",{class:"token operator"},">"),r(" filename")]),r("\naaaa\nbbb\nccc\nEOF")]),r("\n")])],-1),G=p("p",null,[p("strong",null,"Here strings")],-1),K=p("p",null,"大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。",-1),M=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[r("$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},'"Hello World"'),r(),p("span",{class:"token operator"},"|"),r(),p("span",{class:"token builtin class-name"},"read"),r(" first second\n$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$first"),r('"')]),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$second"),r('"')]),r("\n"),p("span",{class:"token comment"},"# nothing"),r("\n")])],-1),Q=p("p",null,"此时使用 here strings 则就很合适了。",-1),V=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[r("$ "),p("span",{class:"token builtin class-name"},"read"),r(" first second "),p("span",{class:"token operator"},"<<<"),r(),p("span",{class:"token string"},'"hello world"'),r("\n$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$first"),r('"')]),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$second"),r('"')]),r("\nhello world\n")])],-1),ss=p("h2",{id:"数学计算"},[p("a",{class:"header-anchor",href:"#数学计算","aria-hidden":"true"},"#"),r(" 数学计算")],-1),ns=p("p",null,[r("数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是 "),p("code",null,"(( ))"),r(" ， 有时我们还会使用 "),p("code",null,"$(( ))"),r(" 这个是 POSIX 的一个形式。")],-1),as=p("p",null,[r("bash 中有一个语法，用来转换进制的。即："),p("code",null,"<base>#number"),r(" 我们可以直接在 "),p("code",null,"$(( ))"),r(" 中使用。其次在数学计算符中可以不用使用 "),p("code",null,"$"),r(" 符来引用变量。")],-1),es=p("pre",{class:"language-shell"},[p("code",{class:"language-shell"},[r("$ "),p("span",{class:"token variable"},[p("span",{class:"token punctuation"},"(("),r("a"),p("span",{class:"token operator"},"="),p("span",{class:"token number"},"1"),p("span",{class:"token punctuation"},","),r(" a"),p("span",{class:"token operator"},"+"),p("span",{class:"token operator"},"="),p("span",{class:"token number"},"2"),p("span",{class:"token punctuation"},"))")]),r("\n$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token variable"},"$a"),r("\n"),p("span",{class:"token number"},"3"),r("\n$ "),p("span",{class:"token builtin class-name"},"printf"),r(),p("span",{class:"token string"},[r("'%d"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token variable"},[p("span",{class:"token variable"},"$(("),p("span",{class:"token number"},"1"),p("span",{class:"token operator"},"+"),p("span",{class:"token number"},"3"),p("span",{class:"token variable"},"))")]),r("\n"),p("span",{class:"token number"},"4"),r("\n")])],-1),ts=p("p",null,[r("在 "),p("code",null,"$(( )) "),r(" 中也是支持变量操作的。比如：")],-1),ls=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[r("$ "),p("span",{class:"token variable"},[p("span",{class:"token punctuation"},"(("),r("a"),p("span",{class:"token operator"},"="),p("span",{class:"token number"},"16"),r("#abc"),p("span",{class:"token punctuation"},","),r(" b"),p("span",{class:"token operator"},"="),p("span",{class:"token number"},"16"),r("#${a"),p("span",{class:"token operator"},":"),p("span",{class:"token number"},"0"),p("span",{class:"token operator"},":"),p("span",{class:"token number"},"2"),r("}"),p("span",{class:"token punctuation"},"))")]),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token builtin class-name"},"printf"),r(),p("span",{class:"token string"},[r("'%s, %s"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token variable"},"$a"),r(),p("span",{class:"token variable"},"$b"),r("\n"),p("span",{class:"token number"},"2748"),r(", "),p("span",{class:"token number"},"39"),r("\n")])],-1),os=p("p",null,"注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中：",-1),cs=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[r("$ "),p("span",{class:"token assign-left variable"},"x"),p("span",{class:"token operator"},"="),p("span",{class:"token number"},"1"),r("\n$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token variable"},[p("span",{class:"token variable"},"$(("),r("$x["),p("span",{class:"token number"},"0"),r("]"),p("span",{class:"token variable"},"))")]),r(),p("span",{class:"token comment"},"# 将会被扩展为 $((1[0]))"),r("\nbash: "),p("span",{class:"token number"},"1"),p("span",{class:"token punctuation"},"["),p("span",{class:"token number"},"0"),p("span",{class:"token punctuation"},"]"),r(": syntax error: invalid arithmetic operator "),p("span",{class:"token punctuation"},"("),r("error token is "),p("span",{class:"token string"},'"[0]"'),p("span",{class:"token punctuation"},")"),r("\n$ "),p("span",{class:"token builtin class-name"},"printf"),r(),p("span",{class:"token string"},[r("'%d"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token variable"},[p("span",{class:"token variable"},"$(("),r("${x["),p("span",{class:"token number"},"0"),r("]}"),p("span",{class:"token variable"},"))")]),r("\n"),p("span",{class:"token number"},"1"),r("\n$ "),p("span",{class:"token builtin class-name"},"printf"),r(),p("span",{class:"token string"},[r("'%d"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token variable"},[p("span",{class:"token variable"},"$(("),r('"$x" '),p("span",{class:"token operator"},"=="),r(),p("span",{class:"token number"},"1"),p("span",{class:"token variable"},"))")]),r("  "),p("span",{class:"token comment"},'# 解析为 $(("1"))'),r("\n"),p("span",{class:"token number"},"1"),r("\n")])],-1),ps=p("p",null,"此外，我们也可以用变量扩展作为布尔值的判断。比如：",-1),rs=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token keyword"},"if"),r(),p("span",{class:"token variable"},[p("span",{class:"token punctuation"},"(("),p("span",{class:"token number"},"1"),r(),p("span",{class:"token operator"},"=="),r(),p("span",{class:"token number"},"2"),p("span",{class:"token punctuation"},"))")]),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"then"),r("\n\t"),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},'"true"'),r("\n"),p("span",{class:"token keyword"},"else"),r("\n\t"),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},'"false"'),r("\n"),p("span",{class:"token keyword"},"fi"),r("\n"),p("span",{class:"token comment"},"# false"),r("\n")])],-1),is=p("h2",{id:"echo-输出"},[p("a",{class:"header-anchor",href:"#echo-输出","aria-hidden":"true"},"#"),r(" echo 输出")],-1),us=p("p",null,[r("echo 在使用 "),p("code",null,"-e"),r(" 的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过 "),p("code",null,"$'string'"),r(" 的方式来进行。比如：")],-1),ks=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[r("$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},'"This is a line"'),r("$"),p("span",{class:"token string"},[r("'"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r("\nThis is a line\n\n$\n")])],-1),ds=p("h2",{id:"trap"},[p("a",{class:"header-anchor",href:"#trap","aria-hidden":"true"},"#"),r(" trap")],-1),bs=p("p",null,"trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子：",-1),gs=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token builtin class-name"},"trap"),r(),p("span",{class:"token string"},[r("'[ "),p("span",{class:"token variable"},"$?"),r(" -eq 0 ] || dosomething'")]),r(" EXIT\n")])],-1),hs=p("h2",{id:"split"},[p("a",{class:"header-anchor",href:"#split","aria-hidden":"true"},"#"),r(" split")],-1),ms=p("p",null,"split 在 shell 中并不是原生支持，需要自己实现一个函数，一般使用 read 来实现。",-1),fs=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token function-name function"},"split"),p("span",{class:"token punctuation"},"("),p("span",{class:"token punctuation"},")"),r(),p("span",{class:"token punctuation"},"{"),r("\n   "),p("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),r("\n   "),p("span",{class:"token assign-left variable"},[p("span",{class:"token environment constant"},"IFS")]),p("span",{class:"token operator"},"="),r("$"),p("span",{class:"token string"},[r("'"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token builtin class-name"},"read"),r(" -d "),p("span",{class:"token string"},'""'),r(" -ra arr "),p("span",{class:"token operator"},"<<<"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},[r("${1"),p("span",{class:"token operator"},"/"),p("span",{class:"token operator"},"/"),r("$2"),p("span",{class:"token operator"},"/"),r("$'\\n'}")]),r('"')]),r("\n   "),p("span",{class:"token builtin class-name"},"printf"),r(),p("span",{class:"token string"},[r("'%s"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},[r("${arr"),p("span",{class:"token punctuation"},"["),r("@"),p("span",{class:"token punctuation"},"]"),r("}")]),r('"')]),r("\n"),p("span",{class:"token punctuation"},"}"),r("\n")])],-1),$s=p("p",null,[r("这种方式在正常场景下并不会有问题，但是当我们设置了 "),p("code",null,"set -e"),r(" 后，上述实现就会提前退出。简单解释一下：")],-1),ys=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[r("$ "),p("span",{class:"token builtin class-name"},"read"),r(" -d "),p("span",{class:"token string"},"''"),r(),p("span",{class:"token operator"},"<<<"),r(),p("span",{class:"token string"},"'Hello World'"),r("\n$ "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token variable"},"$?"),r("\n"),p("span",{class:"token number"},"1"),r("\n")])],-1),vs=p("p",null,[r("这个方式在 while 循环中是非常友好的方式，但是由于设置 "),p("code",null,"set -e"),r(", 存在返回值不为0 的时候，程序会自动退出。这也就意味着 read 之后就直接 exit 了，所以我们需要简单的规避一下:")],-1),ws=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token function-name function"},"split"),p("span",{class:"token punctuation"},"("),p("span",{class:"token punctuation"},")"),r(),p("span",{class:"token punctuation"},"{"),r("\n   "),p("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),r("\n   "),p("span",{class:"token assign-left variable"},[p("span",{class:"token environment constant"},"IFS")]),p("span",{class:"token operator"},"="),r("$"),p("span",{class:"token string"},[r("'"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token builtin class-name"},"read"),r(" -d "),p("span",{class:"token string"},'""'),r(" -ra arr "),p("span",{class:"token operator"},"<<<"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},[r("${1"),p("span",{class:"token operator"},"/"),p("span",{class:"token operator"},"/"),r("$2"),p("span",{class:"token operator"},"/"),r("$'\\n'}")]),r('"')]),r(),p("span",{class:"token operator"},"||"),r(),p("span",{class:"token boolean"},"true"),r("\n   "),p("span",{class:"token builtin class-name"},"printf"),r(),p("span",{class:"token string"},[r("'%s"),p("span",{class:"token entity",title:"\\n"},"\\n"),r("'")]),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},[r("${arr"),p("span",{class:"token punctuation"},"["),r("@"),p("span",{class:"token punctuation"},"]"),r("}")]),r('"')]),r("\n"),p("span",{class:"token punctuation"},"}"),r("\n")])],-1),xs=p("p",null,[r("通过 "),p("code",null,"||"),r(" 将返回值重新变成 0 且逻辑上也是符合需求的。")],-1),_s=p("h2",{id:"tee-redirection"},[p("a",{class:"header-anchor",href:"#tee-redirection","aria-hidden":"true"},"#"),r(" tee redirection")],-1),Fs=p("p",null,"在 shell 中实现 tee 对 stdout 和 stderr 的重定向，可以使用如下的方式：",-1),Ss=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token builtin class-name"},"command"),r(),p("span",{class:"token operator"},">"),r(),p("span",{class:"token operator"},">"),p("span",{class:"token punctuation"},"("),p("span",{class:"token function"},"tee"),r(" -a stdout.log"),p("span",{class:"token punctuation"},")"),r(),p("span",{class:"token operator"},[p("span",{class:"token file-descriptor important"},"2"),r(">")]),r(),p("span",{class:"token operator"},">"),p("span",{class:"token punctuation"},"("),p("span",{class:"token function"},"tee"),r(" -a stderr.log "),p("span",{class:"token operator"},">"),p("span",{class:"token file-descriptor important"},"&2"),p("span",{class:"token punctuation"},")"),r("\n")])],-1),Es=p("p",null,[r("其中, "),p("code",null,">(...) (process substitution)"),r(" 创建一个 FIFO，同时将 command 的输出重定向到这个 FIFO 中。")],-1),Hs=p("h2",{id:"find"},[p("a",{class:"header-anchor",href:"#find","aria-hidden":"true"},"#"),r(" find")],-1),Is=p("p",null,"我们通常需要将 find 的结果放到一个 array 中。如果 bash 版本的比较低的时候，我们可以用通过如下的方式进行：",-1),Os=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token assign-left variable"},"array"),p("span",{class:"token operator"},"="),p("span",{class:"token punctuation"},"("),p("span",{class:"token punctuation"},")"),r("\n"),p("span",{class:"token keyword"},"while"),r(),p("span",{class:"token assign-left variable"},[p("span",{class:"token environment constant"},"IFS")]),p("span",{class:"token operator"},"="),r("  "),p("span",{class:"token builtin class-name"},"read"),r(" -r -d $"),p("span",{class:"token string"},[r("'"),p("span",{class:"token entity",title:"\\0"},"\\0"),r("'")]),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"do"),r("\n    "),p("span",{class:"token assign-left variable"},"array"),p("span",{class:"token operator"},"+="),p("span",{class:"token punctuation"},"("),p("span",{class:"token string"},[r('"'),p("span",{class:"token environment constant"},"$REPLY"),r('"')]),p("span",{class:"token punctuation"},")"),r("\n"),p("span",{class:"token keyword"},"done"),r(),p("span",{class:"token operator"},"<"),r(),p("span",{class:"token operator"},"<"),p("span",{class:"token punctuation"},"("),p("span",{class:"token function"},"find"),r(" * -type d  -print0"),p("span",{class:"token punctuation"},")"),r("\n\n"),p("span",{class:"token keyword"},"for"),r(),p("span",{class:"token for-or-select variable"},"item"),r(),p("span",{class:"token keyword"},"in"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},[r("${array"),p("span",{class:"token punctuation"},"["),r("@"),p("span",{class:"token punctuation"},"]"),r("}")]),r('"')]),p("span",{class:"token punctuation"},";"),r(),p("span",{class:"token keyword"},"do"),r("\n  "),p("span",{class:"token builtin class-name"},"echo"),r(),p("span",{class:"token string"},[r('"'),p("span",{class:"token variable"},"$item"),r('"')]),r("\n"),p("span",{class:"token keyword"},"done"),r("\n\n"),p("span",{class:"token comment"},"# output"),r("\n"),p("span",{class:"token comment"},"# dirl "),r("\n"),p("span",{class:"token comment"},"# dir2"),r("\n")])],-1),Ts=p("p",null,[r("上面是查找当前目录下的所有的目录类型。 注意这边 find 用的是 "),p("code",null,"*"),r("。这会去掉结果前面的 "),p("code",null,"./"),r(" 这个前缀。如果我们的 bash 版本在 4.4 以上，我们可以通过下面的一行命令完成。")],-1),Bs=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[r("$ "),p("span",{class:"token builtin class-name"},"mapfile"),r(" -d $"),p("span",{class:"token string"},[r("'"),p("span",{class:"token entity",title:"\\0"},"\\0"),r("'")]),r(" array "),p("span",{class:"token operator"},"<"),r(),p("span",{class:"token operator"},"<"),p("span",{class:"token punctuation"},"("),p("span",{class:"token function"},"find"),r(" * -type d -print0"),p("span",{class:"token punctuation"},")"),r("\n"),p("span",{class:"token comment"},"# or "),r("\n$ "),p("span",{class:"token builtin class-name"},"readarray"),r(" -d "),p("span",{class:"token string"},"''"),r(" array2 "),p("span",{class:"token operator"},"<"),r(),p("span",{class:"token operator"},"<"),p("span",{class:"token punctuation"},"("),p("span",{class:"token function"},"find"),r(" * -type d -print0"),p("span",{class:"token punctuation"},")"),r("\n")])],-1),js=r(" man mapfile "),qs=r(" man readarray "),Xs=p("h2",{id:"set"},[p("a",{class:"header-anchor",href:"#set","aria-hidden":"true"},"#"),r(" set")],-1),As=p("ul",null,[p("li",null,[p("code",null,"-x")])],-1),Cs=p("p",null,[r("在日常脚本中我们需要调试时，可以在脚本的开头或者是需要调试的函数附近加上 "),p("code",null,"set -x"),r("。这样在此之后的脚本都会以调试模式输出，在不想调试的代码前加上 "),p("code",null,"set +x"),r(" 以关闭调试功能。")],-1),Ls=p("p",null,"在现代的 bash 脚本，支持在脚本内可以直接将调试的输出重定向到指定的文件内，方式如下：",-1),Ns=p("pre",{class:"language-bash"},[p("code",{class:"language-bash"},[p("span",{class:"token shebang important"},"#!/bin/bash"),r("\n\n"),p("span",{class:"token builtin class-name"},"exec"),r(),p("span",{class:"token number"},"1"),p("span",{class:"token operator"},[p("span",{class:"token file-descriptor important"},"9"),r(">")]),r("logfile\n"),p("span",{class:"token assign-left variable"},"BASH_XTRACEFD"),p("span",{class:"token operator"},"="),p("span",{class:"token number"},"19"),r("\n\n"),p("span",{class:"token builtin class-name"},"set"),r(" -x\ncommand1\ncommand2\n"),p("span",{class:"token punctuation"},".."),r(".\n")])],-1),Rs=p("p",null,[r("其中 "),p("code",null,"BASH_XTRACEFD"),r(" 是用来指定文件描述符给 "),p("code",null,"set -x"),r(" 的。")],-1),Ds=r("bash set -x log to file"),Js=r("redirect all output in a bash script when using set -x"),Ps={expose:[],setup(r){const Ps={title:"Bash Script Skill Notes",date:"2021-01-18T00:00:00.000Z",author:"Linkang Chan",twitter:"JessEisen_LJ",description:"collections of bash script skill",public:!0,tag:"21B04 bash",meta:[{property:"og:title",content:"Bash Script Skill Notes"},{property:"og:description",content:"collections of bash script skill"},{name:"description",content:"collections of bash script skill"}]};return t({title:"Bash Script Skill Notes",meta:[{property:"og:title",content:"Bash Script Skill Notes"},{property:"og:description",content:"collections of bash script skill"},{name:"description",content:"collections of bash script skill"}]}),(t,r)=>{const Us=s,Ws=n,Ys=a,Zs=e;return l(),o(Zs,{frontmatter:Ps},{default:c((()=>[p("div",null,[p(Us,{comings:[{text:"command",url:"/notes/command"}]}),i,u,k,d,b,g,h,m,f,$,y,p(Ws),v,w,x,_,F,S,E,H,I,O,T,B,j,q,X,A,C,p(Ws),L,N,R,D,J,P,U,W,Y,Z,z,G,K,M,Q,V,p(Ws),ss,ns,as,es,ts,ls,os,cs,ps,rs,p(Ws),is,us,ks,p(Ws),ds,bs,gs,p(Ws),hs,ms,fs,$s,ys,vs,ws,xs,p(Ws),_s,Fs,Ss,Es,p(Ws),Hs,Is,Os,Ts,Bs,p("p",null,[p(Ys,{text:"mapfile doc",url:"https://linuxcommand.org/lc3_man_pages/mapfileh.html"},{default:c((()=>[js])),_:1}),p(Ys,{text:"readarray doc",url:"https://helpmanual.io/builtin/readarray/"},{default:c((()=>[qs])),_:1})]),p(Ws),Xs,As,Cs,Ls,Ns,Rs,p("p",null,[p(Ys,{text:"refernece1",url:"https://askubuntu.com/questions/811439/bash-set-x-logs-to-file"},{default:c((()=>[Ds])),_:1}),p(Ys,{text:"reference2",url:"https://stackoverflow.com/questions/11229385/redirect-all-output-in-a-bash-script-when-using-set-x"},{default:c((()=>[Js])),_:1})])])])),_:1})}}};export default Ps;

import{_ as n}from"./app.d0a9b53e.js";import{h as s,o as a,a as e,w as l,b as t,k as o}from"./vendor.57ddf3fb.js";const c=t("div",null,[t("p",null,"bash shell 这种古老而又古怪的语言，虽然在处理日常的工作时能很大提升效率，但是其一些语法是真的很难像其他语言一样信手拈来的就使用。所以这篇文章记录的是我日常工作中经常容易忘记的部分。"),t("h2",{id:"目录和文件"},[t("a",{class:"header-anchor",href:"#目录和文件","aria-hidden":"true"},"#"),o(" 目录和文件")]),t("p",null,[o("遍历目录和对目录中的文件进行操作时很常见的。很多情况下我们深度遍历一个目录可能会用两个 "),t("code",null,"for"),o(" 循环，但是实际上我们可以有几种不同的方式来完成这些任务。")]),t("p",null,[t("strong",null,"find")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token function"},"find"),o(),t("span",{class:"token builtin class-name"},"."),o("   // 查找当前目录下所有的文件\n"),t("span",{class:"token function"},"find"),o(),t("span",{class:"token builtin class-name"},"."),o(" -name "),t("span",{class:"token string"},'"*.txt"'),o(" -type f   //find all txt "),t("span",{class:"token function"},"file"),o("\n"),t("span",{class:"token function"},"find"),o(),t("span",{class:"token builtin class-name"},"."),o(" -type f -name "),t("span",{class:"token string"},'"*.txt"'),o(" -print0 "),t("span",{class:"token operator"},"|"),o(),t("span",{class:"token function"},"xargs"),o(" -0 "),t("span",{class:"token function"},"fgrep"),o(" text\n")])]),t("p",null,[t("strong",null,"for")]),t("p",null,[o("正常的思路是使用 "),t("code",null,"for"),o(" 循环去遍历，使用 "),t("code",null,"for"),o(" 循环也是有一定的技巧的，正常的情况是使用一个递归的方式遍历目录，但是在 "),t("code",null,"bash4"),o(" 的版本下，可以开启 "),t("code",null,"globstar"),o(" 或者 "),t("code",null,"dotglob"),o(" 这两个选项，区别在于是否要匹配隐藏的文件。")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token builtin class-name"},"shopt"),o(" -s globstar "),t("span",{class:"token operator"},"||"),o(),t("span",{class:"token builtin class-name"},"exit"),o("\n\n"),t("span",{class:"token keyword"},"for"),o(),t("span",{class:"token for-or-select variable"},"f"),o(),t("span",{class:"token keyword"},"in"),o(" **\n"),t("span",{class:"token keyword"},"do"),o("\n\t"),t("span",{class:"token keyword"},"if"),o(),t("span",{class:"token punctuation"},"["),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$f"),o('"')]),o(),t("span",{class:"token operator"},"="),o("~ "),t("span",{class:"token punctuation"},"\\"),o(".txt$ "),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"then"),o("\n\t\t"),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$f"),o('"')]),o("\n\t"),t("span",{class:"token keyword"},"fi"),o("\n"),t("span",{class:"token keyword"},"done"),o("\n")])]),t("p",null,[o("这里面用到了两个技巧，一个是如果不支持 "),t("code",null,"globstar"),o(" 就退出脚本执行，另一个是 "),t("code",null,"if"),o(" 的正则功能支持。话说回来，如果系统不支持这样的选项，那我们只能回到一个原始的方式了。")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token keyword"},"function"),o(),t("span",{class:"token function-name function"},"walk_tree"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),o("\n"),t("span",{class:"token punctuation"},"{"),o("\n\t"),t("span",{class:"token keyword"},"for"),o(),t("span",{class:"token for-or-select variable"},"f"),o(),t("span",{class:"token keyword"},"in"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$1"),o('"')]),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"do"),o("\n\t\t"),t("span",{class:"token keyword"},"if"),o(),t("span",{class:"token punctuation"},"["),o(" -d "),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$f"),o('"')]),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"then"),o("\n\t\t\twalk_tree "),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$f"),o('"')]),o("\n\t\t"),t("span",{class:"token keyword"},"else"),o("\n\t\t\t"),t("span",{class:"token assign-left variable"},"fullpath"),t("span",{class:"token operator"},"="),t("span",{class:"token variable"},[t("span",{class:"token variable"},"`"),o("readlink -f "),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$f"),o('"')]),t("span",{class:"token variable"},"`")]),o("\n\t\t\t"),t("span",{class:"token keyword"},"if"),o(),t("span",{class:"token punctuation"},"["),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$fullpath"),o('"')]),o(),t("span",{class:"token operator"},"="),o("~ "),t("span",{class:"token punctuation"},"\\"),o(".txt$ "),t("span",{class:"token punctuation"},"]"),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"then"),o("\n\t\t\t\t"),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$fullpath"),o('"')]),o("\n\t\t\t"),t("span",{class:"token keyword"},"fi"),o("\n\t"),t("span",{class:"token keyword"},"done"),o("\n"),t("span",{class:"token punctuation"},"}"),o("\n")])]),t("p",null,[o("有两个可以注意的点是： "),t("code",null,"readlink -f"),o(" 可以输出文件的完整路径。同时 "),t("code",null,"$f"),o(" 本身会带有相对的路径，所以不需要再传路径。实际上如果想要一行就解决问题 "),t("code",null,"find"),o(" 是首选的。其次不需要使用递归也是一个非常棒的方式。 "),t("code",null,"find"),o(" 配合上 "),t("code",null,"exec"),o(" 和 "),t("code",null,"xargs"),o(" 同样可以执行一些简单的命令。")]),t("hr"),t("h2",{id:"重定向"},[t("a",{class:"header-anchor",href:"#重定向","aria-hidden":"true"},"#"),o(" 重定向")]),t("p",null,[o("重定向在简单的使用上没有什么问题，但是涉及到文件描述符的复制时，往往会一脸懵。毕竟我们大多数时间使用的是 "),t("code",null,">"),o(" ,"),t("code",null,">>"),o(" 这两个。下面是简单的一些记录很处理。")]),t("p",null,[t("strong",null,"描述符复制")]),t("blockquote",null,[t("p",null,[t("code",null,"n>&m"),o(" 将描述符 n 指向 m 所指向的位置。")])]),t("p",null,[o("我们一般使用 "),t("code",null,"exec"),o(" 来执行描述符之间的复制。")]),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[o("$ "),t("span",{class:"token builtin class-name"},"exec"),o(),t("span",{class:"token number"},"3"),o(),t("span",{class:"token operator"},"<"),o(),t("span",{class:"token function"},"file"),o("\n$ "),t("span",{class:"token builtin class-name"},"exec"),o(),t("span",{class:"token operator"},[t("span",{class:"token file-descriptor important"},"4"),o(">")]),t("span",{class:"token file-descriptor important"},"&3"),o("\n$ "),t("span",{class:"token builtin class-name"},"read"),o(" -u "),t("span",{class:"token number"},"4"),o(" line\n$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$line"),o('"')]),o("\n")])]),t("p",null,"上面的将文件 file 打开并用描述符 3 表示。接着用描述符 4 来复制描述符 3。接着从描述符 4 中读取内容，这个内容就是 file 中的内容了。这就表示此时描述符 3 和描述符 4 指向了同一个位置。"),t("p",null,[t("strong",null,"重定向顺序")]),t("blockquote",null,[t("p",null,[t("code",null,"2>&1 >foo"),o(),t("strong",null,"描述符 2 和 描述符 1 指向不同的位置。")]),t("p",null,[t("code",null,">foo 2>&1"),o(),t("strong",null,"描述符 2 和 描述符 1 指向相同的位置。")])]),t("p",null,[t("strong",null,"关闭描述符")]),t("ul",null,[t("li",null,"n<&- 关闭一个输入的文件描述符"),t("li",null,"n>&- 关闭一个输出的文件描述符")]),t("p",null,[t("strong",null,"read 命令中使用重定向")]),t("p",null,"常规使用 read 读取文件中所有的内容时，我们会使用一个简单的重定向，简单的示例代码如下："),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[t("span",{class:"token keyword"},"while"),o(),t("span",{class:"token builtin class-name"},"read"),o(" -r line"),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"do"),o("\n\t"),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$line"),o('"')]),o("\n"),t("span",{class:"token keyword"},"done"),o(),t("span",{class:"token operator"},"<"),o(),t("span",{class:"token function"},"file"),o("\n")])]),t("p",null,"然而我们此时我们想在循环体内容再一次使用 read 读取标准输入时，就会出错了。这时使用指定描述符的方式可以解决这个问题。"),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[t("span",{class:"token builtin class-name"},"exec"),o(),t("span",{class:"token number"},"3"),o(),t("span",{class:"token operator"},"<"),o(),t("span",{class:"token function"},"file"),o("\n"),t("span",{class:"token keyword"},"while"),o(),t("span",{class:"token builtin class-name"},"read"),o(" -u "),t("span",{class:"token number"},"3"),o(" line"),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"do"),o("\n\t"),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$line"),o('"')]),o("\n\t"),t("span",{class:"token builtin class-name"},"read"),o(" -p "),t("span",{class:"token string"},'"continue to read?"'),o(" -n "),t("span",{class:"token number"},"1"),o("\n"),t("span",{class:"token keyword"},"done"),o("\n")])]),t("p",null,"这样就能够很好区分开不同的描述符，不至于使得后面的使用会出错。"),t("hr"),t("h2",{id:"here-document-和-here-strings"},[t("a",{class:"header-anchor",href:"#here-document-和-here-strings","aria-hidden":"true"},"#"),o(" Here document 和 Here strings")]),t("p",null,"实际上这两者都是基于重定向的，不过在某些时候还是很有用的。比如 here document 在输出 usage 的时候就有很好的使用，但是这里面的使用还是有一定的技巧的。"),t("p",null,[t("strong",null,"Here document")]),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[t("span",{class:"token builtin class-name"},"command"),o(),t("span",{class:"token operator"},"<<"),t("span",{class:"token punctuation"},"["),o("-"),t("span",{class:"token punctuation"},"]"),o("word\n"),t("span",{class:"token punctuation"},".."),o(".\n"),t("span",{class:"token punctuation"},".."),o(".\nword\n")])]),t("p",null,[o("here document 的使用中有两个技巧，从上面的语法描述上能够看到那个可选的 "),t("code",null,"-"),o(" 。使用 "),t("code",null,"<<-"),o(" 会将文本中的前导 tab 都删除，这就意味着文本不是原样输出。")]),t("p",null,[o("另一个技巧时在 word 上。一般我们会取一个关键字用来标记输入的结束，但是这个 word 如果加上了单引号，比如 "),t("code",null,"'EOF'"),o(" 这个会抑制后面中的变量的展开。简单的示例如下：")]),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[o("$ "),t("span",{class:"token function"},"cat"),o(),t("span",{class:"token operator"},"<<"),o(),t("span",{class:"token string"},"'EOF'"),o("\n"),t("span",{class:"token operator"},">"),o(" This is my name "),t("span",{class:"token variable"},"$name"),o("\n"),t("span",{class:"token operator"},">"),o(" EOF\nThis is my name "),t("span",{class:"token variable"},"$name"),o("\n")])]),t("p",null,"同时 Here document 也是可以在管道中使用的，简单的示例如下："),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[o("$ "),t("span",{class:"token function"},"cat"),o(),t("span",{class:"token operator"},"<<"),o(),t("span",{class:"token string"},"'EOF'"),o(),t("span",{class:"token operator"},"|"),o(),t("span",{class:"token function"},"sed"),o(),t("span",{class:"token string"},"'s/a/b/g'"),o("\n"),t("span",{class:"token operator"},">"),o(" abc\n"),t("span",{class:"token operator"},">"),o(" nab\n"),t("span",{class:"token operator"},">"),o(" EOF\nbbc\nnbb\n")])]),t("p",null,"还有一个比较常见的需求是在脚本中将 cat 的内容输入到文件中，我们可以使用重定向。下面的示例是在脚本中使用："),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[t("span",{class:"token function"},"cat"),o(),t("span",{class:"token operator"},"<<"),o(),t("span",{class:"token string"},[o("EOF"),t("span",{class:"token bash punctuation"},[o(),t("span",{class:"token operator"},">"),o(" filename")]),o("\naaaa\nbbb\nccc\nEOF")]),o("\n")])]),t("p",null,[t("strong",null,"Here strings")]),t("p",null,"大部分情况下使用 here string 主要解决在出了管道之后，还能继续使用变量。我们知道管道等是在 subshell 中使用的。所以有些变量在出了这个作用域之后就不存在了。"),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[o("$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},'"Hello World"'),o(),t("span",{class:"token operator"},"|"),o(),t("span",{class:"token builtin class-name"},"read"),o(" first second\n$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$first"),o('"')]),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$second"),o('"')]),o("\n"),t("span",{class:"token comment"},"# nothing"),o("\n")])]),t("p",null,"此时使用 here strings 则就很合适了。"),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[o("$ "),t("span",{class:"token builtin class-name"},"read"),o(" first second "),t("span",{class:"token operator"},"<<<"),o(),t("span",{class:"token string"},'"hello world"'),o("\n$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$first"),o('"')]),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$second"),o('"')]),o("\nhello world\n")])]),t("hr"),t("h2",{id:"数学计算"},[t("a",{class:"header-anchor",href:"#数学计算","aria-hidden":"true"},"#"),o(" 数学计算")]),t("p",null,[o("数学计算在 shell 中有几种书写方式，但是太多的方式总会让人不知所措，所以还是只精通一种最好用的。实际上现在我们使用的最多的是 "),t("code",null,"(( ))"),o(" ， 有时我们还会使用 "),t("code",null,"$(( ))"),o(" 这个是 POSIX 的一个形式。")]),t("p",null,[o("bash 中有一个语法，用来转换进制的。即："),t("code",null,"<base>#number"),o(" 我们可以直接在 "),t("code",null,"$(( ))"),o(" 中使用。其次在数学计算符中可以不用使用 "),t("code",null,"$"),o(" 符来引用变量。")]),t("pre",{class:"language-shell"},[t("code",{class:"language-shell"},[o("$ "),t("span",{class:"token variable"},[t("span",{class:"token punctuation"},"(("),o("a"),t("span",{class:"token operator"},"="),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},","),o(" a"),t("span",{class:"token operator"},"+"),t("span",{class:"token operator"},"="),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},"))")]),o("\n$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token variable"},"$a"),o("\n"),t("span",{class:"token number"},"3"),o("\n$ "),t("span",{class:"token builtin class-name"},"printf"),o(),t("span",{class:"token string"},[o("'%d"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token variable"},[t("span",{class:"token variable"},"$(("),t("span",{class:"token number"},"1"),t("span",{class:"token operator"},"+"),t("span",{class:"token number"},"3"),t("span",{class:"token variable"},"))")]),o("\n"),t("span",{class:"token number"},"4"),o("\n")])]),t("p",null,[o("在 "),t("code",null,"$(( )) "),o(" 中也是支持变量操作的。比如：")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[o("$ "),t("span",{class:"token variable"},[t("span",{class:"token punctuation"},"(("),o("a"),t("span",{class:"token operator"},"="),t("span",{class:"token number"},"16"),o("#abc"),t("span",{class:"token punctuation"},","),o(" b"),t("span",{class:"token operator"},"="),t("span",{class:"token number"},"16"),o("#${a"),t("span",{class:"token operator"},":"),t("span",{class:"token number"},"0"),t("span",{class:"token operator"},":"),t("span",{class:"token number"},"2"),o("}"),t("span",{class:"token punctuation"},"))")]),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token builtin class-name"},"printf"),o(),t("span",{class:"token string"},[o("'%s, %s"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token variable"},"$a"),o(),t("span",{class:"token variable"},"$b"),o("\n"),t("span",{class:"token number"},"2748"),o(", "),t("span",{class:"token number"},"39"),o("\n")])]),t("p",null,"注意并不是所有的操作都是合法的，也有一些情况需要我们注意到。比如下面的例子中："),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[o("$ "),t("span",{class:"token assign-left variable"},"x"),t("span",{class:"token operator"},"="),t("span",{class:"token number"},"1"),o("\n$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token variable"},[t("span",{class:"token variable"},"$(("),o("$x["),t("span",{class:"token number"},"0"),o("]"),t("span",{class:"token variable"},"))")]),o(),t("span",{class:"token comment"},"# 将会被扩展为 $((1[0]))"),o("\nbash: "),t("span",{class:"token number"},"1"),t("span",{class:"token punctuation"},"["),t("span",{class:"token number"},"0"),t("span",{class:"token punctuation"},"]"),o(": syntax error: invalid arithmetic operator "),t("span",{class:"token punctuation"},"("),o("error token is "),t("span",{class:"token string"},'"[0]"'),t("span",{class:"token punctuation"},")"),o("\n$ "),t("span",{class:"token builtin class-name"},"printf"),o(),t("span",{class:"token string"},[o("'%d"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token variable"},[t("span",{class:"token variable"},"$(("),o("${x["),t("span",{class:"token number"},"0"),o("]}"),t("span",{class:"token variable"},"))")]),o("\n"),t("span",{class:"token number"},"1"),o("\n$ "),t("span",{class:"token builtin class-name"},"printf"),o(),t("span",{class:"token string"},[o("'%d"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token variable"},[t("span",{class:"token variable"},"$(("),o('"$x" '),t("span",{class:"token operator"},"=="),o(),t("span",{class:"token number"},"1"),t("span",{class:"token variable"},"))")]),o("  "),t("span",{class:"token comment"},'# 解析为 $(("1"))'),o("\n"),t("span",{class:"token number"},"1"),o("\n")])]),t("p",null,"此外，我们也可以用变量扩展作为布尔值的判断。比如："),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token keyword"},"if"),o(),t("span",{class:"token variable"},[t("span",{class:"token punctuation"},"(("),t("span",{class:"token number"},"1"),o(),t("span",{class:"token operator"},"=="),o(),t("span",{class:"token number"},"2"),t("span",{class:"token punctuation"},"))")]),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"then"),o("\n\t"),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},'"true"'),o("\n"),t("span",{class:"token keyword"},"else"),o("\n\t"),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},'"false"'),o("\n"),t("span",{class:"token keyword"},"fi"),o("\n"),t("span",{class:"token comment"},"# false"),o("\n")])]),t("hr"),t("h2",{id:"echo-输出"},[t("a",{class:"header-anchor",href:"#echo-输出","aria-hidden":"true"},"#"),o(" echo 输出")]),t("p",null,[o("echo 在使用 "),t("code",null,"-e"),o(" 的时候可以支持转义字符的输出，但是如果不想使用这个标记的时候，可以通过 "),t("code",null,"$'string'"),o(" 的方式来进行。比如：")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[o("$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},'"This is a line"'),o("$"),t("span",{class:"token string"},[o("'"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o("\nThis is a line\n\n$\n")])]),t("hr"),t("h2",{id:"trap"},[t("a",{class:"header-anchor",href:"#trap","aria-hidden":"true"},"#"),o(" trap")]),t("p",null,"trap 一般用于脚本退出时的一些状态清理工作，在捕捉到一定的信号后作出对应的作用。比较常用的是监听 EXIT 的事件。一个简单的例子："),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token builtin class-name"},"trap"),o(),t("span",{class:"token string"},[o("'[ "),t("span",{class:"token variable"},"$?"),o(" -eq 0 ] || dosomething'")]),o(" EXIT\n")])]),t("hr"),t("h2",{id:"split"},[t("a",{class:"header-anchor",href:"#split","aria-hidden":"true"},"#"),o(" split")]),t("p",null,"split 在 shell 中并不是原生支持，需要自己实现一个函数，一般使用 read 来实现。"),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token function-name function"},"split"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),o(),t("span",{class:"token punctuation"},"{"),o("\n   "),t("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),o("\n   "),t("span",{class:"token assign-left variable"},[t("span",{class:"token environment constant"},"IFS")]),t("span",{class:"token operator"},"="),o("$"),t("span",{class:"token string"},[o("'"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token builtin class-name"},"read"),o(" -d "),t("span",{class:"token string"},'""'),o(" -ra arr "),t("span",{class:"token operator"},"<<<"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},[o("${1"),t("span",{class:"token operator"},"/"),t("span",{class:"token operator"},"/"),o("$2"),t("span",{class:"token operator"},"/"),o("$'\\n'}")]),o('"')]),o("\n   "),t("span",{class:"token builtin class-name"},"printf"),o(),t("span",{class:"token string"},[o("'%s"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},[o("${arr"),t("span",{class:"token punctuation"},"["),o("@"),t("span",{class:"token punctuation"},"]"),o("}")]),o('"')]),o("\n"),t("span",{class:"token punctuation"},"}"),o("\n")])]),t("p",null,[o("这种方式在正常场景下并不会有问题，但是当我们设置了 "),t("code",null,"set -e"),o(" 后，上述实现就会提前退出。简单解释一下：")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[o("$ "),t("span",{class:"token builtin class-name"},"read"),o(" -d "),t("span",{class:"token string"},"''"),o(),t("span",{class:"token operator"},"<<<"),o(),t("span",{class:"token string"},"'Hello World'"),o("\n$ "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token variable"},"$?"),o("\n"),t("span",{class:"token number"},"1"),o("\n")])]),t("p",null,[o("这个方式在 while 循环中是非常友好的方式，但是由于设置 "),t("code",null,"set -e"),o(", 存在返回值不为0 的时候，程序会自动退出。这也就意味着 read 之后就直接 exit 了，所以我们需要简单的规避一下:")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token function-name function"},"split"),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),o(),t("span",{class:"token punctuation"},"{"),o("\n   "),t("span",{class:"token comment"},'# Usage: split "string" "delimiter"'),o("\n   "),t("span",{class:"token assign-left variable"},[t("span",{class:"token environment constant"},"IFS")]),t("span",{class:"token operator"},"="),o("$"),t("span",{class:"token string"},[o("'"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token builtin class-name"},"read"),o(" -d "),t("span",{class:"token string"},'""'),o(" -ra arr "),t("span",{class:"token operator"},"<<<"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},[o("${1"),t("span",{class:"token operator"},"/"),t("span",{class:"token operator"},"/"),o("$2"),t("span",{class:"token operator"},"/"),o("$'\\n'}")]),o('"')]),o(),t("span",{class:"token operator"},"||"),o(),t("span",{class:"token boolean"},"true"),o("\n   "),t("span",{class:"token builtin class-name"},"printf"),o(),t("span",{class:"token string"},[o("'%s"),t("span",{class:"token entity",title:"\\n"},"\\n"),o("'")]),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},[o("${arr"),t("span",{class:"token punctuation"},"["),o("@"),t("span",{class:"token punctuation"},"]"),o("}")]),o('"')]),o("\n"),t("span",{class:"token punctuation"},"}"),o("\n")])]),t("p",null,[o("通过 "),t("code",null,"||"),o(" 将返回值重新变成 0 且逻辑上也是符合需求的。")]),t("h2",{id:"tee-redirection"},[t("a",{class:"header-anchor",href:"#tee-redirection","aria-hidden":"true"},"#"),o(" tee redirection")]),t("p",null,"在 shell 中实现 tee 对 stdout 和 stderr 的重定向，可以使用如下的方式："),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token builtin class-name"},"command"),o(),t("span",{class:"token operator"},">"),o(),t("span",{class:"token operator"},">"),t("span",{class:"token punctuation"},"("),t("span",{class:"token function"},"tee"),o(" -a stdout.log"),t("span",{class:"token punctuation"},")"),o(),t("span",{class:"token operator"},[t("span",{class:"token file-descriptor important"},"2"),o(">")]),o(),t("span",{class:"token operator"},">"),t("span",{class:"token punctuation"},"("),t("span",{class:"token function"},"tee"),o(" -a stderr.log "),t("span",{class:"token operator"},">"),t("span",{class:"token file-descriptor important"},"&2"),t("span",{class:"token punctuation"},")"),o("\n")])]),t("p",null,[o("其中, "),t("code",null,">(...) (process substitution)"),o(" 创建一个 FIFO，同时将 command 的输出重定向到这个 FIFO 中。")]),t("h2",{id:"find"},[t("a",{class:"header-anchor",href:"#find","aria-hidden":"true"},"#"),o(" find")]),t("p",null,"我们通常需要将 find 的结果放到一个 array 中。如果 bash 版本的比较低的时候，我们可以用通过如下的方式进行："),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token assign-left variable"},"array"),t("span",{class:"token operator"},"="),t("span",{class:"token punctuation"},"("),t("span",{class:"token punctuation"},")"),o("\n"),t("span",{class:"token keyword"},"while"),o(),t("span",{class:"token assign-left variable"},[t("span",{class:"token environment constant"},"IFS")]),t("span",{class:"token operator"},"="),o("  "),t("span",{class:"token builtin class-name"},"read"),o(" -r -d $"),t("span",{class:"token string"},[o("'"),t("span",{class:"token entity",title:"\\0"},"\\0"),o("'")]),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"do"),o("\n    "),t("span",{class:"token assign-left variable"},"array"),t("span",{class:"token operator"},"+="),t("span",{class:"token punctuation"},"("),t("span",{class:"token string"},[o('"'),t("span",{class:"token environment constant"},"$REPLY"),o('"')]),t("span",{class:"token punctuation"},")"),o("\n"),t("span",{class:"token keyword"},"done"),o(),t("span",{class:"token operator"},"<"),o(),t("span",{class:"token operator"},"<"),t("span",{class:"token punctuation"},"("),t("span",{class:"token function"},"find"),o(" * -type d  -print0"),t("span",{class:"token punctuation"},")"),o("\n\n"),t("span",{class:"token keyword"},"for"),o(),t("span",{class:"token for-or-select variable"},"item"),o(),t("span",{class:"token keyword"},"in"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},[o("${array"),t("span",{class:"token punctuation"},"["),o("@"),t("span",{class:"token punctuation"},"]"),o("}")]),o('"')]),t("span",{class:"token punctuation"},";"),o(),t("span",{class:"token keyword"},"do"),o("\n  "),t("span",{class:"token builtin class-name"},"echo"),o(),t("span",{class:"token string"},[o('"'),t("span",{class:"token variable"},"$item"),o('"')]),o("\n"),t("span",{class:"token keyword"},"done"),o("\n\n"),t("span",{class:"token comment"},"# output"),o("\n"),t("span",{class:"token comment"},"# dirl "),o("\n"),t("span",{class:"token comment"},"# dir2"),o("\n")])]),t("p",null,[o("上面是查找当前目录下的所有的目录类型。 注意这边 find 用的是 "),t("code",null,"*"),o("。这会去掉结果前面的 "),t("code",null,"./"),o(" 这个前缀。如果我们的 bash 版本在 4.4 以上，我们可以通过下面的一行命令完成。")]),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[o("$ "),t("span",{class:"token builtin class-name"},"mapfile"),o(" -d $"),t("span",{class:"token string"},[o("'"),t("span",{class:"token entity",title:"\\0"},"\\0"),o("'")]),o(" array "),t("span",{class:"token operator"},"<"),o(),t("span",{class:"token operator"},"<"),t("span",{class:"token punctuation"},"("),t("span",{class:"token function"},"find"),o(" * -type d -print0"),t("span",{class:"token punctuation"},")"),o("\n"),t("span",{class:"token comment"},"# or "),o("\n$ "),t("span",{class:"token builtin class-name"},"readarray"),o(" -d "),t("span",{class:"token string"},"''"),o(" array2 "),t("span",{class:"token operator"},"<"),o(),t("span",{class:"token operator"},"<"),t("span",{class:"token punctuation"},"("),t("span",{class:"token function"},"find"),o(" * -type d -print0"),t("span",{class:"token punctuation"},")"),o("\n")])]),t("ul",null,[t("li",null,[o("["),t("a",{href:"https://linuxcommand.org/lc3_man_pages/mapfileh.html",target:"_blank",rel:"noopener"},"man mapfile"),o("]")]),t("li",null,[o("["),t("a",{href:"https://helpmanual.io/builtin/readarray/",target:"_blank",rel:"noopener"},"man readarray"),o("]")])]),t("h2",{id:"set"},[t("a",{class:"header-anchor",href:"#set","aria-hidden":"true"},"#"),o(" set")]),t("ul",null,[t("li",null,[t("code",null,"-x")])]),t("p",null,[o("在日常脚本中我们需要调试时，可以在脚本的开头或者是需要调试的函数附近加上 "),t("code",null,"set -x"),o("。这样在此之后的脚本都会以调试模式输出，在不想调试的代码前加上 "),t("code",null,"set +x"),o(" 以关闭调试功能。")]),t("p",null,"在现代的 bash 脚本，支持在脚本内可以直接将调试的输出重定向到指定的文件内，方式如下："),t("pre",{class:"language-bash"},[t("code",{class:"language-bash"},[t("span",{class:"token shebang important"},"#!/bin/bash"),o("\n\n"),t("span",{class:"token builtin class-name"},"exec"),o(),t("span",{class:"token number"},"1"),t("span",{class:"token operator"},[t("span",{class:"token file-descriptor important"},"9"),o(">")]),o("logfile\n"),t("span",{class:"token assign-left variable"},"BASH_XTRACEFD"),t("span",{class:"token operator"},"="),t("span",{class:"token number"},"19"),o("\n\n"),t("span",{class:"token builtin class-name"},"set"),o(" -x\ncommand1\ncommand2\n"),t("span",{class:"token punctuation"},".."),o(".\n")])]),t("p",null,[o("其中 "),t("code",null,"BASH_XTRACEFD"),o(" 是用来指定文件描述符给 "),t("code",null,"set -x"),o(" 的。")]),t("ul",null,[t("li",null,[o("["),t("a",{href:"https://askubuntu.com/questions/811439/bash-set-x-logs-to-file",target:"_blank",rel:"noopener"},"reference1"),o("]")]),t("li",null,[o("["),t("a",{href:"https://stackoverflow.com/questions/11229385/redirect-all-output-in-a-bash-script-when-using-set-x",target:"_blank",rel:"noopener"},"reference2"),o("]")])])],-1),p={expose:[],setup(t){const o={title:"Bash In Action",date:"2021-05-01T00:00:00.000Z",author:"Linkang Chan",twitter:"JessEisen_LJ",description:"This is bash shell notes",public:!0,tag:"tech",meta:[{property:"og:title",content:"Bash In Action"},{property:"og:description",content:"This is bash shell notes"},{name:"description",content:"This is bash shell notes"}]};return s({title:"Bash In Action",meta:[{property:"og:title",content:"Bash In Action"},{property:"og:description",content:"This is bash shell notes"},{name:"description",content:"This is bash shell notes"}]}),(s,t)=>{const p=n;return a(),e(p,{frontmatter:o},{default:l((()=>[c])),_:1})}}};export default p;

### Q: 如何创建一个 socket 连接？

A:  在 Linux 编程中，创建一个 socket 连接是非常简单的。使用 `socket(2)` 函数接口，指定相应参数，函数返回一个 「套接字描述符」。

```c
int socket(int domain, int type, int protocol);
```

一般 domain 指定为 AF_INET 等；type 则可以指定为 SOCK_STREAM 等 ；protocol 这个一般会被置 0 ，这样可以用于 socket 选择对应类型的相关 protocol。



### Q: 如何创建一个服务器类型的 socket 连接？

A:  创建 *服务器* 类型的 socket 连接，需要经过四步，*socket(2)* , *bind(2)*, *listen(2)*, *accept(2)* 。 服务器类型的 socket 需要绑定 IP 和 端口号。这样客户端在发起 *connect(2)* 时才能找到需要连接的服务器，且服务器主机能正确找到相应的端口进行后续的操作。同时在绑定了端口号之后，服务器需要监听客户端的连接请求，使用 *listen(2)* 来进行监听，最后当有连接成功建立之后，需要通过*accept(2)*  接受客户端，并且生成相应的客户端套接字描述符。

上述的内容比较笼统，这之间包括很多细节，后面会更加细致的了解一下每个函数的以及 socket 的最基本的内容。

### Q:  IP 和 端口号如何设置？

A: 这个问题很笼统的回答就是： 将 IP 地址和端口号转换成网络字节序，赋值给相应的结构体即可。而这之间涉及到了几点需要深入了解的细节。

首先是字节序，由于不同的处理器所支持的字节序是不一样的，有的是大端，有的是小端，而网络通信是不同机器之间的通信，所以字节序需要统一，不然通信就会出错。所以 TCP 将不同的字节序转换成了统一的网络字节序， Linux 中提供了很多转换字节序的函数，最基本的四个操作整数的函数：

```c
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);  // 返回网络字节序
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);   // 返回主机字节序
```

从接口的定义上也能看出这四个函数适合对**端口号**进行相应的转换，函数比较简单就不多叙述。对于 IP 地址，现在比较推荐的两个函数是：

```c
#include <arpa/inet.h>
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
int inet_pton(int af, const char *src, void *dst);
```

这两个函数的作用是将 ip 地址根据不同的协议进行转换，通过 `af` 进行指定。函数中的 `void *`  的参数表示的则是相应的 IP 地址在 socket 中的表示形式。其他的函数不是很推荐使用，因为还是有些许的 bug 存在。

 现在说一说地址的数据结构的相关问题。这个结构用于保存 socket 的一些基本内容：协议族，端口号，IP 地址等。由于一些历史原因，一些函数接口使用的 IP 数据结构是通用的 ：

```c
 struct sockaddr {
     sa_family_t sa_family;
     char        sa_data[14];
 }
```

然而对于不同的协议是有单独的数据结构来表示对应的内容的。比如 IPv4 的使用的数据结构则是：

```c
struct sockaddr_in {
	short int           sin_family;   // Address family
	unsigned short int  sin_port;     // Port number
	struct in_addr      sin_addr;     // Internet address
	unsigned char       sin_zero[8];  // Same size as struct sockaddr
};
struct in_addr {
	uint32_t s_addr; // that's a 32-bit int (4 bytes)
};
```

从这之间可以看出 `ip` 地址保存在 `sin_addr` 中，这个结构体里面只有一个成员 `uint32_t s_addr` 。 对于 IPv6 而言，其数据结构是：

```c
struct sockaddr_in6 {
	u_int16_t 		sin6_family;   // address family, AF_INET6
	u_int16_t 		sin6_port; 	   // port number, Network Byte Order
	u_int32_t 		sin6_flowinfo; // IPv6 flow information
	struct in6_addr sin6_addr;     // IPv6 address
	u_int32_t 		sin6_scope_id; // Scope ID
};
struct in6_addr {
	unsigned char 	s6_addr[16]; // IPv6 address
};
```

上述的结构体内容可以通过 ` man 7 ip`  等来查询到。 这些地址在使用的时候需要对其进行类型转换，比如 `bind(2)` ，我们可以这样使用：

```c
struct sockaddr_in serv;
/* some assignment options */
bind(sockfd, (struct sockaddr *)&serv, sizeof(serv));
```

对于上面的字节转换函数我们则可以这样使用：

```c
char ip[INET_ADDRSTRLEN];
struct sockaddr_in serv;

inet_pton(AF_INET, "192.168.1.1", &(serv.sin_addr));
inet_ntop(AF_INET, &(serv.sin_addr), ip, INET_ADDRSTRLEN);
```

这两个数据结构在很多地方使用到，不过实际上我们可以使用更加方便更加稳妥的方式来操作地址结构体。



### Q: 如何更好的操作地址结构体？

首先需要看下，一般情况下我们是如何使用这些地址结构体的。拿服务器类型进行举例，通常的做法如下（暂时忽略掉错误检查）：

```c
int sockfd;
struct sockadd_in addr;

sockfd = socket(AF_INET, SOCK_STREAM, 0);

addr.sin_family = AF_INET;
addr.sin_port = htons(PORT);
addr.sin_addr.s_addr = inet_addr(INADDR_ANY);
bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
....
```

上面的做法是手动去填写用于 bind 的结构。 这个过程中需要我们进行字节序的转换等操作，这中间容易出错。实际上我们可以通过使用 `getaddrinfo` 来自动填充地址结构体，不过这个函数的使用熟悉一下，不同的参数组合所产生的结果是不一样的。函数的签名如下：

```c
int getaddrinfo(const char *node, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **res);

void freeaddrinfo(struct addrinfo *res);

const char *gai_strerror(int errcode);
```

前面两个参数是标识了一个 socket 的连接，hints 是设置的一些参数，最终的结果是保存在 res 里面，这边需要说一下新的结构体 `struct addrinfo` 。

```c
struct addrinfo {
      int              ai_flags;
      int              ai_family;
      int              ai_socktype;
      int              ai_protocol;
      socklen_t        ai_addrlen;
      struct sockaddr *ai_addr;
      char            *ai_canonname;
      struct addrinfo *ai_next;
};
```

这个结构和之前地址结构体里面的内容类似，这个函数所能做的事儿比较多，下面先说一下在创建 socket 连接的时候如何使用 `getaddrinfo` 自动填充相关内容。

```c
struct addrinfo hints, *res;
int    sockfd;

memset(&hints, 0, sizeof hints);
hints.ai_family   = AF_UNSPEC;    // use ipv4 or ipv6
hints.ai_socktype = SOCK_STREAM;  // tcp
hints.ai_flags    = AI_PASSIVE;   // use local ip to bind

getaddrinfo(NULL, "12345", &hints, &res);

sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
bind(sockfd, res->ai_addr, res->ai_addrlen);
```

上面是一个创建服务器的相关代码，我们设置了三个参数，其中最后一个 `AI_PASSIVE` 和 `getaddrinfo` 的第一个参数 `NULL` 是一个组合，效果同我们在 bind 的时候指定 `INADDR_ANY` 。 如果我们指定 `IP` 即第一个参数不为空的话，所设置的 `AI_PASSIVE` 则会被忽略掉。 不设置的 `AI_PASSIVE`  表示的话，所返回的结果可以用于 `connect(2), sendto(2), sendmsg(2)` 。通过下面的表简单说明一下参数设置的关系。

| ai_flags           | node     | result                                 |
| :----------------- | :------- | :------------------------------------- |
| AI_PASSIVE set     | NULL     | res 将包含 wildcard address 的效果，可以用于 bind |
| AI_PASSIVE set     | Not NULL | AI_PASSIVE 会被忽略，结果中的 addr 为指定的地址       |
| AI_PASSIVE not set | NULL     | addr 将被设置成 loopback 接口的地址。             |
| AI_PASSIVE not set | Not NULL | 结果中的 adrr 为指定的地址                       |

此外，第二参数 service 的设置与否也会有所影响，第二参数实际上是端口号的设置。简单的整理表格如下：

| ai_flags | service            | comment              |
| :------- | :----------------- | :------------------- |
| not set  | service name(ftp 等） | 返回通用服务的端口号           |
| not set  | 十进制的端口号（字符串型）      | 返回指定的端口号             |
|          | 必须为十进制的端口号（字符串型）   | 该 flag 禁止通用服务的端口号解析。 |

需要注意的是，如果一个域名包含多个 IP 地址的映射， 函数返回的则是一个链表形式的，可以通过一个遍历来选择所需要的的地址。

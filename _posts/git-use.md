---
layout: post
title: Git Use In Action
date: 2018-05-22 18:00:00
description: git use
---

这篇文章主要记录下在日常的不同场景下使用 git 的相关操作。 有时因为某个场景下不是经常碰到，所以命令操作比较生疏，然后需要各种查找，费时费力。且别人的站点有时候可能因为各种原因宕掉。索性自己总结一些，留着后面查阅。

### 一.基础操作
日常使用 git 的过程中，我们不是每次都是直接 `add -> commit -> push` 这么简单的流程。有时候我们会操作失误，或者在提交前需要对文件的修改做一些确认。这些算是 git 的最基本的，但是有些又不是常用的，所以了解这些有利于更好的使用 git。

在这之前，我们明确一下三个概念：

| 树                | 用途                 |
|:------------------|:--------------------|
| HEAD              | 上一次提交的快照，下一次提交的父节点 |
| index（暂存区）    | 预计下一次提交的快照         |
| working directory | 工作区，实际操作的地方       |

+ 查看版本库中的文件

比如我们想查看一下**某个版本**里面有哪些文件，可以使用：

```shell
git ls-tree -r version
```

如果想查看**暂存区**里面有哪些文件，可以使用：
```shell
git ls-files -s
```

+ 查看当前文件状态

在提交前，我们可以通过 `git status -s` 查看下具体的文件的所处的状态。比如:

```shell
$ git status -s
MM file3
A  file4
?? file5
```
具体标志解释如下：
    + 左边 M 表示修改已经放进了暂存区但是未提交到版本库
    + 右边 M 表示修改未放进暂存区
    + A 表示新加到暂存区的文件
    + ?? 表示文件未被追踪

这个在提交的时候一定程度上可以让我们清晰的看到当前文件的具体状态。

+ 查看提交历史

提交历史的选项比较多，一般都用 alias 来使用。亦或者使用 tig 这样的工具直观的展示这些。不过下面还是给出几个比较常用的选项。

    - git log -n  # 输出最近的 n 条提交
    - git log --oneline 
    - git log --pretty=format:"%h - %an: %s"  # hash值， 提交者，提交说明
    - git log --pretty=format:"%h %s" --graph
    - git log -Sxxx  #显示和关键词相关的提交

此外，`-p` 会以补丁的形式显示每个更新之间的差异。 其他的可以通过 `man git-log` 查询。


### 二.工作区和暂存区文件

工作区就是我们开发时操作的地方，我们所有未提交的修改都是放在工作区的，当我们执行 `git add` 命令时，修改才会被提交到暂存区， git 的暂存区指的是将需要提交的内容先放到暂存区，在下一次提交时，直接从暂存区提交到版本库。所以当在提交时，如果本地文件仍有修改，此修改是不会被提交到版本库的。下面是几个基础的操作：

+ 撤销工作区文件的修改

```shell
$ git checkout -- file # 撤销掉该文件在工作区中的修改
```
如果文件的修改没有添加到暂存区，那么 checkout 之后工作区该文件的修改都会丢失，没有办法找回来，所以除非是确认不需要了，否则慎用此命令。

+ 撤销暂存区里的提交

这个场景出现在我们执行了一次 `git add xxx` 之后，我们的修改被放到了暂存区了。但是发现有些内容不希望此次就提交到版本库。所以在 add 之后，我们将修改从暂存区里面撤出可以这样做：

```shell
$ git reset HEAD file  # 撤销 git add 操作
```
执行了这个操作之后，该文件在暂存区里面的修改将被撤销，工作区的修改仍然保留着。这个只是 reset 的命令的表象，实际上 git 是将 HEAD 中的 file 复制到暂存区里，不过也可以理解成这个命令是 git add 的逆操作，这个操作是工作区安全的。

在这边稍微衍生一下，我们可以看到命令中的 `HEAD` 表示的当前最新的版本，实际上我们可以将其换成**其他的版本号**。这个操作产生的效果则是将对应版本下的 file 复制到当前的暂存区中，如果此时执行 commit 操作，就意味着将当前版本库里面 file 恢复到指定版本中对应的 file。

此外 reset 还能做一些简单场景下的压缩提交，这会在后面详细的描述。

+ 删掉不想添加到版本库中的文件

有时我们在执行 add 时，会将一些 junk file 添加到 git 追踪里面，这种情况下，我我们可以使用 `git rm` 命令对文件进行撤销。

1. **删除版本库中文件，但不删除工作区中的文件**
    + 文件只提交到暂存区，未提交到版本库
    + 文件已经提交到版本库

这两个场景可以直接使用 `git rm --cached file` 即可。这个操作是撤销 git 对文件的追踪。后者在下一次提交的时候则会从版本库中删除掉。

1. **删除版本库中的文件，连同工作区文件**

直接 `git rm -f file`。

> 如果删除的文件之前被提交过，实际上我们还是可以找回来的，因为 git rm 是会有记录的。只不过在某些情况下，工作区未提交修改肯定是会丢失的。

### 三.回退版本库

+ 只回退版本库不影响暂存区和工作区

```shell
git reset --soft HEAD~n  # 回退 HEAD 到之前的 n 个版本
```
+ 回退暂存区里的内容，但不影响工作区

```shell
git reset [--mixed] HEAD~ 
```
将暂存区里面的内容用版本库里的覆盖掉。实际上也就是撤掉 git add 对暂存区的影响，这个操作会将所有加入暂存区中的内容都清掉，但是不会影响工作区。

+ 彻底回退三个区域

```shell
git reset --hard HEAD~
```
这个操作会将版本库、暂存区以及工作区都回退到上一个版本。所以如果工作区有未提交的，则会完全丢失了。即使是用 reflog 也无法找回未提交的部分，但是提交的了则可以找回。

<hr>

+ reset 压缩提交历史

一个简单的场景：当你在开发时，连续多次对同一个文件进行了提交，产生了多个版本。

这种情况下，我们可以将这些中间版本进行压缩。操作很简单，首先此时我们的暂存区和工作区的文件都是最终的版本，我们只需要将版本库里面的提交回退到指定的版本，然后再执行一次 commit 即可。

```shell
$ git reset --soft HEAD~3  # 回退到 HEAD 前面的第三个版本
$ git commit -m "xxx"
```
这样中间的提交历史都被删除掉了，而只剩下最终的一个版本，实际生产环境里面视情况进行操作。

### 四.分支

+ 分支创建

```shell
$ git branch -b xxx
```

+ 合并分支

```shell
$ git checkout master
$ git merger xxx
```

上述是将分支 xxx 合并到 master 分支上，在这个过程中可能出现冲突，git 会用相应的标记表示出来。之后我们手动的去 check 这些冲突，待冲突解决之后，我们再执行提交操作。



### 五.变基

### 六.远程版本库

### 七.存储和清理

### 八.常见问题

+ head detach

当 head 和我们最新的版本库不在同一个地方时，则会发生 `head detach` 的情况。解决办法是，先记住当前最新的版本的版本号，然后切换到 master 分支上，此时在 master 上创建一个新的临时分支，并指定最新的版本号。接着执行一次 merge 操作，即可将 HEAD 更新到最新的版本上。具体操作如下：

```shell
$ git log --oneline  # 取出最新的版本号，比如c922146
$ git checkout master
$ git branch -b temp c922146
$ git merge temp  # 冲突解决
$ git branch -d temp
```

